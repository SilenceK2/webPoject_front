/*[system-bundles-config]*/
System.bundles = {"bundles/can-import-module/test.css!":["qunit@2.19.4#qunit/qunit.css!steal-css@1.3.2#css"]};
/*npm-utils*/
define('npm-utils', function (require, exports, module) {
    (function (global, require, exports, module) {
        var slice = Array.prototype.slice;
        var npmModuleRegEx = /.+@.+\..+\..+#.+/;
        var conditionalModuleRegEx = /#\{[^\}]+\}|#\?.+$/;
        var gitUrlEx = /(git|http(s?)):\/\//;
        var supportsSet = typeof Set === 'function';
        var utils = {
            extend: function (d, s, deep, existingSet) {
                var val;
                var set = existingSet;
                if (deep) {
                    if (!set) {
                        if (supportsSet) {
                            set = new Set();
                        } else {
                            set = [];
                        }
                    }
                    if (supportsSet) {
                        if (set.has(s)) {
                            return s;
                        } else {
                            set.add(s);
                        }
                    } else {
                        if (set.indexOf(s) !== -1) {
                            return s;
                        } else {
                            set.push(s);
                        }
                    }
                }
                for (var prop in s) {
                    val = s[prop];
                    if (deep) {
                        if (utils.isArray(val)) {
                            d[prop] = slice.call(val);
                        } else if (utils.isPlainObject(val)) {
                            d[prop] = utils.extend({}, val, deep, set);
                        } else {
                            d[prop] = s[prop];
                        }
                    } else {
                        d[prop] = s[prop];
                    }
                }
                return d;
            },
            map: function (arr, fn) {
                var i = 0, len = arr.length, out = [];
                for (; i < len; i++) {
                    out.push(fn.call(arr, arr[i]));
                }
                return out;
            },
            filter: function (arr, fn) {
                var i = 0, len = arr.length, out = [], res;
                for (; i < len; i++) {
                    res = fn.call(arr, arr[i]);
                    if (res) {
                        out.push(arr[i]);
                    }
                }
                return out;
            },
            forEach: function (arr, fn) {
                var i = 0, len = arr.length;
                for (; i < len; i++) {
                    fn.call(arr, arr[i], i);
                }
            },
            flow: function (fns) {
                return function () {
                    var res = fns[0].apply(this, arguments);
                    for (var i = 1; i < fns.length; i++) {
                        res = fns[i].call(this, res);
                    }
                    return res;
                };
            },
            isObject: function (obj) {
                return typeof obj === 'object';
            },
            isPlainObject: function (obj) {
                return utils.isObject(obj) && (!obj || obj.__proto__ === Object.prototype);
            },
            isArray: Array.isArray || function (arr) {
                return Object.prototype.toString.call(arr) === '[object Array]';
            },
            isEnv: function (name) {
                return this.isEnv ? this.isEnv(name) : this.env === name;
            },
            isGitUrl: function (str) {
                return gitUrlEx.test(str);
            },
            warnOnce: function (msg) {
                var w = this._warnings = this._warnings || {};
                if (w[msg])
                    return;
                w[msg] = true;
                this.warn(msg);
            },
            warn: function (msg) {
                if (typeof steal !== 'undefined' && typeof console !== 'undefined' && console.warn) {
                    steal.done().then(function () {
                        if (steal.dev && steal.dev.warn) {
                        } else if (console.warn) {
                            console.warn('steal.js WARNING: ' + msg);
                        } else {
                            console.log(msg);
                        }
                    });
                }
            },
            relativeURI: function (baseURL, url) {
                return typeof steal !== 'undefined' ? steal.relativeURI(baseURL, url) : url;
            },
            moduleName: {
                create: function (descriptor, standard) {
                    if (standard) {
                        return descriptor.moduleName;
                    } else {
                        if (descriptor === '@empty') {
                            return descriptor;
                        }
                        var modulePath;
                        if (descriptor.modulePath) {
                            modulePath = descriptor.modulePath.substr(0, 2) === './' ? descriptor.modulePath.substr(2) : descriptor.modulePath;
                        }
                        var version = descriptor.version;
                        if (version && version[0] !== '^') {
                            version = encodeURIComponent(decodeURIComponent(version));
                        }
                        return descriptor.packageName + (version ? '@' + version : '') + (modulePath ? '#' + modulePath : '') + (descriptor.plugin ? descriptor.plugin : '');
                    }
                },
                isNpm: function (moduleName) {
                    return npmModuleRegEx.test(moduleName);
                },
                isConditional: function (moduleName) {
                    return conditionalModuleRegEx.test(moduleName);
                },
                isFullyConvertedNpm: function (parsedModuleName) {
                    return !!(parsedModuleName.packageName && parsedModuleName.version && parsedModuleName.modulePath);
                },
                isScoped: function (moduleName) {
                    return moduleName[0] === '@';
                },
                parse: function (moduleName, currentPackageName, global, context) {
                    var pluginParts = moduleName.split('!');
                    var modulePathParts = pluginParts[0].split('#');
                    var versionParts = modulePathParts[0].split('@');
                    if (!modulePathParts[1] && !versionParts[0]) {
                        versionParts = ['@' + versionParts[1]];
                    }
                    if (versionParts.length === 3 && utils.moduleName.isScoped(moduleName)) {
                        versionParts.splice(0, 1);
                        versionParts[0] = '@' + versionParts[0];
                    }
                    var packageName, modulePath;
                    if (currentPackageName && utils.path.isRelative(moduleName)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0];
                    } else if (currentPackageName && utils.path.isInHomeDir(moduleName, context)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0].split('/').slice(1).join('/');
                    } else {
                        if (modulePathParts[1]) {
                            packageName = versionParts[0];
                            modulePath = modulePathParts[1];
                        } else {
                            var folderParts = versionParts[0].split('/');
                            if (folderParts.length && folderParts[0][0] === '@') {
                                packageName = folderParts.splice(0, 2).join('/');
                            } else {
                                packageName = folderParts.shift();
                            }
                            modulePath = folderParts.join('/');
                        }
                    }
                    modulePath = utils.path.removeJS(modulePath);
                    return {
                        plugin: pluginParts.length === 2 ? '!' + pluginParts[1] : undefined,
                        version: versionParts[1],
                        modulePath: modulePath,
                        packageName: packageName,
                        moduleName: moduleName,
                        isGlobal: global
                    };
                },
                parseFromPackage: function (loader, refPkg, name, parentName) {
                    var packageName = utils.pkg.name(refPkg), parsedModuleName = utils.moduleName.parse(name, packageName, undefined, { loader: loader }), isRelative = utils.path.isRelative(parsedModuleName.modulePath);
                    if (isRelative && !parentName) {
                        throw new Error('Cannot resolve a relative module identifier ' + 'with no parent module:', name);
                    }
                    if (isRelative) {
                        var parentParsed = utils.moduleName.parse(parentName, packageName);
                        if (parentParsed.packageName === parsedModuleName.packageName && parentParsed.modulePath) {
                            var makePathRelative = true;
                            if (name === '../' || name === './' || name === '..') {
                                var relativePath = utils.path.relativeTo(parentParsed.modulePath, name);
                                var isInRoot = utils.path.isPackageRootDir(relativePath);
                                if (isInRoot) {
                                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                                    makePathRelative = false;
                                } else {
                                    parsedModuleName.modulePath = name + (utils.path.endsWithSlash(name) ? '' : '/') + 'index';
                                }
                            }
                            if (makePathRelative) {
                                parsedModuleName.modulePath = utils.path.makeRelative(utils.path.joinURIs(parentParsed.modulePath, parsedModuleName.modulePath));
                            }
                        }
                    }
                    var mapName = utils.moduleName.create(parsedModuleName), refSteal = utils.pkg.config(refPkg), mappedName;
                    if (refPkg.browser && typeof refPkg.browser !== 'string' && mapName in refPkg.browser && (!refSteal || !refSteal.ignoreBrowser)) {
                        mappedName = refPkg.browser[mapName] === false ? '@empty' : refPkg.browser[mapName];
                    }
                    var global = loader && loader.globalBrowser && loader.globalBrowser[mapName];
                    if (global) {
                        mappedName = global.moduleName === false ? '@empty' : global.moduleName;
                    }
                    if (mappedName) {
                        return utils.moduleName.parse(mappedName, packageName, !!global);
                    } else {
                        return parsedModuleName;
                    }
                },
                nameAndVersion: function (parsedModuleName) {
                    return parsedModuleName.packageName + '@' + parsedModuleName.version;
                },
                isBareIdentifier: function (identifier) {
                    return identifier && identifier[0] !== '.' && identifier[0] !== '@';
                }
            },
            pkg: {
                name: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.name || pkg.name;
                },
                main: function (pkg) {
                    var main;
                    var steal = utils.pkg.config(pkg);
                    if (steal && steal.main) {
                        main = steal.main;
                    } else if (typeof pkg.browser === 'string') {
                        if (utils.path.endsWithSlash(pkg.browser)) {
                            main = pkg.browser + 'index';
                        } else {
                            main = pkg.browser;
                        }
                    } else if (typeof pkg.jam === 'object' && pkg.jam.main) {
                        main = pkg.jam.main;
                    } else if (pkg.main) {
                        if (utils.path.endsWithSlash(pkg.main)) {
                            main = pkg.main + 'index';
                        } else {
                            main = pkg.main;
                        }
                    } else {
                        main = 'index';
                    }
                    return utils.path.removeJS(utils.path.removeDotSlash(main));
                },
                rootDir: function (pkg, isRoot) {
                    var root = isRoot ? utils.path.removePackage(pkg.fileUrl) : utils.path.pkgDir(pkg.fileUrl);
                    var lib = utils.pkg.directoriesLib(pkg);
                    if (lib) {
                        root = utils.path.joinURIs(utils.path.addEndingSlash(root), lib);
                    }
                    return root;
                },
                isRoot: function (loader, pkg) {
                    var root = utils.pkg.getDefault(loader);
                    return pkg && pkg.name === root.name && pkg.version === root.version;
                },
                homeAlias: function (context) {
                    return context && context.loader && context.loader.homeAlias || '~';
                },
                getDefault: function (loader) {
                    return loader.npmPaths.__default;
                },
                findByModuleNameOrAddress: function (loader, moduleName, moduleAddress) {
                    if (loader.npm) {
                        if (moduleName) {
                            var parsed = utils.moduleName.parse(moduleName);
                            if (parsed.version && parsed.packageName) {
                                var name = parsed.packageName + '@' + parsed.version;
                                if (name in loader.npm) {
                                    return loader.npm[name];
                                }
                            }
                        }
                        if (moduleAddress) {
                            var startingAddress = utils.relativeURI(loader.baseURL, moduleAddress);
                            var packageFolder = utils.pkg.folderAddress(startingAddress);
                            return packageFolder ? loader.npmPaths[packageFolder] : utils.pkg.getDefault(loader);
                        } else {
                            return utils.pkg.getDefault(loader);
                        }
                    }
                },
                folderAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                findDep: function (loader, refPkg, name) {
                    if (loader.npm && refPkg && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + refPkg.resolutions[name];
                        var pkg = loader.npm[nameAndVersion];
                        return pkg;
                    }
                },
                findDepWalking: function (loader, refPackage, name) {
                    if (loader.npm && refPackage && !utils.path.startsWithDotSlash(name)) {
                        var curPackage = utils.path.depPackageDir(refPackage.fileUrl, name);
                        while (curPackage) {
                            var pkg = loader.npmPaths[curPackage];
                            if (pkg) {
                                return pkg;
                            }
                            var parentAddress = utils.path.parentNodeModuleAddress(curPackage);
                            if (!parentAddress) {
                                return;
                            }
                            curPackage = parentAddress + '/' + name;
                        }
                    }
                },
                findByName: function (loader, name) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        return loader.npm[name];
                    }
                },
                findByNameAndVersion: function (loader, name, version) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + version;
                        return loader.npm[nameAndVersion];
                    }
                },
                findByUrl: function (loader, url) {
                    if (loader.npm) {
                        var fullUrl = utils.pkg.folderAddress(url);
                        return loader.npmPaths[fullUrl];
                    }
                },
                directoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    var lib = steal && steal.directories && steal.directories.lib;
                    var ignores = [
                            '.',
                            '/'
                        ], ignore;
                    if (!lib)
                        return undefined;
                    while (!!(ignore = ignores.shift())) {
                        if (lib[0] === ignore) {
                            lib = lib.substr(1);
                        }
                    }
                    return lib;
                },
                hasDirectoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.directories && !!steal.directories.lib;
                },
                findPackageInfo: function (context, pkg) {
                    var pkgInfo = context.pkgInfo;
                    if (pkgInfo) {
                        var out;
                        utils.forEach(pkgInfo, function (p) {
                            if (pkg.name === p.name && pkg.version === p.version) {
                                out = p;
                            }
                        });
                        return out;
                    }
                },
                saveResolution: function (context, refPkg, pkg) {
                    var npmPkg = utils.pkg.findPackageInfo(context, refPkg);
                    npmPkg.resolutions[pkg.name] = refPkg.resolutions[pkg.name] = pkg.version;
                },
                config: function (pkg) {
                    return pkg.steal || pkg.system;
                }
            },
            path: {
                makeRelative: function (path) {
                    if (utils.path.isRelative(path) && path.substr(0, 1) !== '/') {
                        return path;
                    } else {
                        return './' + path;
                    }
                },
                removeJS: function (path) {
                    return path.replace(/\.js(!|$)/, function (whole, part) {
                        return part;
                    });
                },
                removePackage: function (path) {
                    return path.replace(/\/package\.json.*/, '');
                },
                addJS: function (path) {
                    if (/\.m?js(on)?$/.test(path)) {
                        return path;
                    } else {
                        return path + '.js';
                    }
                },
                isRelative: function (path) {
                    return path.substr(0, 1) === '.';
                },
                isInHomeDir: function (path, context) {
                    return path.substr(0, 2) === utils.pkg.homeAlias(context) + '/';
                },
                joinURIs: function (baseUri, rel) {
                    function removeDotSegments(input) {
                        var output = [];
                        input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                            if (p === '/..') {
                                output.pop();
                            } else {
                                output.push(p);
                            }
                        });
                        return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
                    }
                    var href = parseURI(rel || '');
                    var base = parseURI(baseUri || '');
                    return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
                },
                startsWithDotSlash: function (path) {
                    return path.substr(0, 2) === './';
                },
                removeDotSlash: function (path) {
                    return utils.path.startsWithDotSlash(path) ? path.substr(2) : path;
                },
                endsWithSlash: function (path) {
                    return path[path.length - 1] === '/';
                },
                addEndingSlash: function (path) {
                    return utils.path.endsWithSlash(path) ? path : path + '/';
                },
                depPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return (packageFolderName ? packageFolderName + '/' : '') + 'node_modules/' + childName + '/package.json';
                },
                peerPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return packageFolderName.substr(0, packageFolderName.lastIndexOf('/')) + '/' + childName + '/package.json';
                },
                depPackageDir: function (parentPackageAddress, childName) {
                    return utils.path.depPackage(parentPackageAddress, childName).replace(/\/package\.json.*/, '');
                },
                peerNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules);
                    if (nodeModulesIndex >= 0) {
                        return address.substr(0, nodeModulesIndex + nodeModules.length - 1);
                    }
                },
                parentNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), prevModulesIndex = address.lastIndexOf(nodeModules, nodeModulesIndex - 1);
                    if (prevModulesIndex >= 0) {
                        return address.substr(0, prevModulesIndex + nodeModules.length - 1);
                    }
                },
                pkgDir: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (address[nodeModulesIndex + nodeModules.length] === '@') {
                        nextSlash = address.indexOf('/', nextSlash + 1);
                    }
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                basename: function (address) {
                    var parts = address.split('/');
                    return parts[parts.length - 1];
                },
                relativeTo: function (modulePath, rel) {
                    var parts = modulePath.split('/');
                    var idx = 1;
                    while (rel[idx] === '.') {
                        parts.pop();
                        idx++;
                    }
                    return parts.join('/');
                },
                isPackageRootDir: function (pth) {
                    return pth.indexOf('/') === -1;
                }
            },
            json: {
                transform: function (loader, load, data) {
                    data.steal = utils.pkg.config(data);
                    var fn = loader.jsonOptions && loader.jsonOptions.transform;
                    if (!fn)
                        return data;
                    return fn.call(loader, load, data);
                }
            },
            includeInBuild: true
        };
        function parseURI(url) {
            var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@\/]*(?::[^:@\/]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
            return m ? {
                href: m[0] || '',
                protocol: m[1] || '',
                authority: m[2] || '',
                host: m[3] || '',
                hostname: m[4] || '',
                port: m[5] || '',
                pathname: m[6] || '',
                search: m[7] || '',
                hash: m[8] || ''
            } : null;
        }
        module.exports = utils;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*npm-extension*/
define('npm-extension', [
    'require',
    'exports',
    'module',
    '@steal',
    './npm-utils'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'format cjs';
        var steal = require('@steal');
        var utils = require('./npm-utils');
        exports.includeInBuild = true;
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
        var isElectron = isNode && !!process.versions.electron;
        var isBrowser = typeof window !== 'undefined' && (!isNode || isElectron) && !isWorker;
        exports.addExtension = function addNpmExtension(System) {
            if (System._extensions) {
                System._extensions.push(addNpmExtension);
            }
            function getImportRewritesValue(identifier, parsedParentName) {
                if (this.importRewrites && typeof this.importRewrites === 'object' && parsedParentName) {
                    var childimportRewrites = this.importRewrites[parsedParentName.packageName];
                    if (childimportRewrites) {
                        var identifierValue = childimportRewrites[identifier];
                        return identifierValue;
                    }
                }
            }
            var oldNormalize = System.normalize;
            System.normalize = function npmNormalize(identifier, parentModuleName, parentAddress, pluginNormalize) {
                var name = identifier;
                var parentName = parentModuleName;
                if (parentName && this.npmParentMap && this.npmParentMap[parentName]) {
                    parentName = this.npmParentMap[parentName];
                }
                var hasNoParent = !parentName;
                var parsedParentModuleName = parentName && utils.moduleName.parse(parentName);
                var parentIsNpmModule = utils.moduleName.isNpm(parentName);
                var importRewritesValue = getImportRewritesValue.call(this, identifier, parsedParentModuleName);
                if (importRewritesValue !== undefined) {
                    name = importRewritesValue;
                }
                var nameIsRelative = utils.path.isRelative(name);
                var nameIsNpmModule = utils.moduleName.isNpm(name);
                var identifierEndsWithSlash = utils.path.endsWithSlash(name);
                if (nameIsNpmModule && parentModuleName) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                if (parentName && nameIsRelative && !parentIsNpmModule) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                if (utils.moduleName.isConditional(name)) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var hasContextualMap = typeof this.map[parentName] === 'object' && this.map[parentName][name];
                if (hasContextualMap) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var refPkg = utils.pkg.findByModuleNameOrAddress(this, parentName, parentAddress);
                if (!refPkg) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var isPointingAtParentFolder = name === '../' || name === './';
                if (parentIsNpmModule && isPointingAtParentFolder) {
                    var parentModulePath = parsedParentModuleName.modulePath || '';
                    var relativePath = utils.path.relativeTo(parentModulePath, name);
                    var isInRoot = utils.path.isPackageRootDir(relativePath);
                    if (isInRoot) {
                        name = refPkg.name + '#' + utils.path.removeJS(utils.path.removeDotSlash(refPkg.main));
                    } else {
                        name = name + 'index';
                    }
                }
                var parsedModuleName = utils.moduleName.parseFromPackage(this, refPkg, name, parentName);
                var isRoot = utils.pkg.isRoot(this, refPkg);
                var parsedPackageNameIsReferringPackage = parsedModuleName.packageName === refPkg.name;
                var isRelativeToParentNpmModule = parentIsNpmModule && nameIsRelative && parsedPackageNameIsReferringPackage;
                var depPkg, wantedPkg;
                if (isRelativeToParentNpmModule) {
                    depPkg = refPkg;
                }
                var context = this.npmContext;
                var crawl = context && context.crawl;
                var isDev = !!crawl;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = nameIsRelative ? null : crawl.matchedVersion(context, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            wantedPkg = depMap[parsedModuleName.packageName];
                            if (wantedPkg) {
                                var wantedVersion = refPkg.resolutions && refPkg.resolutions[wantedPkg.name] || wantedPkg.version;
                                var foundPkg = crawl.matchedVersion(this.npmContext, wantedPkg.name, wantedVersion);
                                if (foundPkg) {
                                    depPkg = utils.pkg.findByUrl(this, foundPkg.fileUrl);
                                }
                            }
                        }
                    } else {
                        if (isRoot) {
                            depPkg = utils.pkg.findDepWalking(this, refPkg, parsedModuleName.packageName);
                        } else {
                            depPkg = utils.pkg.findDep(this, refPkg, parsedModuleName.packageName);
                        }
                    }
                }
                if (parsedPackageNameIsReferringPackage) {
                    depPkg = utils.pkg.findByNameAndVersion(this, parsedModuleName.packageName, refPkg.version);
                }
                var lookupByName = parsedModuleName.isGlobal || hasNoParent;
                if (!depPkg) {
                    depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                }
                var isThePackageWeWant = !isDev || !depPkg || (wantedPkg ? crawl.pkgSatisfies(depPkg, wantedPkg.version) : true);
                if (!isThePackageWeWant) {
                    depPkg = undefined;
                } else if (isDev && depPkg) {
                    utils.pkg.saveResolution(context, refPkg, depPkg);
                }
                if (!depPkg) {
                    var browserPackageName = this.globalBrowser[parsedModuleName.packageName];
                    if (browserPackageName) {
                        parsedModuleName.packageName = browserPackageName.moduleName;
                        depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                    }
                }
                if (!depPkg && isRoot && name === refPkg.main && utils.pkg.hasDirectoriesLib(refPkg)) {
                    parsedModuleName.version = refPkg.version;
                    parsedModuleName.packageName = refPkg.name;
                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                    return oldNormalize.call(this, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                }
                var loader = this;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = crawl.matchedVersion(this.npmContext, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            depPkg = depMap[parsedModuleName.packageName];
                            if (!depPkg) {
                                var parents = crawl.findPackageAndParents(this.npmContext, parsedModuleName.packageName);
                                if (parents) {
                                    depPkg = parents.package;
                                }
                            }
                        }
                    }
                    if (!depPkg) {
                        if (refPkg.browser && refPkg.browser[name]) {
                            return oldNormalize.call(this, refPkg.browser[name], parentName, parentAddress, pluginNormalize);
                        }
                        var steal = utils.pkg.config(refPkg);
                        if (steal && steal.map && typeof steal.map[name] === 'string') {
                            var mappedName = steal.map[name];
                            var envConfig = steal.envs && steal.envs[loader.env];
                            if (envConfig && envConfig.map && typeof envConfig.map[name] === 'string') {
                                mappedName = envConfig.map[name];
                            }
                            return loader.normalize(mappedName, parentName, parentAddress, pluginNormalize);
                        } else {
                            return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                        }
                    }
                    return crawl.dep(this.npmContext, parentPkg, refPkg, depPkg, isRoot).then(createModuleNameAndNormalize);
                } else {
                    return createModuleNameAndNormalize(depPkg);
                }
                function createModuleNameAndNormalize(depPkg) {
                    parsedModuleName.version = depPkg.version;
                    if (!parsedModuleName.modulePath) {
                        parsedModuleName.modulePath = utils.pkg.main(depPkg);
                    }
                    var p = oldNormalize.call(loader, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                    if (identifierEndsWithSlash) {
                        p.then(function (name) {
                            if (context && context.forwardSlashMap) {
                                context.forwardSlashMap[name] = true;
                            }
                        });
                    }
                    return p;
                }
            };
            var oldLocate = System.locate;
            System.locate = function (load) {
                var parsedModuleName = utils.moduleName.parse(load.name), loader = this;
                var pmn = load.metadata.parsedModuleName = parsedModuleName;
                load.metadata.npmPackage = utils.pkg.findByNameAndVersion(this, pmn.packageName, pmn.version);
                if (parsedModuleName.version && this.npm && !loader.paths[load.name]) {
                    var pkg = this.npm[utils.moduleName.nameAndVersion(parsedModuleName)];
                    if (pkg) {
                        return oldLocate.call(this, load).then(function (locatedAddress) {
                            var address = locatedAddress;
                            var expectedAddress = utils.path.joinURIs(System.baseURL, load.name);
                            if (isBrowser) {
                                expectedAddress = expectedAddress.replace(/#/g, '%23');
                            }
                            if (address !== expectedAddress + '.js' && address !== expectedAddress) {
                                return address;
                            }
                            var root = utils.pkg.rootDir(pkg, utils.pkg.isRoot(loader, pkg));
                            if (parsedModuleName.modulePath) {
                                var npmAddress = utils.path.joinURIs(utils.path.addEndingSlash(root), parsedModuleName.plugin ? parsedModuleName.modulePath : utils.path.addJS(parsedModuleName.modulePath));
                                address = typeof steal !== 'undefined' ? utils.path.joinURIs(loader.baseURL, npmAddress) : npmAddress;
                            }
                            return address;
                        });
                    }
                }
                return oldLocate.call(this, load);
            };
            var oldFetch = System.fetch;
            System.fetch = function (load) {
                if (load.metadata.dryRun) {
                    return oldFetch.apply(this, arguments);
                }
                var loader = this;
                var context = loader.npmContext;
                var fetchPromise = Promise.resolve(oldFetch.apply(this, arguments));
                if (utils.moduleName.isNpm(load.name)) {
                    fetchPromise = fetchPromise.then(null, function (err) {
                        var statusCode = err.statusCode;
                        if (statusCode !== 404 && statusCode !== 0) {
                            return Promise.reject(err);
                        }
                        if (!loader.npmContext) {
                            loader.npmContext = { forwardSlashMap: {} };
                        }
                        var types = [].slice.call(retryTypes);
                        return retryAll(types, err).then(null, function (e) {
                            return Promise.reject(err);
                        });
                        function retryAll(types, err) {
                            if (!types.length) {
                                throw err;
                            }
                            var type = types.shift();
                            if (!type.test(load)) {
                                throw err;
                            }
                            return Promise.resolve(retryFetch.call(loader, load, type)).then(null, function (err) {
                                return retryAll(types, err);
                            });
                        }
                    });
                }
                return fetchPromise.catch(function (error) {
                    var statusCode = error.statusCode;
                    if ((statusCode === 404 || statusCode === 0) && utils.moduleName.isBareIdentifier(load.name) && !utils.pkg.isRoot(loader, load.metadata.npmPackage)) {
                        var newError = new Error([
                            'Could not load \'' + load.name + '\'',
                            'Is this an npm module not saved in your package.json?'
                        ].join('\n'));
                        newError.statusCode = error.statusCode;
                        newError.stack = newError.stack + error.stack;
                        throw newError;
                    } else {
                        throw error;
                    }
                });
            };
            var convertName = function (loader, name) {
                var pkg = utils.pkg.findByName(loader, name.split('/')[0]);
                if (pkg) {
                    var parsed = utils.moduleName.parse(name, pkg.name);
                    parsed.version = pkg.version;
                    if (!parsed.modulePath) {
                        parsed.modulePath = utils.pkg.main(pkg);
                    }
                    return utils.moduleName.create(parsed);
                }
                return name;
            };
            var configSpecial = {
                map: function (map) {
                    var newMap = {}, val;
                    for (var name in map) {
                        val = map[name];
                        newMap[convertName(this, name)] = typeof val === 'object' ? configSpecial.map(val) : convertName(this, val);
                    }
                    return newMap;
                },
                meta: function (map) {
                    var newMap = {};
                    for (var name in map) {
                        newMap[convertName(this, name)] = map[name];
                    }
                    return newMap;
                },
                paths: function (paths) {
                    var newPaths = {};
                    for (var name in paths) {
                        newPaths[convertName(this, name)] = paths[name];
                    }
                    return newPaths;
                },
                importRewrites: function (importRewrites) {
                    return importRewrites;
                }
            };
            var oldConfig = System.config;
            System.config = function (cfg) {
                var loader = this;
                if (loader.npmContext) {
                    var context = loader.npmContext;
                    var pkg = context.versions.__default;
                    var conv = context.convert.steal(context, pkg, cfg, true);
                    context.convert.updateConfigOnPackageLoad(conv, false, true, context.applyBuildConfig);
                    oldConfig.apply(loader, arguments);
                    return;
                }
                for (var name in cfg) {
                    if (configSpecial[name]) {
                        cfg[name] = configSpecial[name].call(loader, cfg[name]);
                    }
                }
                oldConfig.apply(loader, arguments);
            };
            var newLoader = System._newLoader || Function.prototype;
            System._newLoader = function (loader) {
                loader.npmContext = this.npmContext;
                loader.npmParentMap = this.npmParentMap;
                return newLoader.apply(this, arguments);
            };
            steal.addNpmPackages = function (npmPackages) {
                var packages = npmPackages || [];
                var loader = this.loader;
                for (var i = 0; i < packages.length; i += 1) {
                    var pkg = packages[i];
                    var path = pkg && pkg.fileUrl;
                    if (path) {
                        loader.npmContext.paths[path] = pkg;
                    }
                }
            };
            steal.getNpmPackages = function () {
                var context = this.loader.npmContext;
                return context ? context.packages || [] : [];
            };
            function retryFetch(load, type) {
                var loader = this;
                var moduleName = typeof type.name === 'function' ? type.name(loader, load) : load.name + type.name;
                var local = utils.extend({}, load);
                local.name = moduleName;
                local.metadata = { dryRun: true };
                return Promise.resolve(loader.locate(local)).then(function (address) {
                    local.address = address;
                    return loader.fetch(local);
                }).then(function (source) {
                    load.metadata.address = local.address;
                    loader.npmParentMap[load.name] = local.name;
                    var npmLoad = loader.npmContext && loader.npmContext.npmLoad;
                    if (npmLoad) {
                        npmLoad.saveLoadIfNeeded(loader.npmContext);
                        if (!isNode) {
                            utils.warnOnce('Some 404s were encountered ' + 'while loading. Don\'t panic! ' + 'These will only happen in dev ' + 'and are harmless.');
                        }
                    }
                    return source;
                });
            }
            var retryTypes = [
                {
                    name: function (loader, load) {
                        var context = loader.npmContext;
                        if (context.forwardSlashMap[load.name]) {
                            var parts = load.name.split('/');
                            parts.pop();
                            return parts.concat(['index']).join('/');
                        }
                        return load.name + '/index';
                    },
                    test: function () {
                        return true;
                    }
                },
                {
                    name: '.json',
                    test: function (load) {
                        return utils.moduleName.isNpm(load.name) && utils.path.basename(load.address) === 'package.js';
                    }
                }
            ];
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*npm-load*/
define('npm-load', [], function(){ return {}; });
/*semver*/
define('semver', [], function(){ return {}; });
/*npm-crawl*/
define('npm-crawl', [], function(){ return {}; });
/*npm-convert*/
define('npm-convert', [], function(){ return {}; });
/*npm*/
define('npm', [], function(){ return {}; });
/*package.json!npm*/
define('package.json!npm', [
    '@loader',
    'npm-extension',
    'module'
], function (loader, npmExtension, module) {
    npmExtension.addExtension(loader);
    if (!loader.main) {
        loader.main = 'can-import-module@1.3.0#can-import-module';
    }
    loader._npmExtensions = [].slice.call(arguments, 2);
    (function (loader, packages, options) {
        var g = loader.global;
        if (!g.process) {
            g.process = {
                argv: [],
                cwd: function () {
                    var baseURL = loader.baseURL;
                    return baseURL;
                },
                browser: true,
                env: { NODE_ENV: loader.env },
                version: '',
                platform: navigator && navigator.userAgent && /Windows/.test(navigator.userAgent) ? 'win' : ''
            };
        }
        if (!loader.npm) {
            loader.npm = {};
            loader.npmPaths = {};
            loader.globalBrowser = {};
        }
        if (!loader.npmParentMap) {
            loader.npmParentMap = options.npmParentMap || {};
        }
        var rootPkg = loader.npmPaths.__default = packages[0];
        var rootConfig = rootPkg.steal || rootPkg.system;
        var lib = rootConfig && rootConfig.directories && rootConfig.directories.lib;
        var setGlobalBrowser = function (globals, pkg) {
            for (var name in globals) {
                loader.globalBrowser[name] = {
                    pkg: pkg,
                    moduleName: globals[name]
                };
            }
        };
        var setInNpm = function (name, pkg) {
            if (!loader.npm[name]) {
                loader.npm[name] = pkg;
            }
            loader.npm[name + '@' + pkg.version] = pkg;
        };
        var forEach = function (arr, fn) {
            var i = 0, len = arr.length;
            for (; i < len; i++) {
                res = fn.call(arr, arr[i], i);
                if (res === false)
                    break;
            }
        };
        var setupLiveReload = function () {
            if (loader.liveReloadInstalled) {
                loader['import']('live-reload', { name: module.id }).then(function (reload) {
                    reload.dispose(function () {
                        var pkgInfo = loader.npmContext.pkgInfo;
                        delete pkgInfo[rootPkg.name + '@' + rootPkg.version];
                        var idx = -1;
                        forEach(pkgInfo, function (pkg, i) {
                            if (pkg.name === rootPkg.name && pkg.version === rootPkg.version) {
                                idx = i;
                                return false;
                            }
                        });
                        pkgInfo.splice(idx, 1);
                    });
                });
            }
        };
        var ignoredConfig = [
            'bundle',
            'configDependencies',
            'transpiler',
            'treeShaking'
        ];
        packages.reverse();
        forEach(packages, function (pkg) {
            var steal = pkg.steal || pkg.system;
            if (steal) {
                var main = steal.main;
                delete steal.main;
                var configDeps = steal.configDependencies;
                if (pkg !== rootPkg) {
                    forEach(ignoredConfig, function (name) {
                        delete steal[name];
                    });
                }
                loader.config(steal);
                if (pkg === rootPkg) {
                    steal.configDependencies = configDeps;
                }
                steal.main = main;
            }
            if (pkg.globalBrowser) {
                var doNotApplyGlobalBrowser = pkg.name === 'steal' && rootConfig.builtins === false;
                if (!doNotApplyGlobalBrowser) {
                    setGlobalBrowser(pkg.globalBrowser, pkg);
                }
            }
            var systemName = steal && steal.name;
            if (systemName) {
                setInNpm(systemName, pkg);
            } else {
                setInNpm(pkg.name, pkg);
            }
            if (!loader.npm[pkg.name]) {
                loader.npm[pkg.name] = pkg;
            }
            loader.npm[pkg.name + '@' + pkg.version] = pkg;
            var pkgAddress = pkg.fileUrl.replace(/\/package\.json.*/, '');
            loader.npmPaths[pkgAddress] = pkg;
        });
        setupLiveReload();
        forEach(loader._npmExtensions || [], function (ext) {
            if (ext.systemConfig) {
                loader.config(ext.systemConfig);
            }
        });
    }(loader, [
        {
            'name': 'can-import-module',
            'version': '1.3.0',
            'fileUrl': './package.json',
            'main': 'can-import-module.js',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-import-module': '1.3.0',
                'steal-qunit': '2.0.0',
                'can-namespace': '1.0.0',
                'can-globals': '1.2.2'
            }
        },
        {
            'name': 'steal',
            'version': '2.3.0',
            'fileUrl': './node_modules/steal/package.json',
            'main': 'main',
            'steal': {
                'npmDependencies': {
                    'console-browserify': true,
                    'constants-browserify': true,
                    'crypto-browserify': true,
                    'http-browserify': true,
                    'buffer': true,
                    'os-browserify': true,
                    'vm-browserify': true,
                    'zlib-browserify': true,
                    'assert': true,
                    'domain-browser': true,
                    'events': true,
                    'https-browserify': true,
                    'path-browserify': true,
                    'string_decoder': true,
                    'tty-browserify': true,
                    'process': true,
                    'punycode': true
                }
            },
            'globalBrowser': {
                'console': 'console-browserify',
                'constants': 'constants-browserify',
                'crypto': 'crypto-browserify',
                'http': 'http-browserify',
                'buffer': 'buffer',
                'os': 'os-browserify',
                'vm': 'vm-browserify',
                'zlib': 'zlib-browserify',
                'assert': 'assert',
                'child_process': 'steal#ext/builtin/child_process',
                'cluster': 'steal#ext/builtin/cluster',
                'dgram': 'steal#ext/builtin/dgram',
                'dns': 'steal#ext/builtin/dns',
                'domain': 'domain-browser',
                'events': 'events',
                'fs': 'steal#ext/builtin/fs',
                'https': 'https-browserify',
                'module': 'steal#ext/builtin/module',
                'net': 'steal#ext/builtin/net',
                'path': 'path-browserify',
                'process': 'process',
                'querystring': 'steal#ext/builtin/querystring',
                'readline': 'steal#ext/builtin/readline',
                'repl': 'steal#ext/builtin/repl',
                'stream': 'steal#ext/builtin/stream',
                'string_decoder': 'string_decoder',
                'sys': 'steal#ext/builtin/sys',
                'timers': 'steal#ext/builtin/timers',
                'tls': 'steal#ext/builtin/tls',
                'tty': 'tty-browserify',
                'url': 'steal#ext/builtin/url',
                'util': 'steal#ext/builtin/util',
                '_stream_readable': 'steal#ext/builtin/_stream_readable',
                '_stream_writable': 'steal#ext/builtin/_stream_writable',
                '_stream_duplex': 'steal#ext/builtin/_stream_duplex',
                '_stream_transform': 'steal#ext/builtin/_stream_transform',
                '_stream_passthrough': 'steal#ext/builtin/_stream_passthrough'
            },
            'resolutions': {}
        },
        {
            'name': 'assert',
            'version': '2.0.0',
            'fileUrl': './node_modules/assert/package.json',
            'main': 'build/assert.js',
            'resolutions': {}
        },
        {
            'name': 'buffer',
            'version': '5.0.8',
            'fileUrl': './node_modules/buffer/package.json',
            'main': 'index.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'console-browserify',
            'version': '1.1.0',
            'fileUrl': './node_modules/console-browserify/package.json',
            'main': 'index',
            'resolutions': {}
        },
        {
            'name': 'constants-browserify',
            'version': '1.0.0',
            'fileUrl': './node_modules/constants-browserify/package.json',
            'main': 'constants.json',
            'resolutions': {}
        },
        {
            'name': 'crypto-browserify',
            'version': '3.11.1',
            'fileUrl': './node_modules/crypto-browserify/package.json',
            'browser': { 'crypto': '@empty' },
            'resolutions': {}
        },
        {
            'name': 'domain-browser',
            'version': '1.1.7',
            'fileUrl': './node_modules/domain-browser/package.json',
            'main': './index.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'events',
            'version': '1.1.1',
            'fileUrl': './node_modules/events/package.json',
            'main': './events.js',
            'resolutions': {}
        },
        {
            'name': 'http-browserify',
            'version': '1.7.0',
            'fileUrl': './node_modules/http-browserify/package.json',
            'main': 'index.js',
            'browser': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'https-browserify',
            'version': '1.0.0',
            'fileUrl': './node_modules/https-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'os-browserify',
            'version': '0.3.0',
            'fileUrl': './node_modules/os-browserify/package.json',
            'main': 'main.js',
            'browser': 'browser.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'path-browserify',
            'version': '0.0.1',
            'fileUrl': './node_modules/path-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'process',
            'version': '0.11.10',
            'fileUrl': './node_modules/process/package.json',
            'main': './index.js',
            'browser': './browser.js',
            'resolutions': {}
        },
        {
            'name': 'punycode',
            'version': '2.0.1',
            'fileUrl': './node_modules/punycode/package.json',
            'main': 'punycode.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'string_decoder',
            'version': '0.10.31',
            'fileUrl': './node_modules/string_decoder/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'tty-browserify',
            'version': '0.0.1',
            'fileUrl': './node_modules/tty-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'vm-browserify',
            'version': '0.0.4',
            'fileUrl': './node_modules/vm-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'zlib-browserify',
            'version': '0.0.3',
            'fileUrl': './node_modules/zlib-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'assert',
            'version': '1.4.1',
            'fileUrl': './node_modules/steal/node_modules/assert/package.json',
            'main': './assert.js',
            'resolutions': {}
        },
        {
            'name': 'string_decoder',
            'version': '1.0.3',
            'fileUrl': './node_modules/steal/node_modules/string_decoder/package.json',
            'main': 'lib/string_decoder.js',
            'resolutions': {}
        },
        {
            'name': 'steal-qunit',
            'version': '2.0.0',
            'fileUrl': './node_modules/steal-qunit/package.json',
            'main': 'steal-qunit',
            'steal': {
                'plugins': ['steal-css'],
                'meta': {
                    'qunit@2.19.4#qunit/qunit': {
                        'format': 'global',
                        'exports': 'QUnit',
                        'deps': ['steal-qunit/add-dom']
                    }
                }
            },
            'resolutions': {
                'qunit': '2.19.4',
                'steal-css': '1.3.2'
            },
            'system': {
                'plugins': ['steal-css'],
                'meta': {
                    'qunit@2.19.4#qunit/qunit': {
                        'format': 'global',
                        'exports': 'QUnit',
                        'deps': ['steal-qunit/add-dom']
                    }
                }
            }
        },
        {
            'name': 'steal-css',
            'version': '1.3.2',
            'fileUrl': './node_modules/steal-css/package.json',
            'main': 'css.js',
            'steal': {
                'ext': { 'css': 'steal-css' },
                'map': { '$css': 'steal-css@1.3.2#css' }
            },
            'resolutions': {}
        },
        {
            'name': 'can-namespace',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-namespace/package.json',
            'main': 'can-namespace',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {}
        },
        {
            'name': 'qunit',
            'version': '2.19.4',
            'fileUrl': './node_modules/qunit/package.json',
            'main': 'qunit/qunit.js',
            'resolutions': { 'steal-qunit': '2.0.0' }
        },
        {
            'name': 'can-globals',
            'version': '1.2.2',
            'fileUrl': './node_modules/can-globals/package.json',
            'main': 'can-globals.js',
            'resolutions': {
                'can-globals': '1.2.2',
                'can-namespace': '1.0.0',
                'can-reflect': '1.19.0'
            }
        },
        {
            'name': 'can-reflect',
            'version': '1.19.0',
            'fileUrl': './node_modules/can-reflect/package.json',
            'main': 'can-reflect',
            'resolutions': {
                'can-reflect': '1.19.0',
                'can-namespace': '1.0.0',
                'can-symbol': '1.7.0'
            }
        },
        {
            'name': 'can-symbol',
            'version': '1.7.0',
            'fileUrl': './node_modules/can-symbol/package.json',
            'main': 'can-symbol',
            'steal': {
                'main': 'can-symbol',
                'configDependencies': ['live-reload'],
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                }
            },
            'resolutions': {}
        }
    ], { 'npmParentMap': {} }));
});
/*can-import-module@1.3.0#test/cjs-module*/
define('can-import-module@1.3.0#test/cjs-module', function (require, exports, module) {
    'use strict';
    module.exports = 'Hello from cjs-module';
});
/*steal-qunit@2.0.0#add-dom*/
define('steal-qunit@2.0.0#add-dom', function (require, exports, module) {
    'format cjs';
    if (!document.getElementById('qunit')) {
        var qunit = document.createElement('div');
        qunit.id = 'qunit';
        (document.body || document.documentElement).appendChild(qunit);
    }
});
/*qunit@2.19.4#qunit/qunit*/
define('qunit@2.19.4#qunit/qunit', [
    'module',
    '@loader',
    'require',
    'steal-qunit/add-dom'
], function (module, loader, require) {
    loader.get('@@global-helpers').prepareGlobal({
        require: require,
        name: module.id,
        deps: ['steal-qunit/add-dom'],
        exports: 'QUnit'
    });
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/*!\n * QUnit 2.19.4\n * https://qunitjs.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n */\n(function () {\n  \'use strict\';\n\n  function _typeof(obj) {\n    "@babel/helpers - typeof";\n\n    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;\n    }, _typeof(obj);\n  }\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError("Cannot call a class as a function");\n    }\n  }\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, "prototype", {\n      writable: false\n    });\n    return Constructor;\n  }\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);\n  }\n  function _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i["return"] != null) _i["return"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === "string") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === "Object" && o.constructor) n = o.constructor.name;\n    if (n === "Map" || n === "Set") return Array.from(o);\n    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n  function _nonIterableSpread() {\n    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n  }\n  function _nonIterableRest() {\n    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n  }\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];\n    if (!it) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {\n        if (it) o = it;\n        var i = 0;\n        var F = function () {};\n        return {\n          s: F,\n          n: function () {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: F\n        };\n      }\n      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n    }\n    var normalCompletion = true,\n      didErr = false,\n      err;\n    return {\n      s: function () {\n        it = it.call(o);\n      },\n      n: function () {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function (e) {\n        didErr = true;\n        err = e;\n      },\n      f: function () {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n\n  // We don\'t use global-this-polyfill [1], because it modifies\n  // the globals scope by default. QUnit must not affect the host context\n  // as developers may test their project may be such a polyfill, and/or\n  // they may intentionally test their project with and without certain\n  // polyfills and we must not affect that. It also uses an obscure\n  // mechanism that seems to sometimes causes a runtime error in older\n  // browsers (specifically Safari and IE versions that support\n  // Object.defineProperty but then report _T_ as undefined).\n  // [1] https://github.com/ungap/global-this/blob/v0.4.4/esm/index.js\n  //\n  // Another way is `Function(\'return this\')()`, but doing so relies\n  // on eval which will cause a CSP error on some servers.\n  //\n  // Instead, simply check the four options that already exist\n  // in all supported environments.\n  function getGlobalThis() {\n    if (typeof globalThis !== \'undefined\') {\n      // For SpiderMonkey, modern browsers, and recent Node.js\n      // eslint-disable-next-line no-undef\n      return globalThis;\n    }\n    if (typeof self !== \'undefined\') {\n      // For web workers\n      // eslint-disable-next-line no-undef\n      return self;\n    }\n    if (typeof window$1 !== \'undefined\') {\n      // For document context in browsers\n      return window$1;\n    }\n    if (typeof global !== \'undefined\') {\n      // For Node.js\n      // eslint-disable-next-line no-undef\n      return global;\n    }\n    throw new Error(\'Unable to locate global object\');\n  }\n\n  // This avoids a simple `export const` assignment as that would lead Rollup\n  // to change getGlobalThis and use the same (generated) variable name there.\n  var g = getGlobalThis();\n  var window$1 = g.window;\n  var console$1 = g.console;\n  var setTimeout$1 = g.setTimeout;\n  var clearTimeout = g.clearTimeout;\n  var document = window$1 && window$1.document;\n  var navigator = window$1 && window$1.navigator;\n  var localSessionStorage = function () {\n    var x = \'qunit-test-string\';\n    try {\n      g.sessionStorage.setItem(x, x);\n      g.sessionStorage.removeItem(x);\n      return g.sessionStorage;\n    } catch (e) {\n      return undefined;\n    }\n  }();\n\n  // Basic fallback for ES6 Map\n  // Support: IE 9-10, Safari 7, PhantomJS; Map is undefined\n  // Support: iOS 8; `new Map(iterable)` is not supported\n  //\n  // Fallback for ES7 Map#keys\n  // Support: IE 11; Map#keys is undefined\n  var StringMap = typeof g.Map === \'function\' && typeof g.Map.prototype.keys === \'function\' && typeof g.Symbol === \'function\' && _typeof(g.Symbol.iterator) === \'symbol\' ? g.Map : function StringMap(input) {\n    var _this = this;\n    var store = Object.create(null);\n    var hasOwn = Object.prototype.hasOwnProperty;\n    this.has = function (strKey) {\n      return hasOwn.call(store, strKey);\n    };\n    this.get = function (strKey) {\n      return store[strKey];\n    };\n    this.set = function (strKey, val) {\n      if (!hasOwn.call(store, strKey)) {\n        this.size++;\n      }\n      store[strKey] = val;\n      return this;\n    };\n    this.delete = function (strKey) {\n      if (hasOwn.call(store, strKey)) {\n        delete store[strKey];\n        this.size--;\n      }\n    };\n    this.forEach = function (callback) {\n      for (var strKey in store) {\n        callback(store[strKey], strKey);\n      }\n    };\n    this.keys = function () {\n      return Object.keys(store);\n    };\n    this.clear = function () {\n      store = Object.create(null);\n      this.size = 0;\n    };\n    this.size = 0;\n    if (input) {\n      input.forEach(function (val, strKey) {\n        _this.set(strKey, val);\n      });\n    }\n  };\n\n  // Basic fallback for ES6 Set\n  // Support: IE 11, `new Set(iterable)` parameter not yet implemented\n  // Test for Set#values() which came after Set(iterable).\n  var StringSet = typeof g.Set === \'function\' && typeof g.Set.prototype.values === \'function\' ? g.Set : function (input) {\n    var set = Object.create(null);\n    if (Array.isArray(input)) {\n      input.forEach(function (item) {\n        set[item] = true;\n      });\n    }\n    return {\n      add: function add(value) {\n        set[value] = true;\n      },\n      has: function has(value) {\n        return value in set;\n      },\n      get size() {\n        return Object.keys(set).length;\n      }\n    };\n  };\n\n  // Support: IE 9\n  // Detect if the console object exists and no-op otherwise.\n  // This allows support for IE 9, which doesn\'t have a console\n  // object if the developer tools are not open.\n\n  // Support: IE 9\n  // Function#bind is supported, but no console.log.bind().\n\n  // Support: SpiderMonkey (mozjs 68+)\n  // The console object has a log method, but no warn method.\n\n  var Logger = {\n    warn: console$1 ? Function.prototype.bind.call(console$1.warn || console$1.log, console$1) : function () {}\n  };\n\n  var toString = Object.prototype.toString;\n  var hasOwn$1 = Object.prototype.hasOwnProperty;\n  var nativePerf = getNativePerf();\n\n  // TODO: Consider using globalThis instead so that perf marks work\n  // in Node.js as well. As they can have overhead, we should also\n  // have a way to disable these, and/or make them an opt-in reporter\n  // in QUnit 3 and then support globalThis.\n  // For example: `QUnit.addReporter(QUnit.reporters.perf)`.\n  function getNativePerf() {\n    if (window$1 && typeof window$1.performance !== \'undefined\' && typeof window$1.performance.mark === \'function\' && typeof window$1.performance.measure === \'function\') {\n      return window$1.performance;\n    } else {\n      return undefined;\n    }\n  }\n  var performance = {\n    now: nativePerf ? nativePerf.now.bind(nativePerf) : Date.now,\n    measure: nativePerf ? function (comment, startMark, endMark) {\n      // `performance.measure` may fail if the mark could not be found.\n      // reasons a specific mark could not be found include: outside code invoking `performance.clearMarks()`\n      try {\n        nativePerf.measure(comment, startMark, endMark);\n      } catch (ex) {\n        Logger.warn(\'performance.measure could not be executed because of \', ex.message);\n      }\n    } : function () {},\n    mark: nativePerf ? nativePerf.mark.bind(nativePerf) : function () {}\n  };\n\n  // Returns a new Array with the elements that are in a but not in b\n  function diff(a, b) {\n    return a.filter(function (a) {\n      return b.indexOf(a) === -1;\n    });\n  }\n\n  /**\n   * Determines whether an element exists in a given array or not.\n   *\n   * @method inArray\n   * @param {any} elem\n   * @param {Array} array\n   * @return {boolean}\n   */\n  function inArray(elem, array) {\n    return array.indexOf(elem) !== -1;\n  }\n\n  /**\n   * Recursively clone an object into a plain array or object, taking only the\n   * own enumerable properties.\n   *\n   * @param {any} obj\n   * @param {bool} [allowArray=true]\n   * @return {Object|Array}\n   */\n  function objectValues(obj) {\n    var allowArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var vals = allowArray && is(\'array\', obj) ? [] : {};\n    for (var key in obj) {\n      if (hasOwn$1.call(obj, key)) {\n        var val = obj[key];\n        vals[key] = val === Object(val) ? objectValues(val, allowArray) : val;\n      }\n    }\n    return vals;\n  }\n\n  /**\n   * Recursively clone an object into a plain object, taking only the\n   * subset of own enumerable properties that exist a given model.\n   *\n   * @param {any} obj\n   * @param {any} model\n   * @return {Object}\n   */\n  function objectValuesSubset(obj, model) {\n    // Return primitive values unchanged to avoid false positives or confusing\n    // results from assert.propContains().\n    // E.g. an actual null or false wrongly equaling an empty object,\n    // or an actual string being reported as object not matching a partial object.\n    if (obj !== Object(obj)) {\n      return obj;\n    }\n\n    // Unlike objectValues(), subset arrays to a plain objects as well.\n    // This enables subsetting [20, 30] with {1: 30}.\n    var subset = {};\n    for (var key in model) {\n      if (hasOwn$1.call(model, key) && hasOwn$1.call(obj, key)) {\n        subset[key] = objectValuesSubset(obj[key], model[key]);\n      }\n    }\n    return subset;\n  }\n  function extend(a, b, undefOnly) {\n    for (var prop in b) {\n      if (hasOwn$1.call(b, prop)) {\n        if (b[prop] === undefined) {\n          delete a[prop];\n        } else if (!(undefOnly && typeof a[prop] !== \'undefined\')) {\n          a[prop] = b[prop];\n        }\n      }\n    }\n    return a;\n  }\n  function objectType(obj) {\n    if (typeof obj === \'undefined\') {\n      return \'undefined\';\n    }\n\n    // Consider: typeof null === object\n    if (obj === null) {\n      return \'null\';\n    }\n    var match = toString.call(obj).match(/^\\[object\\s(.*)\\]$/);\n    var type = match && match[1];\n    switch (type) {\n      case \'Number\':\n        if (isNaN(obj)) {\n          return \'nan\';\n        }\n        return \'number\';\n      case \'String\':\n      case \'Boolean\':\n      case \'Array\':\n      case \'Set\':\n      case \'Map\':\n      case \'Date\':\n      case \'RegExp\':\n      case \'Function\':\n      case \'Symbol\':\n        return type.toLowerCase();\n      default:\n        return _typeof(obj);\n    }\n  }\n\n  // Safe object type checking\n  function is(type, obj) {\n    return objectType(obj) === type;\n  }\n\n  // Based on Java\'s String.hashCode, a simple but not\n  // rigorously collision resistant hashing function\n  function generateHash(module, testName) {\n    var str = module + \'\\x1C\' + testName;\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n      hash = (hash << 5) - hash + str.charCodeAt(i);\n      hash |= 0;\n    }\n\n    // Convert the possibly negative integer hash code into an 8 character hex string, which isn\'t\n    // strictly necessary but increases user understanding that the id is a SHA-like hash\n    var hex = (0x100000000 + hash).toString(16);\n    if (hex.length < 8) {\n      hex = \'0000000\' + hex;\n    }\n    return hex.slice(-8);\n  }\n\n  /**\n   * Converts an error into a simple string for comparisons.\n   *\n   * @param {Error|any} error\n   * @return {string}\n   */\n  function errorString(error) {\n    // Use String() instead of toString() to handle non-object values like undefined or null.\n    var resultErrorString = String(error);\n\n    // If the error wasn\'t a subclass of Error but something like\n    // an object literal with name and message properties...\n    if (resultErrorString.slice(0, 7) === \'[object\') {\n      // Based on https://es5.github.io/#x15.11.4.4\n      return (error.name || \'Error\') + (error.message ? ": ".concat(error.message) : \'\');\n    } else {\n      return resultErrorString;\n    }\n  }\n\n  var BOXABLE_TYPES = new StringSet([\'boolean\', \'number\', \'string\']);\n\n  // Memory for previously seen containers (object, array, map, set).\n  // Used for recursion detection, and to avoid repeated comparison.\n  //\n  // Elements are { a: val, b: val }.\n  var memory = [];\n  function useStrictEquality(a, b) {\n    return a === b;\n  }\n  function useObjectValueEquality(a, b) {\n    return a === b || a.valueOf() === b.valueOf();\n  }\n  function compareConstructors(a, b) {\n    // Comparing constructors is more strict than using `instanceof`\n    return getConstructor(a) === getConstructor(b);\n  }\n  function getConstructor(obj) {\n    var proto = Object.getPrototypeOf(obj);\n\n    // If the obj prototype descends from a null constructor, treat it\n    // as a null prototype.\n    // Ref https://github.com/qunitjs/qunit/issues/851\n    //\n    // Allow objects with no prototype, from Object.create(null), to be equivalent to\n    // plain objects that have Object as their constructor.\n    return !proto || proto.constructor === null ? Object : obj.constructor;\n  }\n  function getRegExpFlags(regexp) {\n    return \'flags\' in regexp ? regexp.flags : regexp.toString().match(/[gimuy]*$/)[0];\n  }\n\n  // Specialised comparisons after entryTypeCallbacks.object, based on `objectType()`\n  var objTypeCallbacks = {\n    undefined: useStrictEquality,\n    null: useStrictEquality,\n    // Handle boxed boolean\n    boolean: useObjectValueEquality,\n    number: function number(a, b) {\n      // Handle NaN and boxed number\n      return a === b || a.valueOf() === b.valueOf() || isNaN(a.valueOf()) && isNaN(b.valueOf());\n    },\n    // Handle boxed string\n    string: useObjectValueEquality,\n    symbol: useStrictEquality,\n    date: useObjectValueEquality,\n    nan: function nan() {\n      return true;\n    },\n    regexp: function regexp(a, b) {\n      return a.source === b.source &&\n      // Include flags in the comparison\n      getRegExpFlags(a) === getRegExpFlags(b);\n    },\n    // identical reference only\n    function: useStrictEquality,\n    array: function array(a, b) {\n      if (a.length !== b.length) {\n        // Safe and faster\n        return false;\n      }\n      for (var i = 0; i < a.length; i++) {\n        if (!typeEquiv(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    },\n    // Define sets a and b to be equivalent if for each element aVal in a, there\n    // is some element bVal in b such that aVal and bVal are equivalent. Element\n    // repetitions are not counted, so these are equivalent:\n    // a = new Set( [ X={}, Y=[], Y ] );\n    // b = new Set( [ Y, X, X ] );\n    set: function set(a, b) {\n      if (a.size !== b.size) {\n        // This optimization has certain quirks because of the lack of\n        // repetition counting. For instance, adding the same\n        // (reference-identical) element to two equivalent sets can\n        // make them non-equivalent.\n        return false;\n      }\n      var outerEq = true;\n      a.forEach(function (aVal) {\n        // Short-circuit if the result is already known. (Using for...of\n        // with a break clause would be cleaner here, but it would cause\n        // a syntax error on older JavaScript implementations even if\n        // Set is unused)\n        if (!outerEq) {\n          return;\n        }\n        var innerEq = false;\n        b.forEach(function (bVal) {\n          // Likewise, short-circuit if the result is already known\n          if (innerEq) {\n            return;\n          }\n\n          // Swap out the global memory, as nested typeEquiv() would clobber it\n          var originalMemory = memory;\n          memory = [];\n          if (typeEquiv(bVal, aVal)) {\n            innerEq = true;\n          }\n          // Restore\n          memory = originalMemory;\n        });\n        if (!innerEq) {\n          outerEq = false;\n        }\n      });\n      return outerEq;\n    },\n    // Define maps a and b to be equivalent if for each key-value pair (aKey, aVal)\n    // in a, there is some key-value pair (bKey, bVal) in b such that\n    // [ aKey, aVal ] and [ bKey, bVal ] are equivalent. Key repetitions are not\n    // counted, so these are equivalent:\n    // a = new Map( [ [ {}, 1 ], [ {}, 1 ], [ [], 1 ] ] );\n    // b = new Map( [ [ {}, 1 ], [ [], 1 ], [ [], 1 ] ] );\n    map: function map(a, b) {\n      if (a.size !== b.size) {\n        // This optimization has certain quirks because of the lack of\n        // repetition counting. For instance, adding the same\n        // (reference-identical) key-value pair to two equivalent maps\n        // can make them non-equivalent.\n        return false;\n      }\n      var outerEq = true;\n      a.forEach(function (aVal, aKey) {\n        // Short-circuit if the result is already known. (Using for...of\n        // with a break clause would be cleaner here, but it would cause\n        // a syntax error on older JavaScript implementations even if\n        // Map is unused)\n        if (!outerEq) {\n          return;\n        }\n        var innerEq = false;\n        b.forEach(function (bVal, bKey) {\n          // Likewise, short-circuit if the result is already known\n          if (innerEq) {\n            return;\n          }\n\n          // Swap out the global memory, as nested typeEquiv() would clobber it\n          var originalMemory = memory;\n          memory = [];\n          if (objTypeCallbacks.array([bVal, bKey], [aVal, aKey])) {\n            innerEq = true;\n          }\n          // Restore\n          memory = originalMemory;\n        });\n        if (!innerEq) {\n          outerEq = false;\n        }\n      });\n      return outerEq;\n    }\n  };\n\n  // Entry points from typeEquiv, based on `typeof`\n  var entryTypeCallbacks = {\n    undefined: useStrictEquality,\n    null: useStrictEquality,\n    boolean: useStrictEquality,\n    number: function number(a, b) {\n      // Handle NaN\n      return a === b || isNaN(a) && isNaN(b);\n    },\n    string: useStrictEquality,\n    symbol: useStrictEquality,\n    function: useStrictEquality,\n    object: function object(a, b) {\n      // Handle memory (skip recursion)\n      if (memory.some(function (pair) {\n        return pair.a === a && pair.b === b;\n      })) {\n        return true;\n      }\n      memory.push({\n        a: a,\n        b: b\n      });\n      var aObjType = objectType(a);\n      var bObjType = objectType(b);\n      if (aObjType !== \'object\' || bObjType !== \'object\') {\n        // Handle literal `null`\n        // Handle: Array, Map/Set, Date, Regxp/Function, boxed primitives\n        return aObjType === bObjType && objTypeCallbacks[aObjType](a, b);\n      }\n\n      // NOTE: Literal null must not make it here as it would throw\n      if (compareConstructors(a, b) === false) {\n        return false;\n      }\n      var aProperties = [];\n      var bProperties = [];\n\n      // Be strict and go deep, no filtering with hasOwnProperty.\n      for (var i in a) {\n        // Collect a\'s properties\n        aProperties.push(i);\n\n        // Skip OOP methods that look the same\n        if (a.constructor !== Object && typeof a.constructor !== \'undefined\' && typeof a[i] === \'function\' && typeof b[i] === \'function\' && a[i].toString() === b[i].toString()) {\n          continue;\n        }\n        if (!typeEquiv(a[i], b[i])) {\n          return false;\n        }\n      }\n      for (var _i in b) {\n        // Collect b\'s properties\n        bProperties.push(_i);\n      }\n      return objTypeCallbacks.array(aProperties.sort(), bProperties.sort());\n    }\n  };\n  function typeEquiv(a, b) {\n    // Optimization: Only perform type-specific comparison when pairs are not strictly equal.\n    if (a === b) {\n      return true;\n    }\n    var aType = _typeof(a);\n    var bType = _typeof(b);\n    if (aType !== bType) {\n      // Support comparing primitive to boxed primitives\n      // Try again after possibly unwrapping one\n      return (aType === \'object\' && BOXABLE_TYPES.has(objectType(a)) ? a.valueOf() : a) === (bType === \'object\' && BOXABLE_TYPES.has(objectType(b)) ? b.valueOf() : b);\n    }\n    return entryTypeCallbacks[aType](a, b);\n  }\n  function innerEquiv(a, b) {\n    var res = typeEquiv(a, b);\n    // Release any retained objects and reset recursion detection for next call\n    memory = [];\n    return res;\n  }\n\n  /**\n   * Test any two types of JavaScript values for equality.\n   *\n   * @author Philippe Rath <prathe@gmail.com>\n   * @author David Chan <david@troi.org>\n   */\n  function equiv(a, b) {\n    if (arguments.length === 2) {\n      return a === b || innerEquiv(a, b);\n    }\n\n    // Given 0 or 1 arguments, just return true (nothing to compare).\n    // Given (A,B,C,D) compare C,D then B,C then A,B.\n    var i = arguments.length - 1;\n    while (i > 0) {\n      if (!innerEquiv(arguments[i - 1], arguments[i])) {\n        return false;\n      }\n      i--;\n    }\n    return true;\n  }\n\n  /**\n   * Config object: Maintain internal state\n   * Later exposed as QUnit.config\n   * `config` initialized at top of scope\n   */\n  var config = {\n    // HTML Reporter: Modify document.title when suite is done\n    altertitle: true,\n    // HTML Reporter: collapse every test except the first failing test\n    // If false, all failing tests will be expanded\n    collapse: true,\n    // whether or not to fail when there are zero tests\n    // defaults to `true`\n    failOnZeroTests: true,\n    // Select by pattern or case-insensitive substring match against "moduleName: testName"\n    filter: undefined,\n    // Depth up-to which object will be dumped\n    maxDepth: 5,\n    // Select case-insensitive match of the module name\n    module: undefined,\n    // HTML Reporter: Select module/test by array of internal IDs\n    moduleId: undefined,\n    // By default, run previously failed tests first\n    // very useful in combination with "Hide passed tests" checked\n    reorder: true,\n    // When enabled, all tests must call expect()\n    requireExpects: false,\n    // By default, scroll to top of the page when suite is done\n    scrolltop: true,\n    // The storage module to use for reordering tests\n    storage: localSessionStorage,\n    testId: undefined,\n    // HTML Reporter: List of URL parameters that are given visual controls\n    urlConfig: [],\n    // Internal: The first unnamed module\n    //\n    // By being defined as the intial value for currentModule, it is the\n    // receptacle and implied parent for any global tests. It is as if we\n    // called `QUnit.module( "" );` before any other tests were defined.\n    //\n    // If we reach begin() and no tests were put in it, we dequeue it as if it\n    // never existed, and in that case never expose it to the events and\n    // callbacks API.\n    //\n    // When global tests are defined, then this unnamed module will execute\n    // as any other module, including moduleStart/moduleDone events etc.\n    //\n    // Since this module isn\'t explicitly created by the user, they have no\n    // access to add hooks for it. The hooks object is defined to comply\n    // with internal expectations of test.js, but they will be empty.\n    // To apply hooks, place tests explicitly in a QUnit.module(), and use\n    // its hooks accordingly.\n    //\n    // For global hooks that apply to all tests and all modules, use QUnit.hooks.\n    //\n    // NOTE: This is *not* a "global module". It is not an ancestor of all modules\n    // and tests. It is merely the parent for any tests defined globally,\n    // before the first QUnit.module(). As such, the events for this unnamed\n    // module will fire as normal, right after its last test, and *not* at\n    // the end of the test run.\n    //\n    // NOTE: This also should probably also not become a global module, unless\n    // we keep it out of the public API. For example, it would likely not\n    // improve the user interface and plugin behaviour if all modules became\n    // wrapped between the start and end events of this module, and thus\n    // needlessly add indentation, indirection, or other visible noise.\n    // Unit tests for the callbacks API would detect that as a regression.\n    currentModule: {\n      name: \'\',\n      tests: [],\n      childModules: [],\n      testsRun: 0,\n      testsIgnored: 0,\n      hooks: {\n        before: [],\n        beforeEach: [],\n        afterEach: [],\n        after: []\n      }\n    },\n    // Internal: Exposed to make resets easier\n    // Ref https://github.com/qunitjs/qunit/pull/1598\n    globalHooks: {},\n    // Internal state\n    blocking: true,\n    callbacks: {},\n    modules: [],\n    queue: [],\n    stats: {\n      all: 0,\n      bad: 0,\n      testCount: 0\n    }\n  };\n\n  // Apply a predefined QUnit.config object\n  //\n  // Ignore QUnit.config if it is a QUnit distribution instead of preconfig.\n  // That means QUnit was loaded twice! (Use the same approach as export.js)\n  var preConfig = g && g.QUnit && !g.QUnit.version && g.QUnit.config;\n  if (preConfig) {\n    extend(config, preConfig);\n  }\n\n  // Push a loose unnamed module to the modules collection\n  config.modules.push(config.currentModule);\n\n  var dump = (function () {\n    function quote(str) {\n      return \'"\' + str.toString().replace(/\\\\/g, \'\\\\\\\\\').replace(/"/g, \'\\\\"\') + \'"\';\n    }\n    function literal(o) {\n      return o + \'\';\n    }\n    function join(pre, arr, post) {\n      var s = dump.separator();\n      var inner = dump.indent(1);\n      if (arr.join) {\n        arr = arr.join(\',\' + s + inner);\n      }\n      if (!arr) {\n        return pre + post;\n      }\n      var base = dump.indent();\n      return [pre, inner + arr, base + post].join(s);\n    }\n    function array(arr, stack) {\n      if (dump.maxDepth && dump.depth > dump.maxDepth) {\n        return \'[object Array]\';\n      }\n      this.up();\n      var i = arr.length;\n      var ret = new Array(i);\n      while (i--) {\n        ret[i] = this.parse(arr[i], undefined, stack);\n      }\n      this.down();\n      return join(\'[\', ret, \']\');\n    }\n    function isArray(obj) {\n      return (\n        // Native Arrays\n        toString.call(obj) === \'[object Array]\' ||\n        // NodeList objects\n        typeof obj.length === \'number\' && obj.item !== undefined && (obj.length ? obj.item(0) === obj[0] : obj.item(0) === null && obj[0] === undefined)\n      );\n    }\n    var reName = /^function (\\w+)/;\n    var dump = {\n      // The objType is used mostly internally, you can fix a (custom) type in advance\n      parse: function parse(obj, objType, stack) {\n        stack = stack || [];\n        var objIndex = stack.indexOf(obj);\n        if (objIndex !== -1) {\n          return "recursion(".concat(objIndex - stack.length, ")");\n        }\n        objType = objType || this.typeOf(obj);\n        var parser = this.parsers[objType];\n        var parserType = _typeof(parser);\n        if (parserType === \'function\') {\n          stack.push(obj);\n          var res = parser.call(this, obj, stack);\n          stack.pop();\n          return res;\n        }\n        if (parserType === \'string\') {\n          return parser;\n        }\n        return \'[ERROR: Missing QUnit.dump formatter for type \' + objType + \']\';\n      },\n      typeOf: function typeOf(obj) {\n        var type;\n        if (obj === null) {\n          type = \'null\';\n        } else if (typeof obj === \'undefined\') {\n          type = \'undefined\';\n        } else if (is(\'regexp\', obj)) {\n          type = \'regexp\';\n        } else if (is(\'date\', obj)) {\n          type = \'date\';\n        } else if (is(\'function\', obj)) {\n          type = \'function\';\n        } else if (obj.setInterval !== undefined && obj.document !== undefined && obj.nodeType === undefined) {\n          type = \'window\';\n        } else if (obj.nodeType === 9) {\n          type = \'document\';\n        } else if (obj.nodeType) {\n          type = \'node\';\n        } else if (isArray(obj)) {\n          type = \'array\';\n        } else if (obj.constructor === Error.prototype.constructor) {\n          type = \'error\';\n        } else {\n          type = _typeof(obj);\n        }\n        return type;\n      },\n      separator: function separator() {\n        if (this.multiline) {\n          return this.HTML ? \'<br />\' : \'\\n\';\n        } else {\n          return this.HTML ? \'&#160;\' : \' \';\n        }\n      },\n      // Extra can be a number, shortcut for increasing-calling-decreasing\n      indent: function indent(extra) {\n        if (!this.multiline) {\n          return \'\';\n        }\n        var chr = this.indentChar;\n        if (this.HTML) {\n          chr = chr.replace(/\\t/g, \'   \').replace(/ /g, \'&#160;\');\n        }\n        return new Array(this.depth + (extra || 0)).join(chr);\n      },\n      up: function up(a) {\n        this.depth += a || 1;\n      },\n      down: function down(a) {\n        this.depth -= a || 1;\n      },\n      setParser: function setParser(name, parser) {\n        this.parsers[name] = parser;\n      },\n      // The next 3 are exposed so you can use them\n      quote: quote,\n      literal: literal,\n      join: join,\n      depth: 1,\n      maxDepth: config.maxDepth,\n      // This is the list of parsers, to modify them, use dump.setParser\n      parsers: {\n        window: \'[Window]\',\n        document: \'[Document]\',\n        error: function error(_error) {\n          return \'Error("\' + _error.message + \'")\';\n        },\n        // This has been unused since QUnit 1.0.0.\n        // @todo Deprecate and remove.\n        unknown: \'[Unknown]\',\n        null: \'null\',\n        undefined: \'undefined\',\n        function: function _function(fn) {\n          var ret = \'function\';\n\n          // Functions never have name in IE\n          var name = \'name\' in fn ? fn.name : (reName.exec(fn) || [])[1];\n          if (name) {\n            ret += \' \' + name;\n          }\n          ret += \'(\';\n          ret = [ret, dump.parse(fn, \'functionArgs\'), \'){\'].join(\'\');\n          return join(ret, dump.parse(fn, \'functionCode\'), \'}\');\n        },\n        array: array,\n        nodelist: array,\n        arguments: array,\n        object: function object(map, stack) {\n          var ret = [];\n          if (dump.maxDepth && dump.depth > dump.maxDepth) {\n            return \'[object Object]\';\n          }\n          dump.up();\n          var keys = [];\n          for (var key in map) {\n            keys.push(key);\n          }\n\n          // Some properties are not always enumerable on Error objects.\n          var nonEnumerableProperties = [\'message\', \'name\'];\n          for (var i in nonEnumerableProperties) {\n            var _key = nonEnumerableProperties[i];\n            if (_key in map && !inArray(_key, keys)) {\n              keys.push(_key);\n            }\n          }\n          keys.sort();\n          for (var _i = 0; _i < keys.length; _i++) {\n            var _key2 = keys[_i];\n            var val = map[_key2];\n            ret.push(dump.parse(_key2, \'key\') + \': \' + dump.parse(val, undefined, stack));\n          }\n          dump.down();\n          return join(\'{\', ret, \'}\');\n        },\n        node: function node(_node) {\n          var open = dump.HTML ? \'&lt;\' : \'<\';\n          var close = dump.HTML ? \'&gt;\' : \'>\';\n          var tag = _node.nodeName.toLowerCase();\n          var ret = open + tag;\n          var attrs = _node.attributes;\n          if (attrs) {\n            for (var i = 0; i < attrs.length; i++) {\n              var val = attrs[i].nodeValue;\n\n              // IE6 includes all attributes in .attributes, even ones not explicitly\n              // set. Those have values like undefined, null, 0, false, "" or\n              // "inherit".\n              if (val && val !== \'inherit\') {\n                ret += \' \' + attrs[i].nodeName + \'=\' + dump.parse(val, \'attribute\');\n              }\n            }\n          }\n          ret += close;\n\n          // Show content of TextNode or CDATASection\n          if (_node.nodeType === 3 || _node.nodeType === 4) {\n            ret += _node.nodeValue;\n          }\n          return ret + open + \'/\' + tag + close;\n        },\n        // Function calls it internally, it\'s the arguments part of the function\n        functionArgs: function functionArgs(fn) {\n          var l = fn.length;\n          if (!l) {\n            return \'\';\n          }\n          var args = new Array(l);\n          while (l--) {\n            // 97 is \'a\'\n            args[l] = String.fromCharCode(97 + l);\n          }\n          return \' \' + args.join(\', \') + \' \';\n        },\n        // Object calls it internally, the key part of an item in a map\n        key: quote,\n        // Function calls it internally, it\'s the content of the function\n        functionCode: \'[code]\',\n        // Node calls it internally, it\'s a html attribute value\n        attribute: quote,\n        string: quote,\n        date: quote,\n        regexp: literal,\n        number: literal,\n        boolean: literal,\n        symbol: function symbol(sym) {\n          return sym.toString();\n        }\n      },\n      // If true, entities are escaped ( <, >, \\t, space and \\n )\n      HTML: false,\n      // Indentation unit\n      indentChar: \'  \',\n      // If true, items in a collection, are separated by a \\n, else just a space.\n      multiline: true\n    };\n    return dump;\n  })();\n\n  var SuiteReport = /*#__PURE__*/function () {\n    function SuiteReport(name, parentSuite) {\n      _classCallCheck(this, SuiteReport);\n      this.name = name;\n      this.fullName = parentSuite ? parentSuite.fullName.concat(name) : [];\n\n      // When an "error" event is emitted from onUncaughtException(), the\n      // "runEnd" event should report the status as failed. The "runEnd" event data\n      // is tracked through this property (via the "runSuite" instance).\n      this.globalFailureCount = 0;\n      this.tests = [];\n      this.childSuites = [];\n      if (parentSuite) {\n        parentSuite.pushChildSuite(this);\n      }\n    }\n    _createClass(SuiteReport, [{\n      key: "start",\n      value: function start(recordTime) {\n        if (recordTime) {\n          this._startTime = performance.now();\n          var suiteLevel = this.fullName.length;\n          performance.mark("qunit_suite_".concat(suiteLevel, "_start"));\n        }\n        return {\n          name: this.name,\n          fullName: this.fullName.slice(),\n          tests: this.tests.map(function (test) {\n            return test.start();\n          }),\n          childSuites: this.childSuites.map(function (suite) {\n            return suite.start();\n          }),\n          testCounts: {\n            total: this.getTestCounts().total\n          }\n        };\n      }\n    }, {\n      key: "end",\n      value: function end(recordTime) {\n        if (recordTime) {\n          this._endTime = performance.now();\n          var suiteLevel = this.fullName.length;\n          var suiteName = this.fullName.join(\' \u2013 \');\n          performance.mark("qunit_suite_".concat(suiteLevel, "_end"));\n          performance.measure(suiteLevel === 0 ? \'QUnit Test Run\' : "QUnit Test Suite: ".concat(suiteName), "qunit_suite_".concat(suiteLevel, "_start"), "qunit_suite_".concat(suiteLevel, "_end"));\n        }\n        return {\n          name: this.name,\n          fullName: this.fullName.slice(),\n          tests: this.tests.map(function (test) {\n            return test.end();\n          }),\n          childSuites: this.childSuites.map(function (suite) {\n            return suite.end();\n          }),\n          testCounts: this.getTestCounts(),\n          runtime: this.getRuntime(),\n          status: this.getStatus()\n        };\n      }\n    }, {\n      key: "pushChildSuite",\n      value: function pushChildSuite(suite) {\n        this.childSuites.push(suite);\n      }\n    }, {\n      key: "pushTest",\n      value: function pushTest(test) {\n        this.tests.push(test);\n      }\n    }, {\n      key: "getRuntime",\n      value: function getRuntime() {\n        return Math.round(this._endTime - this._startTime);\n      }\n    }, {\n      key: "getTestCounts",\n      value: function getTestCounts() {\n        var counts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n          passed: 0,\n          failed: 0,\n          skipped: 0,\n          todo: 0,\n          total: 0\n        };\n        counts.failed += this.globalFailureCount;\n        counts.total += this.globalFailureCount;\n        counts = this.tests.reduce(function (counts, test) {\n          if (test.valid) {\n            counts[test.getStatus()]++;\n            counts.total++;\n          }\n          return counts;\n        }, counts);\n        return this.childSuites.reduce(function (counts, suite) {\n          return suite.getTestCounts(counts);\n        }, counts);\n      }\n    }, {\n      key: "getStatus",\n      value: function getStatus() {\n        var _this$getTestCounts = this.getTestCounts(),\n          total = _this$getTestCounts.total,\n          failed = _this$getTestCounts.failed,\n          skipped = _this$getTestCounts.skipped,\n          todo = _this$getTestCounts.todo;\n        if (failed) {\n          return \'failed\';\n        } else {\n          if (skipped === total) {\n            return \'skipped\';\n          } else if (todo === total) {\n            return \'todo\';\n          } else {\n            return \'passed\';\n          }\n        }\n      }\n    }]);\n    return SuiteReport;\n  }();\n\n  var moduleStack = [];\n  var runSuite = new SuiteReport();\n  function isParentModuleInQueue() {\n    var modulesInQueue = config.modules.filter(function (module) {\n      return !module.ignored;\n    }).map(function (module) {\n      return module.moduleId;\n    });\n    return moduleStack.some(function (module) {\n      return modulesInQueue.includes(module.moduleId);\n    });\n  }\n  function createModule(name, testEnvironment, modifiers) {\n    var parentModule = moduleStack.length ? moduleStack.slice(-1)[0] : null;\n    var moduleName = parentModule !== null ? [parentModule.name, name].join(\' > \') : name;\n    var parentSuite = parentModule ? parentModule.suiteReport : runSuite;\n    var skip = parentModule !== null && parentModule.skip || modifiers.skip;\n    var todo = parentModule !== null && parentModule.todo || modifiers.todo;\n    var env = {};\n    if (parentModule) {\n      extend(env, parentModule.testEnvironment);\n    }\n    extend(env, testEnvironment);\n    var module = {\n      name: moduleName,\n      parentModule: parentModule,\n      hooks: {\n        before: [],\n        beforeEach: [],\n        afterEach: [],\n        after: []\n      },\n      testEnvironment: env,\n      tests: [],\n      moduleId: generateHash(moduleName),\n      testsRun: 0,\n      testsIgnored: 0,\n      childModules: [],\n      suiteReport: new SuiteReport(name, parentSuite),\n      // Initialised by test.js when the module start executing,\n      // i.e. before the first test in this module (or a child).\n      stats: null,\n      // Pass along `skip` and `todo` properties from parent module, in case\n      // there is one, to childs. And use own otherwise.\n      // This property will be used to mark own tests and tests of child suites\n      // as either `skipped` or `todo`.\n      skip: skip,\n      todo: skip ? false : todo,\n      ignored: modifiers.ignored || false\n    };\n    if (parentModule) {\n      parentModule.childModules.push(module);\n    }\n    config.modules.push(module);\n    return module;\n  }\n  function setHookFromEnvironment(hooks, environment, name) {\n    var potentialHook = environment[name];\n    if (typeof potentialHook === \'function\') {\n      hooks[name].push(potentialHook);\n    }\n    delete environment[name];\n  }\n  function makeSetHook(module, hookName) {\n    return function setHook(callback) {\n      if (config.currentModule !== module) {\n        Logger.warn(\'The `\' + hookName + \'` hook was called inside the wrong module (`\' + config.currentModule.name + \'`). \' + \'Instead, use hooks provided by the callback to the containing module (`\' + module.name + \'`). \' + \'This will become an error in QUnit 3.0.\');\n      }\n      module.hooks[hookName].push(callback);\n    };\n  }\n  function processModule(name, options, executeNow) {\n    var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    if (typeof options === \'function\') {\n      executeNow = options;\n      options = undefined;\n    }\n    var module = createModule(name, options, modifiers);\n\n    // Transfer any initial hooks from the options object to the \'hooks\' object\n    var testEnvironment = module.testEnvironment;\n    var hooks = module.hooks;\n    setHookFromEnvironment(hooks, testEnvironment, \'before\');\n    setHookFromEnvironment(hooks, testEnvironment, \'beforeEach\');\n    setHookFromEnvironment(hooks, testEnvironment, \'afterEach\');\n    setHookFromEnvironment(hooks, testEnvironment, \'after\');\n    var moduleFns = {\n      before: makeSetHook(module, \'before\'),\n      beforeEach: makeSetHook(module, \'beforeEach\'),\n      afterEach: makeSetHook(module, \'afterEach\'),\n      after: makeSetHook(module, \'after\')\n    };\n    var prevModule = config.currentModule;\n    config.currentModule = module;\n    if (typeof executeNow === \'function\') {\n      moduleStack.push(module);\n      try {\n        var cbReturnValue = executeNow.call(module.testEnvironment, moduleFns);\n        if (cbReturnValue && typeof cbReturnValue.then === \'function\') {\n          Logger.warn(\'Returning a promise from a module callback is not supported. \' + \'Instead, use hooks for async behavior. \' + \'This will become an error in QUnit 3.0.\');\n        }\n      } finally {\n        // If the module closure threw an uncaught error during the load phase,\n        // we let this bubble up to global error handlers. But, not until after\n        // we teardown internal state to ensure correct module nesting.\n        // Ref https://github.com/qunitjs/qunit/issues/1478.\n        moduleStack.pop();\n        config.currentModule = module.parentModule || prevModule;\n      }\n    }\n  }\n  var focused$1 = false; // indicates that the "only" filter was used\n\n  function module$1(name, options, executeNow) {\n    var ignored = focused$1 && !isParentModuleInQueue();\n    processModule(name, options, executeNow, {\n      ignored: ignored\n    });\n  }\n  module$1.only = function () {\n    if (!focused$1) {\n      // Upon the first module.only() call,\n      // delete any and all previously registered modules and tests.\n      config.modules.length = 0;\n      config.queue.length = 0;\n\n      // Ignore any tests declared after this block within the same\n      // module parent. https://github.com/qunitjs/qunit/issues/1645\n      config.currentModule.ignored = true;\n    }\n    focused$1 = true;\n    processModule.apply(void 0, arguments);\n  };\n  module$1.skip = function (name, options, executeNow) {\n    if (focused$1) {\n      return;\n    }\n    processModule(name, options, executeNow, {\n      skip: true\n    });\n  };\n  module$1.todo = function (name, options, executeNow) {\n    if (focused$1) {\n      return;\n    }\n    processModule(name, options, executeNow, {\n      todo: true\n    });\n  };\n\n  // Doesn\'t support IE9, it will return undefined on these browsers\n  // See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\n  var fileName = (sourceFromStacktrace(0) || \'\').replace(/(:\\d+)+\\)?/, \'\')\n  // Remove anything prior to the last slash (Unix/Windows)\n  // from the last frame\n  .replace(/.+[/\\\\]/, \'\');\n  function extractStacktrace(e, offset) {\n    offset = offset === undefined ? 4 : offset;\n    if (e && e.stack) {\n      var stack = e.stack.split(\'\\n\');\n      if (/^error$/i.test(stack[0])) {\n        stack.shift();\n      }\n      if (fileName) {\n        var include = [];\n        for (var i = offset; i < stack.length; i++) {\n          if (stack[i].indexOf(fileName) !== -1) {\n            break;\n          }\n          include.push(stack[i]);\n        }\n        if (include.length) {\n          return include.join(\'\\n\');\n        }\n      }\n      return stack[offset];\n    }\n  }\n  function sourceFromStacktrace(offset) {\n    var error = new Error();\n\n    // Support: Safari <=7 only, IE <=10 - 11 only\n    // Not all browsers generate the `stack` property for `new Error()`, see also #636\n    if (!error.stack) {\n      try {\n        throw error;\n      } catch (err) {\n        error = err;\n      }\n    }\n    return extractStacktrace(error, offset);\n  }\n\n  var Assert = /*#__PURE__*/function () {\n    function Assert(testContext) {\n      _classCallCheck(this, Assert);\n      this.test = testContext;\n    }\n    _createClass(Assert, [{\n      key: "timeout",\n      value: function timeout(duration) {\n        if (typeof duration !== \'number\') {\n          throw new Error(\'You must pass a number as the duration to assert.timeout\');\n        }\n        this.test.timeout = duration;\n\n        // If a timeout has been set, clear it and reset with the new duration\n        if (config.timeout) {\n          clearTimeout(config.timeout);\n          config.timeout = null;\n          if (config.timeoutHandler && this.test.timeout > 0) {\n            this.test.internalResetTimeout(this.test.timeout);\n          }\n        }\n      }\n\n      // Documents a "step", which is a string value, in a test as a passing assertion\n    }, {\n      key: "step",\n      value: function step(message) {\n        var assertionMessage = message;\n        var result = !!message;\n        this.test.steps.push(message);\n        if (typeof message === \'undefined\' || message === \'\') {\n          assertionMessage = \'You must provide a message to assert.step\';\n        } else if (typeof message !== \'string\') {\n          assertionMessage = \'You must provide a string value to assert.step\';\n          result = false;\n        }\n        this.pushResult({\n          result: result,\n          message: assertionMessage\n        });\n      }\n\n      // Verifies the steps in a test match a given array of string values\n    }, {\n      key: "verifySteps",\n      value: function verifySteps(steps, message) {\n        // Since the steps array is just string values, we can clone with slice\n        var actualStepsClone = this.test.steps.slice();\n        this.deepEqual(actualStepsClone, steps, message);\n        this.test.steps.length = 0;\n      }\n    }, {\n      key: "expect",\n      value: function expect(asserts) {\n        if (arguments.length === 1) {\n          this.test.expected = asserts;\n        } else {\n          return this.test.expected;\n        }\n      }\n\n      // Create a new async pause and return a new function that can release the pause.\n    }, {\n      key: "async",\n      value: function async(count) {\n        var requiredCalls = count === undefined ? 1 : count;\n        return this.test.internalStop(requiredCalls);\n      }\n\n      // Exports test.push() to the user API\n      // Alias of pushResult.\n    }, {\n      key: "push",\n      value: function push(result, actual, expected, message, negative) {\n        Logger.warn(\'assert.push is deprecated and will be removed in QUnit 3.0.\' + \' Please use assert.pushResult instead (https://api.qunitjs.com/assert/pushResult).\');\n        var currentAssert = this instanceof Assert ? this : config.current.assert;\n        return currentAssert.pushResult({\n          result: result,\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: negative\n        });\n      }\n    }, {\n      key: "pushResult",\n      value: function pushResult(resultInfo) {\n        // Destructure of resultInfo = { result, actual, expected, message, negative }\n        var assert = this;\n        var currentTest = assert instanceof Assert && assert.test || config.current;\n\n        // Backwards compatibility fix.\n        // Allows the direct use of global exported assertions and QUnit.assert.*\n        // Although, it\'s use is not recommended as it can leak assertions\n        // to other tests from async tests, because we only get a reference to the current test,\n        // not exactly the test where assertion were intended to be called.\n        if (!currentTest) {\n          throw new Error(\'assertion outside test context, in \' + sourceFromStacktrace(2));\n        }\n        if (!(assert instanceof Assert)) {\n          assert = currentTest.assert;\n        }\n        return assert.test.pushResult(resultInfo);\n      }\n    }, {\n      key: "ok",\n      value: function ok(result, message) {\n        if (!message) {\n          message = result ? \'okay\' : "failed, expected argument to be truthy, was: ".concat(dump.parse(result));\n        }\n        this.pushResult({\n          result: !!result,\n          actual: result,\n          expected: true,\n          message: message\n        });\n      }\n    }, {\n      key: "notOk",\n      value: function notOk(result, message) {\n        if (!message) {\n          message = !result ? \'okay\' : "failed, expected argument to be falsy, was: ".concat(dump.parse(result));\n        }\n        this.pushResult({\n          result: !result,\n          actual: result,\n          expected: false,\n          message: message\n        });\n      }\n    }, {\n      key: "true",\n      value: function _true(result, message) {\n        this.pushResult({\n          result: result === true,\n          actual: result,\n          expected: true,\n          message: message\n        });\n      }\n    }, {\n      key: "false",\n      value: function _false(result, message) {\n        this.pushResult({\n          result: result === false,\n          actual: result,\n          expected: false,\n          message: message\n        });\n      }\n    }, {\n      key: "equal",\n      value: function equal(actual, expected, message) {\n        this.pushResult({\n          // eslint-disable-next-line eqeqeq\n          result: expected == actual,\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: "notEqual",\n      value: function notEqual(actual, expected, message) {\n        this.pushResult({\n          // eslint-disable-next-line eqeqeq\n          result: expected != actual,\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: "propEqual",\n      value: function propEqual(actual, expected, message) {\n        actual = objectValues(actual);\n        expected = objectValues(expected);\n        this.pushResult({\n          result: equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: "notPropEqual",\n      value: function notPropEqual(actual, expected, message) {\n        actual = objectValues(actual);\n        expected = objectValues(expected);\n        this.pushResult({\n          result: !equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: "propContains",\n      value: function propContains(actual, expected, message) {\n        actual = objectValuesSubset(actual, expected);\n\n        // The expected parameter is usually a plain object, but clone it for\n        // consistency with propEqual(), and to make it easy to explain that\n        // inheritence is not considered (on either side), and to support\n        // recursively checking subsets of nested objects.\n        expected = objectValues(expected, false);\n        this.pushResult({\n          result: equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: "notPropContains",\n      value: function notPropContains(actual, expected, message) {\n        actual = objectValuesSubset(actual, expected);\n        expected = objectValues(expected);\n        this.pushResult({\n          result: !equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: "deepEqual",\n      value: function deepEqual(actual, expected, message) {\n        this.pushResult({\n          result: equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: "notDeepEqual",\n      value: function notDeepEqual(actual, expected, message) {\n        this.pushResult({\n          result: !equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: "strictEqual",\n      value: function strictEqual(actual, expected, message) {\n        this.pushResult({\n          result: expected === actual,\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: "notStrictEqual",\n      value: function notStrictEqual(actual, expected, message) {\n        this.pushResult({\n          result: expected !== actual,\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: \'throws\',\n      value: function throws(block, expected, message) {\n        var _validateExpectedExce = validateExpectedExceptionArgs(expected, message, \'throws\');\n        var _validateExpectedExce2 = _slicedToArray(_validateExpectedExce, 2);\n        expected = _validateExpectedExce2[0];\n        message = _validateExpectedExce2[1];\n        var currentTest = this instanceof Assert && this.test || config.current;\n        if (typeof block !== \'function\') {\n          currentTest.assert.pushResult({\n            result: false,\n            actual: block,\n            message: \'The value provided to `assert.throws` in \' + \'"\' + currentTest.testName + \'" was not a function.\'\n          });\n          return;\n        }\n        var actual;\n        var result = false;\n        currentTest.ignoreGlobalErrors = true;\n        try {\n          block.call(currentTest.testEnvironment);\n        } catch (e) {\n          actual = e;\n        }\n        currentTest.ignoreGlobalErrors = false;\n        if (actual) {\n          var _validateException = validateException(actual, expected, message);\n          var _validateException2 = _slicedToArray(_validateException, 3);\n          result = _validateException2[0];\n          expected = _validateException2[1];\n          message = _validateException2[2];\n        }\n        currentTest.assert.pushResult({\n          result: result,\n          // undefined if it didn\'t throw\n          actual: actual && errorString(actual),\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: "rejects",\n      value: function rejects(promise, expected, message) {\n        var _validateExpectedExce3 = validateExpectedExceptionArgs(expected, message, \'rejects\');\n        var _validateExpectedExce4 = _slicedToArray(_validateExpectedExce3, 2);\n        expected = _validateExpectedExce4[0];\n        message = _validateExpectedExce4[1];\n        var currentTest = this instanceof Assert && this.test || config.current;\n        var then = promise && promise.then;\n        if (typeof then !== \'function\') {\n          currentTest.assert.pushResult({\n            result: false,\n            message: \'The value provided to `assert.rejects` in \' + \'"\' + currentTest.testName + \'" was not a promise.\',\n            actual: promise\n          });\n          return;\n        }\n        var done = this.async();\n        return then.call(promise, function handleFulfillment() {\n          currentTest.assert.pushResult({\n            result: false,\n            message: \'The promise returned by the `assert.rejects` callback in \' + \'"\' + currentTest.testName + \'" did not reject.\',\n            actual: promise\n          });\n          done();\n        }, function handleRejection(actual) {\n          var result;\n          var _validateException3 = validateException(actual, expected, message);\n          var _validateException4 = _slicedToArray(_validateException3, 3);\n          result = _validateException4[0];\n          expected = _validateException4[1];\n          message = _validateException4[2];\n          currentTest.assert.pushResult({\n            result: result,\n            // leave rejection value of undefined as-is\n            actual: actual && errorString(actual),\n            expected: expected,\n            message: message\n          });\n          done();\n        });\n      }\n    }]);\n    return Assert;\n  }();\n  function validateExpectedExceptionArgs(expected, message, assertionMethod) {\n    var expectedType = objectType(expected);\n\n    // \'expected\' is optional unless doing string comparison\n    if (expectedType === \'string\') {\n      if (message === undefined) {\n        message = expected;\n        expected = undefined;\n        return [expected, message];\n      } else {\n        throw new Error(\'assert.\' + assertionMethod + \' does not accept a string value for the expected argument.\\n\' + \'Use a non-string object value (e.g. RegExp or validator function) \' + \'instead if necessary.\');\n      }\n    }\n    var valid = !expected ||\n    // TODO: be more explicit here\n    expectedType === \'regexp\' || expectedType === \'function\' || expectedType === \'object\';\n    if (!valid) {\n      throw new Error(\'Invalid expected value type (\' + expectedType + \') \' + \'provided to assert.\' + assertionMethod + \'.\');\n    }\n    return [expected, message];\n  }\n  function validateException(actual, expected, message) {\n    var result = false;\n    var expectedType = objectType(expected);\n\n    // These branches should be exhaustive, based on validation done in validateExpectedException\n\n    // We don\'t want to validate\n    if (!expected) {\n      result = true;\n\n      // Expected is a regexp\n    } else if (expectedType === \'regexp\') {\n      result = expected.test(errorString(actual));\n\n      // Log the string form of the regexp\n      expected = String(expected);\n\n      // Expected is a constructor, maybe an Error constructor.\n      // Note the extra check on its prototype - this is an implicit\n      // requirement of "instanceof", else it will throw a TypeError.\n    } else if (expectedType === \'function\' && expected.prototype !== undefined && actual instanceof expected) {\n      result = true;\n\n      // Expected is an Error object\n    } else if (expectedType === \'object\') {\n      result = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;\n\n      // Log the string form of the Error object\n      expected = errorString(expected);\n\n      // Expected is a validation function which returns true if validation passed\n    } else if (expectedType === \'function\') {\n      // protect against accidental semantics which could hard error in the test\n      try {\n        result = expected.call({}, actual) === true;\n        expected = null;\n      } catch (e) {\n        // assign the "expected" to a nice error string to communicate the local failure to the user\n        expected = errorString(e);\n      }\n    }\n    return [result, expected, message];\n  }\n\n  // Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n  // Known to us are: Closure Compiler, Narwhal\n  // eslint-disable-next-line dot-notation\n  Assert.prototype.raises = Assert.prototype[\'throws\'];\n\n  var LISTENERS = Object.create(null);\n  var SUPPORTED_EVENTS = [\'error\', \'runStart\', \'suiteStart\', \'testStart\', \'assertion\', \'testEnd\', \'suiteEnd\', \'runEnd\'];\n\n  /**\n   * Emits an event with the specified data to all currently registered listeners.\n   * Callbacks will fire in the order in which they are registered (FIFO). This\n   * function is not exposed publicly; it is used by QUnit internals to emit\n   * logging events.\n   *\n   * @private\n   * @method emit\n   * @param {string} eventName\n   * @param {Object} data\n   * @return {void}\n   */\n  function emit(eventName, data) {\n    if (typeof eventName !== \'string\') {\n      throw new TypeError(\'eventName must be a string when emitting an event\');\n    }\n\n    // Clone the callbacks in case one of them registers a new callback\n    var originalCallbacks = LISTENERS[eventName];\n    var callbacks = originalCallbacks ? _toConsumableArray(originalCallbacks) : [];\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](data);\n    }\n  }\n\n  /**\n   * Registers a callback as a listener to the specified event.\n   *\n   * @public\n   * @method on\n   * @param {string} eventName\n   * @param {Function} callback\n   * @return {void}\n   */\n  function on(eventName, callback) {\n    if (typeof eventName !== \'string\') {\n      throw new TypeError(\'eventName must be a string when registering a listener\');\n    } else if (!inArray(eventName, SUPPORTED_EVENTS)) {\n      var events = SUPPORTED_EVENTS.join(\', \');\n      throw new Error("\\"".concat(eventName, "\\" is not a valid event; must be one of: ").concat(events, "."));\n    } else if (typeof callback !== \'function\') {\n      throw new TypeError(\'callback must be a function when registering a listener\');\n    }\n    if (!LISTENERS[eventName]) {\n      LISTENERS[eventName] = [];\n    }\n\n    // Don\'t register the same callback more than once\n    if (!inArray(callback, LISTENERS[eventName])) {\n      LISTENERS[eventName].push(callback);\n    }\n  }\n\n  var commonjsGlobal = typeof globalThis !== \'undefined\' ? globalThis : typeof window !== \'undefined\' ? window : typeof global !== \'undefined\' ? global : typeof self !== \'undefined\' ? self : {};\n\n  function commonjsRequire (path) {\n  \tthrow new Error(\'Could not dynamically require "\' + path + \'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.\');\n  }\n\n  var promisePolyfill = {exports: {}};\n\n  (function () {\n\n    /** @suppress {undefinedVars} */\n    var globalNS = function () {\n      // the only reliable means to get the global object is\n      // `Function(\'return this\')()`\n      // However, this causes CSP violations in Chrome apps.\n      if (typeof globalThis !== \'undefined\') {\n        return globalThis;\n      }\n      if (typeof self !== \'undefined\') {\n        return self;\n      }\n      if (typeof window !== \'undefined\') {\n        return window;\n      }\n      if (typeof commonjsGlobal !== \'undefined\') {\n        return commonjsGlobal;\n      }\n      throw new Error(\'unable to locate global object\');\n    }();\n\n    // Expose the polyfill if Promise is undefined or set to a\n    // non-function value. The latter can be due to a named HTMLElement\n    // being exposed by browsers for legacy reasons.\n    // https://github.com/taylorhakes/promise-polyfill/issues/114\n    if (typeof globalNS[\'Promise\'] === \'function\') {\n      promisePolyfill.exports = globalNS[\'Promise\'];\n      return;\n    }\n\n    /**\n     * @this {Promise}\n     */\n    function finallyConstructor(callback) {\n      var constructor = this.constructor;\n      return this.then(function (value) {\n        // @ts-ignore\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        // @ts-ignore\n        return constructor.resolve(callback()).then(function () {\n          // @ts-ignore\n          return constructor.reject(reason);\n        });\n      });\n    }\n    function allSettled(arr) {\n      var P = this;\n      return new P(function (resolve, reject) {\n        if (!(arr && typeof arr.length !== \'undefined\')) {\n          return reject(new TypeError(_typeof(arr) + \' \' + arr + \' is not iterable(cannot read property Symbol(Symbol.iterator))\'));\n        }\n        var args = Array.prototype.slice.call(arr);\n        if (args.length === 0) return resolve([]);\n        var remaining = args.length;\n        function res(i, val) {\n          if (val && (_typeof(val) === \'object\' || typeof val === \'function\')) {\n            var then = val.then;\n            if (typeof then === \'function\') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, function (e) {\n                args[i] = {\n                  status: \'rejected\',\n                  reason: e\n                };\n                if (--remaining === 0) {\n                  resolve(args);\n                }\n              });\n              return;\n            }\n          }\n          args[i] = {\n            status: \'fulfilled\',\n            value: val\n          };\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        }\n        for (var i = 0; i < args.length; i++) {\n          res(i, args[i]);\n        }\n      });\n    }\n\n    // Store setTimeout reference so promise-polyfill will be unaffected by\n    // other code modifying setTimeout (like sinon.useFakeTimers())\n    var setTimeoutFunc = setTimeout;\n    function isArray(x) {\n      return Boolean(x && typeof x.length !== \'undefined\');\n    }\n    function noop() {}\n\n    // Polyfill for Function.prototype.bind\n    function bind(fn, thisArg) {\n      return function () {\n        fn.apply(thisArg, arguments);\n      };\n    }\n\n    /**\n     * @constructor\n     * @param {Function} fn\n     */\n    function Promise(fn) {\n      if (!(this instanceof Promise)) throw new TypeError(\'Promises must be constructed via new\');\n      if (typeof fn !== \'function\') throw new TypeError(\'not a function\');\n      /** @type {!number} */\n      this._state = 0;\n      /** @type {!boolean} */\n      this._handled = false;\n      /** @type {Promise|undefined} */\n      this._value = undefined;\n      /** @type {!Array<!Function>} */\n      this._deferreds = [];\n      doResolve(fn, this);\n    }\n    function handle(self, deferred) {\n      while (self._state === 3) {\n        self = self._value;\n      }\n      if (self._state === 0) {\n        self._deferreds.push(deferred);\n        return;\n      }\n      self._handled = true;\n      Promise._immediateFn(function () {\n        var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n        if (cb === null) {\n          (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n          return;\n        }\n        var ret;\n        try {\n          ret = cb(self._value);\n        } catch (e) {\n          reject(deferred.promise, e);\n          return;\n        }\n        resolve(deferred.promise, ret);\n      });\n    }\n    function resolve(self, newValue) {\n      try {\n        // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n        if (newValue === self) throw new TypeError(\'A promise cannot be resolved with itself.\');\n        if (newValue && (_typeof(newValue) === \'object\' || typeof newValue === \'function\')) {\n          var then = newValue.then;\n          if (newValue instanceof Promise) {\n            self._state = 3;\n            self._value = newValue;\n            finale(self);\n            return;\n          } else if (typeof then === \'function\') {\n            doResolve(bind(then, newValue), self);\n            return;\n          }\n        }\n        self._state = 1;\n        self._value = newValue;\n        finale(self);\n      } catch (e) {\n        reject(self, e);\n      }\n    }\n    function reject(self, newValue) {\n      self._state = 2;\n      self._value = newValue;\n      finale(self);\n    }\n    function finale(self) {\n      if (self._state === 2 && self._deferreds.length === 0) {\n        Promise._immediateFn(function () {\n          if (!self._handled) {\n            Promise._unhandledRejectionFn(self._value);\n          }\n        });\n      }\n      for (var i = 0, len = self._deferreds.length; i < len; i++) {\n        handle(self, self._deferreds[i]);\n      }\n      self._deferreds = null;\n    }\n\n    /**\n     * @constructor\n     */\n    function Handler(onFulfilled, onRejected, promise) {\n      this.onFulfilled = typeof onFulfilled === \'function\' ? onFulfilled : null;\n      this.onRejected = typeof onRejected === \'function\' ? onRejected : null;\n      this.promise = promise;\n    }\n\n    /**\n     * Take a potentially misbehaving resolver function and make sure\n     * onFulfilled and onRejected are only called once.\n     *\n     * Makes no guarantees about asynchrony.\n     */\n    function doResolve(fn, self) {\n      var done = false;\n      try {\n        fn(function (value) {\n          if (done) return;\n          done = true;\n          resolve(self, value);\n        }, function (reason) {\n          if (done) return;\n          done = true;\n          reject(self, reason);\n        });\n      } catch (ex) {\n        if (done) return;\n        done = true;\n        reject(self, ex);\n      }\n    }\n    Promise.prototype[\'catch\'] = function (onRejected) {\n      return this.then(null, onRejected);\n    };\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n      // @ts-ignore\n      var prom = new this.constructor(noop);\n      handle(this, new Handler(onFulfilled, onRejected, prom));\n      return prom;\n    };\n    Promise.prototype[\'finally\'] = finallyConstructor;\n    Promise.all = function (arr) {\n      return new Promise(function (resolve, reject) {\n        if (!isArray(arr)) {\n          return reject(new TypeError(\'Promise.all accepts an array\'));\n        }\n        var args = Array.prototype.slice.call(arr);\n        if (args.length === 0) return resolve([]);\n        var remaining = args.length;\n        function res(i, val) {\n          try {\n            if (val && (_typeof(val) === \'object\' || typeof val === \'function\')) {\n              var then = val.then;\n              if (typeof then === \'function\') {\n                then.call(val, function (val) {\n                  res(i, val);\n                }, reject);\n                return;\n              }\n            }\n            args[i] = val;\n            if (--remaining === 0) {\n              resolve(args);\n            }\n          } catch (ex) {\n            reject(ex);\n          }\n        }\n        for (var i = 0; i < args.length; i++) {\n          res(i, args[i]);\n        }\n      });\n    };\n    Promise.allSettled = allSettled;\n    Promise.resolve = function (value) {\n      if (value && _typeof(value) === \'object\' && value.constructor === Promise) {\n        return value;\n      }\n      return new Promise(function (resolve) {\n        resolve(value);\n      });\n    };\n    Promise.reject = function (value) {\n      return new Promise(function (resolve, reject) {\n        reject(value);\n      });\n    };\n    Promise.race = function (arr) {\n      return new Promise(function (resolve, reject) {\n        if (!isArray(arr)) {\n          return reject(new TypeError(\'Promise.race accepts an array\'));\n        }\n        for (var i = 0, len = arr.length; i < len; i++) {\n          Promise.resolve(arr[i]).then(resolve, reject);\n        }\n      });\n    };\n\n    // Use polyfill for setImmediate for performance gains\n    Promise._immediateFn =\n    // @ts-ignore\n    typeof setImmediate === \'function\' && function (fn) {\n      // @ts-ignore\n      setImmediate(fn);\n    } || function (fn) {\n      setTimeoutFunc(fn, 0);\n    };\n    Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n      if (typeof console !== \'undefined\' && console) {\n        console.warn(\'Possible Unhandled Promise Rejection:\', err); // eslint-disable-line no-console\n      }\n    };\n\n    promisePolyfill.exports = Promise;\n  })();\n  var _Promise = promisePolyfill.exports;\n\n  // Register logging callbacks\n  function registerLoggingCallbacks(obj) {\n    var callbackNames = [\'begin\', \'done\', \'log\', \'testStart\', \'testDone\', \'moduleStart\', \'moduleDone\'];\n    function registerLoggingCallback(key) {\n      return function loggingCallback(callback) {\n        if (typeof callback !== \'function\') {\n          throw new Error(\'Callback parameter must be a function\');\n        }\n        config.callbacks[key].push(callback);\n      };\n    }\n    for (var i = 0; i < callbackNames.length; i++) {\n      var key = callbackNames[i];\n\n      // Initialize key collection of logging callback\n      if (typeof config.callbacks[key] === \'undefined\') {\n        config.callbacks[key] = [];\n      }\n      obj[key] = registerLoggingCallback(key);\n    }\n  }\n  function runLoggingCallbacks(key, args) {\n    var callbacks = config.callbacks[key];\n\n    // Handling \'log\' callbacks separately. Unlike the other callbacks,\n    // the log callback is not controlled by the processing queue,\n    // but rather used by asserts. Hence to promisfy the \'log\' callback\n    // would mean promisfying each step of a test\n    if (key === \'log\') {\n      callbacks.map(function (callback) {\n        return callback(args);\n      });\n      return;\n    }\n\n    // ensure that each callback is executed serially\n    var promiseChain = _Promise.resolve();\n    callbacks.forEach(function (callback) {\n      promiseChain = promiseChain.then(function () {\n        return _Promise.resolve(callback(args));\n      });\n    });\n    return promiseChain;\n  }\n\n  var priorityCount = 0;\n  var unitSampler;\n\n  // This is a queue of functions that are tasks within a single test.\n  // After tests are dequeued from config.queue they are expanded into\n  // a set of tasks in this queue.\n  var taskQueue = [];\n\n  /**\n   * Advances the taskQueue to the next task. If the taskQueue is empty,\n   * process the testQueue\n   */\n  function advance() {\n    advanceTaskQueue();\n    if (!taskQueue.length && !config.blocking && !config.current) {\n      advanceTestQueue();\n    }\n  }\n\n  /**\n   * Advances the taskQueue with an increased depth\n   */\n  function advanceTaskQueue() {\n    var start = performance.now();\n    config.depth = (config.depth || 0) + 1;\n    processTaskQueue(start);\n    config.depth--;\n  }\n\n  /**\n   * Process the first task on the taskQueue as a promise.\n   * Each task is a function added by Test#queue() in /src/test.js\n   */\n  function processTaskQueue(start) {\n    if (taskQueue.length && !config.blocking) {\n      var elapsedTime = performance.now() - start;\n\n      // The updateRate ensures that a user interface (HTML Reporter) can be updated\n      // at least once every second. This can also prevent browsers from prompting\n      // a warning about long running scripts.\n      if (!setTimeout$1 || config.updateRate <= 0 || elapsedTime < config.updateRate) {\n        var task = taskQueue.shift();\n        _Promise.resolve(task()).then(function () {\n          if (!taskQueue.length) {\n            advance();\n          } else {\n            processTaskQueue(start);\n          }\n        });\n      } else {\n        setTimeout$1(advance);\n      }\n    }\n  }\n\n  /**\n   * Advance the testQueue to the next test to process. Call done() if testQueue completes.\n   */\n  function advanceTestQueue() {\n    if (!config.blocking && !config.queue.length && config.depth === 0) {\n      done();\n      return;\n    }\n    var testTasks = config.queue.shift();\n    addToTaskQueue(testTasks());\n    if (priorityCount > 0) {\n      priorityCount--;\n    }\n    advance();\n  }\n\n  /**\n   * Enqueue the tasks for a test into the task queue.\n   * @param {Array} tasksArray\n   */\n  function addToTaskQueue(tasksArray) {\n    taskQueue.push.apply(taskQueue, _toConsumableArray(tasksArray));\n  }\n\n  /**\n   * Return the number of tasks remaining in the task queue to be processed.\n   * @return {number}\n   */\n  function taskQueueLength() {\n    return taskQueue.length;\n  }\n\n  /**\n   * Adds a test to the TestQueue for execution.\n   * @param {Function} testTasksFunc\n   * @param {boolean} prioritize\n   * @param {string} seed\n   */\n  function addToTestQueue(testTasksFunc, prioritize, seed) {\n    if (prioritize) {\n      config.queue.splice(priorityCount++, 0, testTasksFunc);\n    } else if (seed) {\n      if (!unitSampler) {\n        unitSampler = unitSamplerGenerator(seed);\n      }\n\n      // Insert into a random position after all prioritized items\n      var index = Math.floor(unitSampler() * (config.queue.length - priorityCount + 1));\n      config.queue.splice(priorityCount + index, 0, testTasksFunc);\n    } else {\n      config.queue.push(testTasksFunc);\n    }\n  }\n\n  /**\n   * Creates a seeded "sample" generator which is used for randomizing tests.\n   */\n  function unitSamplerGenerator(seed) {\n    // 32-bit xorshift, requires only a nonzero seed\n    // https://excamera.com/sphinx/article-xorshift.html\n    var sample = parseInt(generateHash(seed), 16) || -1;\n    return function () {\n      sample ^= sample << 13;\n      sample ^= sample >>> 17;\n      sample ^= sample << 5;\n\n      // ECMAScript has no unsigned number type\n      if (sample < 0) {\n        sample += 0x100000000;\n      }\n      return sample / 0x100000000;\n    };\n  }\n\n  /**\n   * This function is called when the ProcessingQueue is done processing all\n   * items. It handles emitting the final run events.\n   */\n  function done() {\n    // We have reached the end of the processing queue and are about to emit the\n    // "runEnd" event after which reporters typically stop listening and exit\n    // the process. First, check if we need to emit one final test.\n    if (config.stats.testCount === 0 && config.failOnZeroTests === true) {\n      var error;\n      if (config.filter && config.filter.length) {\n        error = new Error("No tests matched the filter \\"".concat(config.filter, "\\"."));\n      } else if (config.module && config.module.length) {\n        error = new Error("No tests matched the module \\"".concat(config.module, "\\"."));\n      } else if (config.moduleId && config.moduleId.length) {\n        error = new Error("No tests matched the moduleId \\"".concat(config.moduleId, "\\"."));\n      } else if (config.testId && config.testId.length) {\n        error = new Error("No tests matched the testId \\"".concat(config.testId, "\\"."));\n      } else {\n        error = new Error(\'No tests were run.\');\n      }\n      test(\'global failure\', extend(function (assert) {\n        assert.pushResult({\n          result: false,\n          message: error.message,\n          source: error.stack\n        });\n      }, {\n        validTest: true\n      }));\n\n      // We do need to call `advance()` in order to resume the processing queue.\n      // Once this new test is finished processing, we\'ll reach `done` again, and\n      // that time the above condition will evaluate to false.\n      advance();\n      return;\n    }\n    var storage = config.storage;\n    var runtime = Math.round(performance.now() - config.started);\n    var passed = config.stats.all - config.stats.bad;\n    ProcessingQueue.finished = true;\n    emit(\'runEnd\', runSuite.end(true));\n    runLoggingCallbacks(\'done\', {\n      // @deprecated since 2.19.0 Use done() without `details` parameter,\n      // or use `QUnit.on(\'runEnd\')` instead. Parameter to be replaced in\n      // QUnit 3.0 with test counts.\n      passed: passed,\n      failed: config.stats.bad,\n      total: config.stats.all,\n      runtime: runtime\n    }).then(function () {\n      // Clear own storage items if all tests passed\n      if (storage && config.stats.bad === 0) {\n        for (var i = storage.length - 1; i >= 0; i--) {\n          var key = storage.key(i);\n          if (key.indexOf(\'qunit-test-\') === 0) {\n            storage.removeItem(key);\n          }\n        }\n      }\n    });\n  }\n  var ProcessingQueue = {\n    finished: false,\n    add: addToTestQueue,\n    advance: advance,\n    taskCount: taskQueueLength\n  };\n\n  var TestReport = /*#__PURE__*/function () {\n    function TestReport(name, suite, options) {\n      _classCallCheck(this, TestReport);\n      this.name = name;\n      this.suiteName = suite.name;\n      this.fullName = suite.fullName.concat(name);\n      this.runtime = 0;\n      this.assertions = [];\n      this.skipped = !!options.skip;\n      this.todo = !!options.todo;\n      this.valid = options.valid;\n      this._startTime = 0;\n      this._endTime = 0;\n      suite.pushTest(this);\n    }\n    _createClass(TestReport, [{\n      key: "start",\n      value: function start(recordTime) {\n        if (recordTime) {\n          this._startTime = performance.now();\n          performance.mark(\'qunit_test_start\');\n        }\n        return {\n          name: this.name,\n          suiteName: this.suiteName,\n          fullName: this.fullName.slice()\n        };\n      }\n    }, {\n      key: "end",\n      value: function end(recordTime) {\n        if (recordTime) {\n          this._endTime = performance.now();\n          if (performance) {\n            performance.mark(\'qunit_test_end\');\n            var testName = this.fullName.join(\' \u2013 \');\n            performance.measure("QUnit Test: ".concat(testName), \'qunit_test_start\', \'qunit_test_end\');\n          }\n        }\n        return extend(this.start(), {\n          runtime: this.getRuntime(),\n          status: this.getStatus(),\n          errors: this.getFailedAssertions(),\n          assertions: this.getAssertions()\n        });\n      }\n    }, {\n      key: "pushAssertion",\n      value: function pushAssertion(assertion) {\n        this.assertions.push(assertion);\n      }\n    }, {\n      key: "getRuntime",\n      value: function getRuntime() {\n        return Math.round(this._endTime - this._startTime);\n      }\n    }, {\n      key: "getStatus",\n      value: function getStatus() {\n        if (this.skipped) {\n          return \'skipped\';\n        }\n        var testPassed = this.getFailedAssertions().length > 0 ? this.todo : !this.todo;\n        if (!testPassed) {\n          return \'failed\';\n        } else if (this.todo) {\n          return \'todo\';\n        } else {\n          return \'passed\';\n        }\n      }\n    }, {\n      key: "getFailedAssertions",\n      value: function getFailedAssertions() {\n        return this.assertions.filter(function (assertion) {\n          return !assertion.passed;\n        });\n      }\n    }, {\n      key: "getAssertions",\n      value: function getAssertions() {\n        return this.assertions.slice();\n      }\n\n      // Remove actual and expected values from assertions. This is to prevent\n      // leaking memory throughout a test suite.\n    }, {\n      key: "slimAssertions",\n      value: function slimAssertions() {\n        this.assertions = this.assertions.map(function (assertion) {\n          delete assertion.actual;\n          delete assertion.expected;\n          return assertion;\n        });\n      }\n    }]);\n    return TestReport;\n  }();\n\n  function Test(settings) {\n    this.expected = null;\n    this.assertions = [];\n    this.module = config.currentModule;\n    this.steps = [];\n    this.timeout = undefined;\n    this.data = undefined;\n    this.withData = false;\n    this.pauses = new StringMap();\n    this.nextPauseId = 1;\n\n    // For the most common case, we have:\n    // - 0: new Test\n    // - 1: addTest\n    // - 2: QUnit.test\n    // - 3: user file\n    //\n    // This needs is customised by test.each()\n    this.stackOffset = 3;\n    extend(this, settings);\n\n    // If a module is skipped, all its tests and the tests of the child suites\n    // should be treated as skipped even if they are defined as `only` or `todo`.\n    // As for `todo` module, all its tests will be treated as `todo` except for\n    // tests defined as `skip` which will be left intact.\n    //\n    // So, if a test is defined as `todo` and is inside a skipped module, we should\n    // then treat that test as if was defined as `skip`.\n    if (this.module.skip) {\n      this.skip = true;\n      this.todo = false;\n\n      // Skipped tests should be left intact\n    } else if (this.module.todo && !this.skip) {\n      this.todo = true;\n    }\n\n    // Queuing a late test after the run has ended is not allowed.\n    // This was once supported for internal use by QUnit.onError().\n    // Ref https://github.com/qunitjs/qunit/issues/1377\n    if (ProcessingQueue.finished) {\n      // Using this for anything other than onError(), such as testing in QUnit.done(),\n      // is unstable and will likely result in the added tests being ignored by CI.\n      // (Meaning the CI passes irregardless of the added tests).\n      //\n      // TODO: Make this an error in QUnit 3.0\n      // throw new Error( "Unexpected test after runEnd" );\n      Logger.warn(\'Unexpected test after runEnd. This is unstable and will fail in QUnit 3.0.\');\n      return;\n    }\n    if (!this.skip && typeof this.callback !== \'function\') {\n      var method = this.todo ? \'QUnit.todo\' : \'QUnit.test\';\n      throw new TypeError("You must provide a callback to ".concat(method, "(\\"").concat(this.testName, "\\")"));\n    }\n\n    // Register unique strings\n    for (var i = 0, l = this.module.tests; i < l.length; i++) {\n      if (this.module.tests[i].name === this.testName) {\n        this.testName += \' \';\n      }\n    }\n    this.testId = generateHash(this.module.name, this.testName);\n\n    // No validation after this. Beyond this point, failures must be recorded as\n    // a completed test with errors, instead of early bail out.\n    // Otherwise, internals may be left in an inconsistent state.\n    // Ref https://github.com/qunitjs/qunit/issues/1514\n\n    ++Test.count;\n    this.errorForStack = new Error();\n    if (this.callback && this.callback.validTest) {\n      // Omit the test-level trace for the internal "No tests" test failure,\n      // There is already an assertion-level trace, and that\'s noisy enough\n      // as it is.\n      this.errorForStack.stack = undefined;\n    }\n    this.testReport = new TestReport(this.testName, this.module.suiteReport, {\n      todo: this.todo,\n      skip: this.skip,\n      valid: this.valid()\n    });\n    this.module.tests.push({\n      name: this.testName,\n      testId: this.testId,\n      skip: !!this.skip\n    });\n    if (this.skip) {\n      // Skipped tests will fully ignore any sent callback\n      this.callback = function () {};\n      this.async = false;\n      this.expected = 0;\n    } else {\n      this.assert = new Assert(this);\n    }\n  }\n  Test.count = 0;\n  function getNotStartedModules(startModule) {\n    var module = startModule;\n    var modules = [];\n    while (module && module.testsRun === 0) {\n      modules.push(module);\n      module = module.parentModule;\n    }\n\n    // The above push modules from the child to the parent\n    // return a reversed order with the top being the top most parent module\n    return modules.reverse();\n  }\n  Test.prototype = {\n    // Use a getter to avoid computing a stack trace (which can be expensive),\n    // This is displayed by the HTML Reporter, but most other integrations do\n    // not access it.\n    get stack() {\n      return extractStacktrace(this.errorForStack, this.stackOffset);\n    },\n    before: function before() {\n      var _this = this;\n      var module = this.module;\n      var notStartedModules = getNotStartedModules(module);\n\n      // ensure the callbacks are executed serially for each module\n      var moduleStartChain = _Promise.resolve();\n      notStartedModules.forEach(function (startModule) {\n        moduleStartChain = moduleStartChain.then(function () {\n          startModule.stats = {\n            all: 0,\n            bad: 0,\n            started: performance.now()\n          };\n          emit(\'suiteStart\', startModule.suiteReport.start(true));\n          return runLoggingCallbacks(\'moduleStart\', {\n            name: startModule.name,\n            tests: startModule.tests\n          });\n        });\n      });\n      return moduleStartChain.then(function () {\n        config.current = _this;\n        _this.testEnvironment = extend({}, module.testEnvironment);\n        _this.started = performance.now();\n        emit(\'testStart\', _this.testReport.start(true));\n        return runLoggingCallbacks(\'testStart\', {\n          name: _this.testName,\n          module: module.name,\n          testId: _this.testId,\n          previousFailure: _this.previousFailure\n        }).then(function () {\n          if (!config.pollution) {\n            saveGlobal();\n          }\n        });\n      });\n    },\n    run: function run() {\n      config.current = this;\n      if (config.notrycatch) {\n        runTest(this);\n        return;\n      }\n      try {\n        runTest(this);\n      } catch (e) {\n        this.pushFailure(\'Died on test #\' + (this.assertions.length + 1) + \': \' + (e.message || e) + \'\\n\' + this.stack, extractStacktrace(e, 0));\n\n        // Else next test will carry the responsibility\n        saveGlobal();\n\n        // Restart the tests if they\'re blocking\n        if (config.blocking) {\n          internalRecover(this);\n        }\n      }\n      function runTest(test) {\n        var promise;\n        if (test.withData) {\n          promise = test.callback.call(test.testEnvironment, test.assert, test.data);\n        } else {\n          promise = test.callback.call(test.testEnvironment, test.assert);\n        }\n        test.resolvePromise(promise);\n\n        // If the test has an async "pause" on it, but the timeout is 0, then we push a\n        // failure as the test should be synchronous.\n        if (test.timeout === 0 && test.pauses.size > 0) {\n          pushFailure(\'Test did not finish synchronously even though assert.timeout( 0 ) was used.\', sourceFromStacktrace(2));\n        }\n      }\n    },\n    after: function after() {\n      checkPollution();\n    },\n    queueGlobalHook: function queueGlobalHook(hook, hookName) {\n      var _this2 = this;\n      var runHook = function runHook() {\n        config.current = _this2;\n        var promise;\n        if (config.notrycatch) {\n          promise = hook.call(_this2.testEnvironment, _this2.assert);\n        } else {\n          try {\n            promise = hook.call(_this2.testEnvironment, _this2.assert);\n          } catch (error) {\n            _this2.pushFailure(\'Global \' + hookName + \' failed on \' + _this2.testName + \': \' + errorString(error), extractStacktrace(error, 0));\n            return;\n          }\n        }\n        _this2.resolvePromise(promise, hookName);\n      };\n      return runHook;\n    },\n    queueHook: function queueHook(hook, hookName, hookOwner) {\n      var _this3 = this;\n      var callHook = function callHook() {\n        var promise = hook.call(_this3.testEnvironment, _this3.assert);\n        _this3.resolvePromise(promise, hookName);\n      };\n      var runHook = function runHook() {\n        if (hookName === \'before\') {\n          if (hookOwner.testsRun !== 0) {\n            return;\n          }\n          _this3.preserveEnvironment = true;\n        }\n\n        // The \'after\' hook should only execute when there are not tests left and\n        // when the \'after\' and \'finish\' tasks are the only tasks left to process\n        if (hookName === \'after\' && !lastTestWithinModuleExecuted(hookOwner) && (config.queue.length > 0 || ProcessingQueue.taskCount() > 2)) {\n          return;\n        }\n        config.current = _this3;\n        if (config.notrycatch) {\n          callHook();\n          return;\n        }\n        try {\n          // This try-block includes the indirect call to resolvePromise, which shouldn\'t\n          // have to be inside try-catch. But, since we support any user-provided thenable\n          // object, the thenable might throw in some unexpected way.\n          // This subtle behaviour is undocumented. To avoid new failures in minor releases\n          // we will not change this until QUnit 3.\n          // TODO: In QUnit 3, reduce this try-block to just hook.call(), matching\n          // the simplicity of queueGlobalHook.\n          callHook();\n        } catch (error) {\n          _this3.pushFailure(hookName + \' failed on \' + _this3.testName + \': \' + (error.message || error), extractStacktrace(error, 0));\n        }\n      };\n      return runHook;\n    },\n    // Currently only used for module level hooks, can be used to add global level ones\n    hooks: function hooks(handler) {\n      var hooks = [];\n      function processGlobalhooks(test) {\n        if ((handler === \'beforeEach\' || handler === \'afterEach\') && config.globalHooks[handler]) {\n          for (var i = 0; i < config.globalHooks[handler].length; i++) {\n            hooks.push(test.queueGlobalHook(config.globalHooks[handler][i], handler));\n          }\n        }\n      }\n      function processHooks(test, module) {\n        if (module.parentModule) {\n          processHooks(test, module.parentModule);\n        }\n        if (module.hooks[handler].length) {\n          for (var i = 0; i < module.hooks[handler].length; i++) {\n            hooks.push(test.queueHook(module.hooks[handler][i], handler, module));\n          }\n        }\n      }\n\n      // Hooks are ignored on skipped tests\n      if (!this.skip) {\n        processGlobalhooks(this);\n        processHooks(this, this.module);\n      }\n      return hooks;\n    },\n    finish: function finish() {\n      config.current = this;\n\n      // Release the timeout and timeout callback references to be garbage collected.\n      // https://github.com/qunitjs/qunit/pull/1708\n      if (setTimeout$1) {\n        clearTimeout(this.timeout);\n        config.timeoutHandler = null;\n      }\n\n      // Release the test callback to ensure that anything referenced has been\n      // released to be garbage collected.\n      this.callback = undefined;\n      if (this.steps.length) {\n        var stepsList = this.steps.join(\', \');\n        this.pushFailure(\'Expected assert.verifySteps() to be called before end of test \' + "after using assert.step(). Unverified steps: ".concat(stepsList), this.stack);\n      }\n      if (config.requireExpects && this.expected === null) {\n        this.pushFailure(\'Expected number of assertions to be defined, but expect() was \' + \'not called.\', this.stack);\n      } else if (this.expected !== null && this.expected !== this.assertions.length) {\n        this.pushFailure(\'Expected \' + this.expected + \' assertions, but \' + this.assertions.length + \' were run\', this.stack);\n      } else if (this.expected === null && !this.assertions.length) {\n        this.pushFailure(\'Expected at least one assertion, but none were run - call \' + \'expect(0) to accept zero assertions.\', this.stack);\n      }\n      var module = this.module;\n      var moduleName = module.name;\n      var testName = this.testName;\n      var skipped = !!this.skip;\n      var todo = !!this.todo;\n      var bad = 0;\n      var storage = config.storage;\n      this.runtime = Math.round(performance.now() - this.started);\n      config.stats.all += this.assertions.length;\n      config.stats.testCount += 1;\n      module.stats.all += this.assertions.length;\n      for (var i = 0; i < this.assertions.length; i++) {\n        // A failing assertion will counts toward the HTML Reporter\'s\n        // "X assertions, Y failed" line even if it was inside a todo.\n        // Inverting this would be similarly confusing since all but the last\n        // passing assertion inside a todo test should be considered as good.\n        // These stats don\'t decide the outcome of anything, so counting them\n        // as failing seems the most intuitive.\n        if (!this.assertions[i].result) {\n          bad++;\n          config.stats.bad++;\n          module.stats.bad++;\n        }\n      }\n      if (skipped) {\n        incrementTestsIgnored(module);\n      } else {\n        incrementTestsRun(module);\n      }\n\n      // Store result when possible.\n      // Note that this also marks todo tests as bad, thus they get hoisted,\n      // and always run first on refresh.\n      if (storage) {\n        if (bad) {\n          storage.setItem(\'qunit-test-\' + moduleName + \'-\' + testName, bad);\n        } else {\n          storage.removeItem(\'qunit-test-\' + moduleName + \'-\' + testName);\n        }\n      }\n\n      // After emitting the js-reporters event we cleanup the assertion data to\n      // avoid leaking it. It is not used by the legacy testDone callbacks.\n      emit(\'testEnd\', this.testReport.end(true));\n      this.testReport.slimAssertions();\n      var test = this;\n      return runLoggingCallbacks(\'testDone\', {\n        name: testName,\n        module: moduleName,\n        skipped: skipped,\n        todo: todo,\n        failed: bad,\n        passed: this.assertions.length - bad,\n        total: this.assertions.length,\n        runtime: skipped ? 0 : this.runtime,\n        // HTML Reporter use\n        assertions: this.assertions,\n        testId: this.testId,\n        // Source of Test\n        // generating stack trace is expensive, so using a getter will help defer this until we need it\n        get source() {\n          return test.stack;\n        }\n      }).then(function () {\n        if (allTestsExecuted(module)) {\n          var completedModules = [module];\n\n          // Check if the parent modules, iteratively, are done. If that the case,\n          // we emit the `suiteEnd` event and trigger `moduleDone` callback.\n          var parent = module.parentModule;\n          while (parent && allTestsExecuted(parent)) {\n            completedModules.push(parent);\n            parent = parent.parentModule;\n          }\n          var moduleDoneChain = _Promise.resolve();\n          completedModules.forEach(function (completedModule) {\n            moduleDoneChain = moduleDoneChain.then(function () {\n              return logSuiteEnd(completedModule);\n            });\n          });\n          return moduleDoneChain;\n        }\n      }).then(function () {\n        config.current = undefined;\n      });\n      function logSuiteEnd(module) {\n        // Reset `module.hooks` to ensure that anything referenced in these hooks\n        // has been released to be garbage collected. Descendant modules that were\n        // entirely skipped, e.g. due to filtering, will never have this method\n        // called for them, but might have hooks with references pinning data in\n        // memory (even if the hooks weren\'t actually executed), so we reset the\n        // hooks on all descendant modules here as well. This is safe because we\n        // will never call this as long as any descendant modules still have tests\n        // to run. This also means that in multi-tiered nesting scenarios we might\n        // reset the hooks multiple times on some modules, but that\'s harmless.\n        var modules = [module];\n        while (modules.length) {\n          var nextModule = modules.shift();\n          nextModule.hooks = {};\n          modules.push.apply(modules, _toConsumableArray(nextModule.childModules));\n        }\n        emit(\'suiteEnd\', module.suiteReport.end(true));\n        return runLoggingCallbacks(\'moduleDone\', {\n          name: module.name,\n          tests: module.tests,\n          failed: module.stats.bad,\n          passed: module.stats.all - module.stats.bad,\n          total: module.stats.all,\n          runtime: Math.round(performance.now() - module.stats.started)\n        });\n      }\n    },\n    preserveTestEnvironment: function preserveTestEnvironment() {\n      if (this.preserveEnvironment) {\n        this.module.testEnvironment = this.testEnvironment;\n        this.testEnvironment = extend({}, this.module.testEnvironment);\n      }\n    },\n    queue: function queue() {\n      var test = this;\n      if (!this.valid()) {\n        incrementTestsIgnored(this.module);\n        return;\n      }\n      function runTest() {\n        return [function () {\n          return test.before();\n        }].concat(_toConsumableArray(test.hooks(\'before\')), [function () {\n          test.preserveTestEnvironment();\n        }], _toConsumableArray(test.hooks(\'beforeEach\')), [function () {\n          test.run();\n        }], _toConsumableArray(test.hooks(\'afterEach\').reverse()), _toConsumableArray(test.hooks(\'after\').reverse()), [function () {\n          test.after();\n        }, function () {\n          return test.finish();\n        }]);\n      }\n      var previousFailCount = config.storage && +config.storage.getItem(\'qunit-test-\' + this.module.name + \'-\' + this.testName);\n\n      // Prioritize previously failed tests, detected from storage\n      var prioritize = config.reorder && !!previousFailCount;\n      this.previousFailure = !!previousFailCount;\n      ProcessingQueue.add(runTest, prioritize, config.seed);\n    },\n    pushResult: function pushResult(resultInfo) {\n      if (this !== config.current) {\n        var message = resultInfo && resultInfo.message || \'\';\n        var testName = this && this.testName || \'\';\n        var error = \'Assertion occurred after test finished.\\n\' + \'> Test: \' + testName + \'\\n\' + \'> Message: \' + message + \'\\n\';\n        throw new Error(error);\n      }\n\n      // Destructure of resultInfo = { result, actual, expected, message, negative }\n      var details = {\n        module: this.module.name,\n        name: this.testName,\n        result: resultInfo.result,\n        message: resultInfo.message,\n        actual: resultInfo.actual,\n        testId: this.testId,\n        negative: resultInfo.negative || false,\n        runtime: Math.round(performance.now() - this.started),\n        todo: !!this.todo\n      };\n      if (hasOwn$1.call(resultInfo, \'expected\')) {\n        details.expected = resultInfo.expected;\n      }\n      if (!resultInfo.result) {\n        var source = resultInfo.source || sourceFromStacktrace();\n        if (source) {\n          details.source = source;\n        }\n      }\n      this.logAssertion(details);\n      this.assertions.push({\n        result: !!resultInfo.result,\n        message: resultInfo.message\n      });\n    },\n    pushFailure: function pushFailure(message, source, actual) {\n      if (!(this instanceof Test)) {\n        throw new Error(\'pushFailure() assertion outside test context, was \' + sourceFromStacktrace(2));\n      }\n      this.pushResult({\n        result: false,\n        message: message || \'error\',\n        actual: actual || null,\n        source: source\n      });\n    },\n    /**\n     * Log assertion details using both the old QUnit.log interface and\n     * QUnit.on( "assertion" ) interface.\n     *\n     * @private\n     */\n    logAssertion: function logAssertion(details) {\n      runLoggingCallbacks(\'log\', details);\n      var assertion = {\n        passed: details.result,\n        actual: details.actual,\n        expected: details.expected,\n        message: details.message,\n        stack: details.source,\n        todo: details.todo\n      };\n      this.testReport.pushAssertion(assertion);\n      emit(\'assertion\', assertion);\n    },\n    /**\n     * Reset config.timeout with a new timeout duration.\n     *\n     * @param {number} timeoutDuration\n     */\n    internalResetTimeout: function internalResetTimeout(timeoutDuration) {\n      clearTimeout(config.timeout);\n      config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);\n    },\n    /**\n     * Create a new async pause and return a new function that can release the pause.\n     *\n     * This mechanism is internally used by:\n     *\n     * - explicit async pauses, created by calling `assert.async()`,\n     * - implicit async pauses, created when `QUnit.test()` or module hook callbacks\n     *   use async-await or otherwise return a Promise.\n     *\n     * Happy scenario:\n     *\n     * - Pause is created by calling internalStop().\n     *\n     *   Pause is released normally by invoking release() during the same test.\n     *\n     *   The release() callback lets internal processing resume.\n     *\n     * Failure scenarios:\n     *\n     * - The test fails due to an uncaught exception.\n     *\n     *   In this case, Test.run() will call internalRecover() which empties the clears all\n     *   async pauses and sets the cancelled flag, which means we silently ignore any\n     *   late calls to the resume() callback, as we will have moved on to a different\n     *   test by then, and we don\'t want to cause an extra "release during a different test"\n     *   errors that the developer isn\'t really responsible for. This can happen when a test\n     *   correctly schedules a call to release(), but also causes an uncaught error. The\n     *   uncaught error means we will no longer wait for the release (as it might not arrive).\n     *\n     * - Pause is never released, or called an insufficient number of times.\n     *\n     *   Our timeout handler will kill the pause and resume test processing, basically\n     *   like internalRecover(), but for one pause instead of any/all.\n     *\n     *   Here, too, any late calls to resume() will be silently ignored to avoid\n     *   extra errors. We tolerate this since the original test will have already been\n     *   marked as failure.\n     *\n     *   TODO: QUnit 3 will enable timeouts by default <https://github.com/qunitjs/qunit/issues/1483>,\n     *   but right now a test will hang indefinitely if async pauses are not released,\n     *   unless QUnit.config.testTimeout or assert.timeout() is used.\n     *\n     * - Pause is spontaneously released during a different test,\n     *   or when no test is currently running.\n     *\n     *   This is close to impossible because this error only happens if the original test\n     *   succesfully finished first (since other failure scenarios kill pauses and ignore\n     *   late calls). It can happen if a test ended exactly as expected, but has some\n     *   external or shared state continuing to hold a reference to the release callback,\n     *   and either the same test scheduled another call to it in the future, or a later test\n     *   causes it to be called through some shared state.\n     *\n     * - Pause release() is called too often, during the same test.\n     *\n     *   This simply throws an error, after which uncaught error handling picks it up\n     *   and processing resumes.\n     *\n     * @param {number} [requiredCalls=1]\n     */\n    internalStop: function internalStop() {\n      var requiredCalls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      config.blocking = true;\n      var test = this;\n      var pauseId = this.nextPauseId++;\n      var pause = {\n        cancelled: false,\n        remaining: requiredCalls\n      };\n      test.pauses.set(pauseId, pause);\n      function release() {\n        if (pause.cancelled) {\n          return;\n        }\n        if (config.current === undefined) {\n          throw new Error(\'Unexpected release of async pause after tests finished.\\n\' + "> Test: ".concat(test.testName, " [async #").concat(pauseId, "]"));\n        }\n        if (config.current !== test) {\n          throw new Error(\'Unexpected release of async pause during a different test.\\n\' + "> Test: ".concat(test.testName, " [async #").concat(pauseId, "]"));\n        }\n        if (pause.remaining <= 0) {\n          throw new Error(\'Tried to release async pause that was already released.\\n\' + "> Test: ".concat(test.testName, " [async #").concat(pauseId, "]"));\n        }\n\n        // The `requiredCalls` parameter exists to support `assert.async(count)`\n        pause.remaining--;\n        if (pause.remaining === 0) {\n          test.pauses.delete(pauseId);\n        }\n        internalStart(test);\n      }\n\n      // Set a recovery timeout, if so configured.\n      if (setTimeout$1) {\n        var timeoutDuration;\n        if (typeof test.timeout === \'number\') {\n          timeoutDuration = test.timeout;\n        } else if (typeof config.testTimeout === \'number\') {\n          timeoutDuration = config.testTimeout;\n        }\n        if (typeof timeoutDuration === \'number\' && timeoutDuration > 0) {\n          config.timeoutHandler = function (timeout) {\n            return function () {\n              config.timeout = null;\n              pause.cancelled = true;\n              test.pauses.delete(pauseId);\n              test.pushFailure("Test took longer than ".concat(timeout, "ms; test timed out."), sourceFromStacktrace(2));\n              internalStart(test);\n            };\n          };\n          clearTimeout(config.timeout);\n          config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);\n        }\n      }\n      return release;\n    },\n    resolvePromise: function resolvePromise(promise, phase) {\n      if (promise != null) {\n        var _test = this;\n        var then = promise.then;\n        if (typeof then === \'function\') {\n          var resume = _test.internalStop();\n          var resolve = function resolve() {\n            resume();\n          };\n          if (config.notrycatch) {\n            then.call(promise, resolve);\n          } else {\n            var reject = function reject(error) {\n              var message = \'Promise rejected \' + (!phase ? \'during\' : phase.replace(/Each$/, \'\')) + \' "\' + _test.testName + \'": \' + (error && error.message || error);\n              _test.pushFailure(message, extractStacktrace(error, 0));\n\n              // Else next test will carry the responsibility\n              saveGlobal();\n\n              // Unblock\n              internalRecover(_test);\n            };\n            then.call(promise, resolve, reject);\n          }\n        }\n      }\n    },\n    valid: function valid() {\n      // Internally-generated tests are always valid\n      if (this.callback && this.callback.validTest) {\n        return true;\n      }\n      function moduleChainIdMatch(testModule, selectedId) {\n        return (\n          // undefined or empty array\n          !selectedId || !selectedId.length || inArray(testModule.moduleId, selectedId) || testModule.parentModule && moduleChainIdMatch(testModule.parentModule, selectedId)\n        );\n      }\n      if (!moduleChainIdMatch(this.module, config.moduleId)) {\n        return false;\n      }\n      if (config.testId && config.testId.length && !inArray(this.testId, config.testId)) {\n        return false;\n      }\n      function moduleChainNameMatch(testModule, selectedModule) {\n        if (!selectedModule) {\n          // undefined or empty string\n          return true;\n        }\n        var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n        if (testModuleName === selectedModule) {\n          return true;\n        } else if (testModule.parentModule) {\n          return moduleChainNameMatch(testModule.parentModule, selectedModule);\n        } else {\n          return false;\n        }\n      }\n      var selectedModule = config.module && config.module.toLowerCase();\n      if (!moduleChainNameMatch(this.module, selectedModule)) {\n        return false;\n      }\n      var filter = config.filter;\n      if (!filter) {\n        return true;\n      }\n      var regexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec(filter);\n      var fullName = this.module.name + \': \' + this.testName;\n      return regexFilter ? this.regexFilter(!!regexFilter[1], regexFilter[2], regexFilter[3], fullName) : this.stringFilter(filter, fullName);\n    },\n    regexFilter: function regexFilter(exclude, pattern, flags, fullName) {\n      var regex = new RegExp(pattern, flags);\n      var match = regex.test(fullName);\n      return match !== exclude;\n    },\n    stringFilter: function stringFilter(filter, fullName) {\n      filter = filter.toLowerCase();\n      fullName = fullName.toLowerCase();\n      var include = filter.charAt(0) !== \'!\';\n      if (!include) {\n        filter = filter.slice(1);\n      }\n\n      // If the filter matches, we need to honour include\n      if (fullName.indexOf(filter) !== -1) {\n        return include;\n      }\n\n      // Otherwise, do the opposite\n      return !include;\n    }\n  };\n  function pushFailure() {\n    if (!config.current) {\n      throw new Error(\'pushFailure() assertion outside test context, in \' + sourceFromStacktrace(2));\n    }\n\n    // Gets current test obj\n    var currentTest = config.current;\n    return currentTest.pushFailure.apply(currentTest, arguments);\n  }\n  function saveGlobal() {\n    config.pollution = [];\n    if (config.noglobals) {\n      for (var key in g) {\n        if (hasOwn$1.call(g, key)) {\n          // In Opera sometimes DOM element ids show up here, ignore them\n          if (/^qunit-test-output/.test(key)) {\n            continue;\n          }\n          config.pollution.push(key);\n        }\n      }\n    }\n  }\n  function checkPollution() {\n    var old = config.pollution;\n    saveGlobal();\n    var newGlobals = diff(config.pollution, old);\n    if (newGlobals.length > 0) {\n      pushFailure(\'Introduced global variable(s): \' + newGlobals.join(\', \'));\n    }\n    var deletedGlobals = diff(old, config.pollution);\n    if (deletedGlobals.length > 0) {\n      pushFailure(\'Deleted global variable(s): \' + deletedGlobals.join(\', \'));\n    }\n  }\n  var focused = false; // indicates that the "only" filter was used\n\n  function addTest(settings) {\n    if (focused || config.currentModule.ignored) {\n      return;\n    }\n    var newTest = new Test(settings);\n    newTest.queue();\n  }\n  function addOnlyTest(settings) {\n    if (config.currentModule.ignored) {\n      return;\n    }\n    if (!focused) {\n      config.queue.length = 0;\n      focused = true;\n    }\n    var newTest = new Test(settings);\n    newTest.queue();\n  }\n\n  // Will be exposed as QUnit.test\n  function test(testName, callback) {\n    addTest({\n      testName: testName,\n      callback: callback\n    });\n  }\n  function makeEachTestName(testName, argument) {\n    return "".concat(testName, " [").concat(argument, "]");\n  }\n  function runEach(data, eachFn) {\n    if (Array.isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        eachFn(data[i], i);\n      }\n    } else if (_typeof(data) === \'object\' && data !== null) {\n      for (var key in data) {\n        eachFn(data[key], key);\n      }\n    } else {\n      throw new Error("test.each() expects an array or object as input, but\\nfound ".concat(_typeof(data), " instead."));\n    }\n  }\n  extend(test, {\n    todo: function todo(testName, callback) {\n      addTest({\n        testName: testName,\n        callback: callback,\n        todo: true\n      });\n    },\n    skip: function skip(testName) {\n      addTest({\n        testName: testName,\n        skip: true\n      });\n    },\n    only: function only(testName, callback) {\n      addOnlyTest({\n        testName: testName,\n        callback: callback\n      });\n    },\n    each: function each(testName, dataset, callback) {\n      runEach(dataset, function (data, testKey) {\n        addTest({\n          testName: makeEachTestName(testName, testKey),\n          callback: callback,\n          withData: true,\n          stackOffset: 5,\n          data: data\n        });\n      });\n    }\n  });\n  test.todo.each = function (testName, dataset, callback) {\n    runEach(dataset, function (data, testKey) {\n      addTest({\n        testName: makeEachTestName(testName, testKey),\n        callback: callback,\n        todo: true,\n        withData: true,\n        stackOffset: 5,\n        data: data\n      });\n    });\n  };\n  test.skip.each = function (testName, dataset) {\n    runEach(dataset, function (_, testKey) {\n      addTest({\n        testName: makeEachTestName(testName, testKey),\n        stackOffset: 5,\n        skip: true\n      });\n    });\n  };\n  test.only.each = function (testName, dataset, callback) {\n    runEach(dataset, function (data, testKey) {\n      addOnlyTest({\n        testName: makeEachTestName(testName, testKey),\n        callback: callback,\n        withData: true,\n        stackOffset: 5,\n        data: data\n      });\n    });\n  };\n\n  // Forcefully release all processing holds.\n  function internalRecover(test) {\n    test.pauses.forEach(function (pause) {\n      pause.cancelled = true;\n    });\n    test.pauses.clear();\n    internalStart(test);\n  }\n\n  // Release a processing hold, scheduling a resumption attempt if no holds remain.\n  function internalStart(test) {\n    // Ignore if other async pauses still exist.\n    if (test.pauses.size > 0) {\n      return;\n    }\n\n    // Add a slight delay to allow more assertions etc.\n    if (setTimeout$1) {\n      clearTimeout(config.timeout);\n      config.timeout = setTimeout$1(function () {\n        if (test.pauses.size > 0) {\n          return;\n        }\n        clearTimeout(config.timeout);\n        config.timeout = null;\n        config.blocking = false;\n        ProcessingQueue.advance();\n      });\n    } else {\n      config.blocking = false;\n      ProcessingQueue.advance();\n    }\n  }\n  function collectTests(module) {\n    var tests = [].concat(module.tests);\n    var modules = _toConsumableArray(module.childModules);\n\n    // Do a breadth-first traversal of the child modules\n    while (modules.length) {\n      var nextModule = modules.shift();\n      tests.push.apply(tests, nextModule.tests);\n      modules.push.apply(modules, _toConsumableArray(nextModule.childModules));\n    }\n    return tests;\n  }\n\n  // This returns true after all executable and skippable tests\n  // in a module have been proccessed, and informs \'suiteEnd\'\n  // and moduleDone().\n  function allTestsExecuted(module) {\n    return module.testsRun + module.testsIgnored === collectTests(module).length;\n  }\n\n  // This returns true during the last executable non-skipped test\n  // within a module, and informs the running of the \'after\' hook\n  // for a given module. This runs only once for a given module,\n  // but must run during the last non-skipped test. When it runs,\n  // there may be non-zero skipped tests left.\n  function lastTestWithinModuleExecuted(module) {\n    return module.testsRun === collectTests(module).filter(function (test) {\n      return !test.skip;\n    }).length - 1;\n  }\n  function incrementTestsRun(module) {\n    module.testsRun++;\n    while (module = module.parentModule) {\n      module.testsRun++;\n    }\n  }\n  function incrementTestsIgnored(module) {\n    module.testsIgnored++;\n    while (module = module.parentModule) {\n      module.testsIgnored++;\n    }\n  }\n\n  /* global module, exports, define */\n  function exportQUnit(QUnit) {\n    var exportedModule = false;\n    if (window$1 && document) {\n      // QUnit may be defined when it is preconfigured but then only QUnit and QUnit.config may be defined.\n      if (window$1.QUnit && window$1.QUnit.version) {\n        throw new Error(\'QUnit has already been defined.\');\n      }\n      window$1.QUnit = QUnit;\n      exportedModule = true;\n    }\n\n    // For Node.js\n    if (typeof module !== \'undefined\' && module && module.exports) {\n      module.exports = QUnit;\n\n      // For consistency with CommonJS environments\' exports\n      module.exports.QUnit = QUnit;\n      exportedModule = true;\n    }\n\n    // For CommonJS with exports, but without module.exports, like Rhino\n    if (typeof exports !== \'undefined\' && exports) {\n      exports.QUnit = QUnit;\n      exportedModule = true;\n    }\n\n    // For AMD\n    if (typeof define === \'function\' && define.amd) {\n      define(function () {\n        return QUnit;\n      });\n      QUnit.config.autostart = false;\n      exportedModule = true;\n    }\n\n    // For other environments, including Web Workers (globalThis === self),\n    // SpiderMonkey (mozjs), and other embedded JavaScript engines\n    if (!exportedModule) {\n      g.QUnit = QUnit;\n    }\n  }\n\n  var ConsoleReporter = /*#__PURE__*/function () {\n    function ConsoleReporter(runner) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _classCallCheck(this, ConsoleReporter);\n      // Cache references to console methods to ensure we can report failures\n      // from tests tests that mock the console object itself.\n      // https://github.com/qunitjs/qunit/issues/1340\n      // Support IE 9: Function#bind is supported, but no console.log.bind().\n      this.log = options.log || Function.prototype.bind.call(console$1.log, console$1);\n      runner.on(\'error\', this.onError.bind(this));\n      runner.on(\'runStart\', this.onRunStart.bind(this));\n      runner.on(\'testStart\', this.onTestStart.bind(this));\n      runner.on(\'testEnd\', this.onTestEnd.bind(this));\n      runner.on(\'runEnd\', this.onRunEnd.bind(this));\n    }\n    _createClass(ConsoleReporter, [{\n      key: "onError",\n      value: function onError(error) {\n        this.log(\'error\', error);\n      }\n    }, {\n      key: "onRunStart",\n      value: function onRunStart(runStart) {\n        this.log(\'runStart\', runStart);\n      }\n    }, {\n      key: "onTestStart",\n      value: function onTestStart(test) {\n        this.log(\'testStart\', test);\n      }\n    }, {\n      key: "onTestEnd",\n      value: function onTestEnd(test) {\n        this.log(\'testEnd\', test);\n      }\n    }, {\n      key: "onRunEnd",\n      value: function onRunEnd(runEnd) {\n        this.log(\'runEnd\', runEnd);\n      }\n    }], [{\n      key: "init",\n      value: function init(runner, options) {\n        return new ConsoleReporter(runner, options);\n      }\n    }]);\n    return ConsoleReporter;\n  }();\n\n  var FORCE_COLOR,\n    NODE_DISABLE_COLORS,\n    NO_COLOR,\n    TERM,\n    isTTY = true;\n  if (typeof process !== \'undefined\') {\n    var _ref = process.env || {};\n    FORCE_COLOR = _ref.FORCE_COLOR;\n    NODE_DISABLE_COLORS = _ref.NODE_DISABLE_COLORS;\n    NO_COLOR = _ref.NO_COLOR;\n    TERM = _ref.TERM;\n    isTTY = process.stdout && process.stdout.isTTY;\n  }\n  var $ = {\n    enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== \'dumb\' && (FORCE_COLOR != null && FORCE_COLOR !== \'0\' || isTTY),\n    // modifiers\n    reset: init(0, 0),\n    bold: init(1, 22),\n    dim: init(2, 22),\n    italic: init(3, 23),\n    underline: init(4, 24),\n    inverse: init(7, 27),\n    hidden: init(8, 28),\n    strikethrough: init(9, 29),\n    // colors\n    black: init(30, 39),\n    red: init(31, 39),\n    green: init(32, 39),\n    yellow: init(33, 39),\n    blue: init(34, 39),\n    magenta: init(35, 39),\n    cyan: init(36, 39),\n    white: init(37, 39),\n    gray: init(90, 39),\n    grey: init(90, 39),\n    // background colors\n    bgBlack: init(40, 49),\n    bgRed: init(41, 49),\n    bgGreen: init(42, 49),\n    bgYellow: init(43, 49),\n    bgBlue: init(44, 49),\n    bgMagenta: init(45, 49),\n    bgCyan: init(46, 49),\n    bgWhite: init(47, 49)\n  };\n  function run(arr, str) {\n    var i = 0,\n      tmp,\n      beg = \'\',\n      end = \'\';\n    for (; i < arr.length; i++) {\n      tmp = arr[i];\n      beg += tmp.open;\n      end += tmp.close;\n      if (!!~str.indexOf(tmp.close)) {\n        str = str.replace(tmp.rgx, tmp.close + tmp.open);\n      }\n    }\n    return beg + str + end;\n  }\n  function chain(has, keys) {\n    var ctx = {\n      has: has,\n      keys: keys\n    };\n    ctx.reset = $.reset.bind(ctx);\n    ctx.bold = $.bold.bind(ctx);\n    ctx.dim = $.dim.bind(ctx);\n    ctx.italic = $.italic.bind(ctx);\n    ctx.underline = $.underline.bind(ctx);\n    ctx.inverse = $.inverse.bind(ctx);\n    ctx.hidden = $.hidden.bind(ctx);\n    ctx.strikethrough = $.strikethrough.bind(ctx);\n    ctx.black = $.black.bind(ctx);\n    ctx.red = $.red.bind(ctx);\n    ctx.green = $.green.bind(ctx);\n    ctx.yellow = $.yellow.bind(ctx);\n    ctx.blue = $.blue.bind(ctx);\n    ctx.magenta = $.magenta.bind(ctx);\n    ctx.cyan = $.cyan.bind(ctx);\n    ctx.white = $.white.bind(ctx);\n    ctx.gray = $.gray.bind(ctx);\n    ctx.grey = $.grey.bind(ctx);\n    ctx.bgBlack = $.bgBlack.bind(ctx);\n    ctx.bgRed = $.bgRed.bind(ctx);\n    ctx.bgGreen = $.bgGreen.bind(ctx);\n    ctx.bgYellow = $.bgYellow.bind(ctx);\n    ctx.bgBlue = $.bgBlue.bind(ctx);\n    ctx.bgMagenta = $.bgMagenta.bind(ctx);\n    ctx.bgCyan = $.bgCyan.bind(ctx);\n    ctx.bgWhite = $.bgWhite.bind(ctx);\n    return ctx;\n  }\n  function init(open, close) {\n    var blk = {\n      open: "\\x1B[".concat(open, "m"),\n      close: "\\x1B[".concat(close, "m"),\n      rgx: new RegExp("\\\\x1b\\\\[".concat(close, "m"), \'g\')\n    };\n    return function (txt) {\n      if (this !== void 0 && this.has !== void 0) {\n        !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));\n        return txt === void 0 ? this : $.enabled ? run(this.keys, txt + \'\') : txt + \'\';\n      }\n      return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt + \'\') : txt + \'\';\n    };\n  }\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  /**\n   * Format a given value into YAML.\n   *\n   * YAML is a superset of JSON that supports all the same data\n   * types and syntax, and more. As such, it is always possible\n   * to fallback to JSON.stringfify, but we generally avoid\n   * that to make output easier to read for humans.\n   *\n   * Supported data types:\n   *\n   * - null\n   * - boolean\n   * - number\n   * - string\n   * - array\n   * - object\n   *\n   * Anything else (including NaN, Infinity, and undefined)\n   * must be described in strings, for display purposes.\n   *\n   * Note that quotes are optional in YAML strings if the\n   * strings are "simple", and as such we generally prefer\n   * that for improved readability. We output strings in\n   * one of three ways:\n   *\n   * - bare unquoted text, for simple one-line strings.\n   * - JSON (quoted text), for complex one-line strings.\n   * - YAML Block, for complex multi-line strings.\n   *\n   * Objects with cyclical references will be stringifed as\n   * "[Circular]" as they cannot otherwise be represented.\n   */\n  function prettyYamlValue(value) {\n    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n    if (value === undefined) {\n      // Not supported in JSON/YAML, turn into string\n      // and let the below output it as bare string.\n      value = String(value);\n    }\n\n    // Support IE 9-11: Use isFinite instead of ES6 Number.isFinite\n    if (typeof value === \'number\' && !isFinite(value)) {\n      // Turn NaN and Infinity into simple strings.\n      // Paranoia: Don\'t return directly just in case there\'s\n      // a way to add special characters here.\n      value = String(value);\n    }\n    if (typeof value === \'number\') {\n      // Simple numbers\n      return JSON.stringify(value);\n    }\n    if (typeof value === \'string\') {\n      // If any of these match, then we can\'t output it\n      // as bare unquoted text, because that would either\n      // cause data loss or invalid YAML syntax.\n      //\n      // - Quotes, escapes, line breaks, or JSON-like stuff.\n      var rSpecialJson = /[\'"\\\\/[{}\\]\\r\\n]/;\n\n      // - Characters that are special at the start of a YAML value\n      var rSpecialYaml = /[-?:,[\\]{}#&*!|=>\'"%@`]/;\n\n      // - Leading or trailing whitespace.\n      var rUntrimmed = /(^\\s|\\s$)/;\n\n      // - Ambiguous as YAML number, e.g. \'2\', \'-1.2\', \'.2\', or \'2_000\'\n      var rNumerical = /^[\\d._-]+$/;\n\n      // - Ambiguous as YAML bool.\n      //   Use case-insensitive match, although technically only\n      //   fully-lower, fully-upper, or uppercase-first would be ambiguous.\n      //   e.g. true/True/TRUE, but not tRUe.\n      var rBool = /^(true|false|y|n|yes|no|on|off)$/i;\n\n      // Is this a complex string?\n      if (value === \'\' || rSpecialJson.test(value) || rSpecialYaml.test(value[0]) || rUntrimmed.test(value) || rNumerical.test(value) || rBool.test(value)) {\n        if (!/\\n/.test(value)) {\n          // Complex one-line string, use JSON (quoted string)\n          return JSON.stringify(value);\n        }\n\n        // See also <https://yaml-multiline.info/>\n        // Support IE 9-11: Avoid ES6 String#repeat\n        var prefix = new Array(indent + 1).join(\' \');\n        var trailingLinebreakMatch = value.match(/\\n+$/);\n        var trailingLinebreaks = trailingLinebreakMatch ? trailingLinebreakMatch[0].length : 0;\n        if (trailingLinebreaks === 1) {\n          // Use the most straight-forward "Block" string in YAML\n          // without any "Chomping" indicators.\n          var lines = value\n\n          // Ignore the last new line, since we\'ll get that one for free\n          // with the straight-forward Block syntax.\n          .replace(/\\n$/, \'\').split(\'\\n\').map(function (line) {\n            return prefix + line;\n          });\n          return \'|\\n\' + lines.join(\'\\n\');\n        } else {\n          // This has either no trailing new lines, or more than 1.\n          // Use |+ so that YAML parsers will preserve it exactly.\n          var _lines = value.split(\'\\n\').map(function (line) {\n            return prefix + line;\n          });\n          return \'|+\\n\' + _lines.join(\'\\n\');\n        }\n      } else {\n        // Simple string, use bare unquoted text\n        return value;\n      }\n    }\n\n    // Handle null, boolean, array, and object\n    return JSON.stringify(decycledShallowClone(value), null, 2);\n  }\n\n  /**\n   * Creates a shallow clone of an object where cycles have\n   * been replaced with "[Circular]".\n   */\n  function decycledShallowClone(object) {\n    var ancestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    if (ancestors.indexOf(object) !== -1) {\n      return \'[Circular]\';\n    }\n    var type = Object.prototype.toString.call(object).replace(/^\\[.+\\s(.+?)]$/, \'$1\').toLowerCase();\n    var clone;\n    switch (type) {\n      case \'array\':\n        ancestors.push(object);\n        clone = object.map(function (element) {\n          return decycledShallowClone(element, ancestors);\n        });\n        ancestors.pop();\n        break;\n      case \'object\':\n        ancestors.push(object);\n        clone = {};\n        Object.keys(object).forEach(function (key) {\n          clone[key] = decycledShallowClone(object[key], ancestors);\n        });\n        ancestors.pop();\n        break;\n      default:\n        clone = object;\n    }\n    return clone;\n  }\n  var TapReporter = /*#__PURE__*/function () {\n    function TapReporter(runner) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _classCallCheck(this, TapReporter);\n      // Cache references to console methods to ensure we can report failures\n      // from tests tests that mock the console object itself.\n      // https://github.com/qunitjs/qunit/issues/1340\n      // Support IE 9: Function#bind is supported, but no console.log.bind().\n      this.log = options.log || Function.prototype.bind.call(console$1.log, console$1);\n      this.testCount = 0;\n      this.ended = false;\n      this.bailed = false;\n      runner.on(\'error\', this.onError.bind(this));\n      runner.on(\'runStart\', this.onRunStart.bind(this));\n      runner.on(\'testEnd\', this.onTestEnd.bind(this));\n      runner.on(\'runEnd\', this.onRunEnd.bind(this));\n    }\n    _createClass(TapReporter, [{\n      key: "onRunStart",\n      value: function onRunStart(_runSuite) {\n        this.log(\'TAP version 13\');\n      }\n    }, {\n      key: "onError",\n      value: function onError(error) {\n        if (this.bailed) {\n          return;\n        }\n        this.bailed = true;\n\n        // Imitate onTestEnd\n        // Skip this if we\'re past "runEnd" as it would look odd\n        if (!this.ended) {\n          this.testCount = this.testCount + 1;\n          this.log($.red("not ok ".concat(this.testCount, " global failure")));\n          this.logError(error);\n        }\n        this.log(\'Bail out! \' + errorString(error).split(\'\\n\')[0]);\n        if (this.ended) {\n          this.logError(error);\n        }\n      }\n    }, {\n      key: "onTestEnd",\n      value: function onTestEnd(test) {\n        var _this = this;\n        this.testCount = this.testCount + 1;\n        if (test.status === \'passed\') {\n          this.log("ok ".concat(this.testCount, " ").concat(test.fullName.join(\' > \')));\n        } else if (test.status === \'skipped\') {\n          this.log($.yellow("ok ".concat(this.testCount, " # SKIP ").concat(test.fullName.join(\' > \'))));\n        } else if (test.status === \'todo\') {\n          this.log($.cyan("not ok ".concat(this.testCount, " # TODO ").concat(test.fullName.join(\' > \'))));\n          test.errors.forEach(function (error) {\n            return _this.logAssertion(error, \'todo\');\n          });\n        } else {\n          this.log($.red("not ok ".concat(this.testCount, " ").concat(test.fullName.join(\' > \'))));\n          test.errors.forEach(function (error) {\n            return _this.logAssertion(error);\n          });\n        }\n      }\n    }, {\n      key: "onRunEnd",\n      value: function onRunEnd(runSuite) {\n        this.ended = true;\n        this.log("1..".concat(runSuite.testCounts.total));\n        this.log("# pass ".concat(runSuite.testCounts.passed));\n        this.log($.yellow("# skip ".concat(runSuite.testCounts.skipped)));\n        this.log($.cyan("# todo ".concat(runSuite.testCounts.todo)));\n        this.log($.red("# fail ".concat(runSuite.testCounts.failed)));\n      }\n    }, {\n      key: "logAssertion",\n      value: function logAssertion(error, severity) {\n        var out = \'  ---\';\n        out += "\\n  message: ".concat(prettyYamlValue(error.message || \'failed\'));\n        out += "\\n  severity: ".concat(prettyYamlValue(severity || \'failed\'));\n        if (hasOwn.call(error, \'actual\')) {\n          out += "\\n  actual  : ".concat(prettyYamlValue(error.actual));\n        }\n        if (hasOwn.call(error, \'expected\')) {\n          out += "\\n  expected: ".concat(prettyYamlValue(error.expected));\n        }\n        if (error.stack) {\n          // Since stacks aren\'t user generated, take a bit of liberty by\n          // adding a trailing new line to allow a straight-forward YAML Blocks.\n          out += "\\n  stack: ".concat(prettyYamlValue(error.stack + \'\\n\'));\n        }\n        out += \'\\n  ...\';\n        this.log(out);\n      }\n    }, {\n      key: "logError",\n      value: function logError(error) {\n        var out = \'  ---\';\n        out += "\\n  message: ".concat(prettyYamlValue(errorString(error)));\n        out += "\\n  severity: ".concat(prettyYamlValue(\'failed\'));\n        if (error && error.stack) {\n          out += "\\n  stack: ".concat(prettyYamlValue(error.stack + \'\\n\'));\n        }\n        out += \'\\n  ...\';\n        this.log(out);\n      }\n    }], [{\n      key: "init",\n      value: function init(runner, options) {\n        return new TapReporter(runner, options);\n      }\n    }]);\n    return TapReporter;\n  }();\n\n  var reporters = {\n    console: ConsoleReporter,\n    tap: TapReporter\n  };\n\n  function makeAddGlobalHook(hookName) {\n    return function addGlobalHook(callback) {\n      if (!config.globalHooks[hookName]) {\n        config.globalHooks[hookName] = [];\n      }\n      config.globalHooks[hookName].push(callback);\n    };\n  }\n  var hooks = {\n    beforeEach: makeAddGlobalHook(\'beforeEach\'),\n    afterEach: makeAddGlobalHook(\'afterEach\')\n  };\n\n  /**\n   * Handle a global error that should result in a failed test run.\n   *\n   * Summary:\n   *\n   * - If we\'re strictly inside a test (or one if its module hooks), the exception\n   *   becomes a failed assertion.\n   *\n   *   This has the important side-effect that uncaught exceptions (such as\n   *   calling an undefined function) during a "todo" test do NOT result in\n   *   a failed test run.\n   *\n   * - If we\'re anywhere outside a test (be it in early event callbacks, or\n   *   internally between tests, or somewhere after "runEnd" if the process is\n   *   still alive for some reason), then send an "error" event to the reporters.\n   *\n   * @since 2.17.0\n   * @param {Error|any} error\n   */\n  function onUncaughtException(error) {\n    if (config.current) {\n      config.current.assert.pushResult({\n        result: false,\n        message: "global failure: ".concat(errorString(error)),\n        // We could let callers specify an offset to subtract a number of frames via\n        // sourceFromStacktrace, in case they are a wrapper further away from the error\n        // handler, and thus reduce some noise in the stack trace. However, we\'re not\n        // doing this right now because it would almost never be used in practice given\n        // the vast majority of error values will be Error objects, and thus have their\n        // own stack trace already.\n        source: error && error.stack || sourceFromStacktrace(2)\n      });\n    } else {\n      // The "error" event was added in QUnit 2.17.\n      // Increase "bad assertion" stats despite no longer pushing an assertion in this case.\n      // This ensures "runEnd" and "QUnit.done()" handlers behave as expected, since the "bad"\n      // count is typically how reporters decide on the boolean outcome of the test run.\n      runSuite.globalFailureCount++;\n      config.stats.bad++;\n      config.stats.all++;\n      emit(\'error\', error);\n    }\n  }\n\n  /**\n   * Handle a window.onerror error.\n   *\n   * If there is a current test that sets the internal `ignoreGlobalErrors` field\n   * (such as during `assert.throws()`), then the error is ignored and native\n   * error reporting is suppressed as well. This is because in browsers, an error\n   * can sometimes end up in `window.onerror` instead of in the local try/catch.\n   * This ignoring of errors does not apply to our general onUncaughtException\n   * method, nor to our `unhandledRejection` handlers, as those are not meant\n   * to receive an "expected" error during `assert.throws()`.\n   *\n   * @see <https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror>\n   * @deprecated since 2.17.0 Use QUnit.onUncaughtException instead.\n   * @param {Object} details\n   * @param {string} details.message\n   * @param {string} details.fileName\n   * @param {number} details.lineNumber\n   * @param {string|undefined} [details.stacktrace]\n   * @return {bool} True if native error reporting should be suppressed.\n   */\n  function onWindowError(details) {\n    Logger.warn(\'QUnit.onError is deprecated and will be removed in QUnit 3.0.\' + \' Please use QUnit.onUncaughtException instead.\');\n    if (config.current && config.current.ignoreGlobalErrors) {\n      return true;\n    }\n    var err = new Error(details.message);\n    err.stack = details.stacktrace || details.fileName + \':\' + details.lineNumber;\n    onUncaughtException(err);\n    return false;\n  }\n\n  var QUnit = {};\n\n  // The "currentModule" object would ideally be defined using the createModule()\n  // function. Since it isn\'t, add the missing suiteReport property to it now that\n  // we have loaded all source code required to do so.\n  //\n  // TODO: Consider defining currentModule in core.js or module.js in its entirely\n  // rather than partly in config.js and partly here.\n  config.currentModule.suiteReport = runSuite;\n  var globalStartCalled = false;\n  var runStarted = false;\n\n  // Figure out if we\'re running the tests from a server or not\n  QUnit.isLocal = window$1 && window$1.location && window$1.location.protocol === \'file:\';\n\n  // Expose the current QUnit version\n  QUnit.version = \'2.19.4\';\n  extend(QUnit, {\n    config: config,\n    dump: dump,\n    equiv: equiv,\n    reporters: reporters,\n    hooks: hooks,\n    is: is,\n    objectType: objectType,\n    on: on,\n    onError: onWindowError,\n    onUncaughtException: onUncaughtException,\n    pushFailure: pushFailure,\n    assert: Assert.prototype,\n    module: module$1,\n    test: test,\n    // alias other test flavors for easy access\n    todo: test.todo,\n    skip: test.skip,\n    only: test.only,\n    start: function start(count) {\n      if (config.current) {\n        throw new Error(\'QUnit.start cannot be called inside a test context.\');\n      }\n      var globalStartAlreadyCalled = globalStartCalled;\n      globalStartCalled = true;\n      if (runStarted) {\n        throw new Error(\'Called start() while test already started running\');\n      }\n      if (globalStartAlreadyCalled || count > 1) {\n        throw new Error(\'Called start() outside of a test context too many times\');\n      }\n      if (config.autostart) {\n        throw new Error(\'Called start() outside of a test context when \' + \'QUnit.config.autostart was true\');\n      }\n      if (!config.pageLoaded) {\n        // The page isn\'t completely loaded yet, so we set autostart and then\n        // load if we\'re in Node or wait for the browser\'s load event.\n        config.autostart = true;\n\n        // Starts from Node even if .load was not previously called. We still return\n        // early otherwise we\'ll wind up "beginning" twice.\n        if (!document) {\n          QUnit.load();\n        }\n        return;\n      }\n      scheduleBegin();\n    },\n    onUnhandledRejection: function onUnhandledRejection(reason) {\n      Logger.warn(\'QUnit.onUnhandledRejection is deprecated and will be removed in QUnit 3.0.\' + \' Please use QUnit.onUncaughtException instead.\');\n      onUncaughtException(reason);\n    },\n    extend: function extend$1() {\n      Logger.warn(\'QUnit.extend is deprecated and will be removed in QUnit 3.0.\' + \' Please use Object.assign instead.\');\n\n      // delegate to utility implementation, which does not warn and can be used elsewhere internally\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return extend.apply(this, args);\n    },\n    load: function load() {\n      config.pageLoaded = true;\n\n      // Initialize the configuration options\n      extend(config, {\n        started: 0,\n        updateRate: 1000,\n        autostart: true,\n        filter: \'\'\n      }, true);\n      if (!runStarted) {\n        config.blocking = false;\n        if (config.autostart) {\n          scheduleBegin();\n        }\n      }\n    },\n    stack: function stack(offset) {\n      offset = (offset || 0) + 2;\n      return sourceFromStacktrace(offset);\n    }\n  });\n  registerLoggingCallbacks(QUnit);\n  function scheduleBegin() {\n    runStarted = true;\n\n    // Add a slight delay to allow definition of more modules and tests.\n    if (setTimeout$1) {\n      setTimeout$1(function () {\n        begin();\n      });\n    } else {\n      begin();\n    }\n  }\n  function unblockAndAdvanceQueue() {\n    config.blocking = false;\n    ProcessingQueue.advance();\n  }\n  function begin() {\n    if (config.started) {\n      unblockAndAdvanceQueue();\n      return;\n    }\n\n    // The test run hasn\'t officially begun yet\n    // Record the time of the test run\'s beginning\n    config.started = performance.now();\n\n    // Delete the loose unnamed module if unused.\n    if (config.modules[0].name === \'\' && config.modules[0].tests.length === 0) {\n      config.modules.shift();\n    }\n    var modulesLog = [];\n    for (var i = 0; i < config.modules.length; i++) {\n      // Don\'t expose the unnamed global test module to plugins.\n      if (config.modules[i].name !== \'\') {\n        modulesLog.push({\n          name: config.modules[i].name,\n          moduleId: config.modules[i].moduleId,\n          // Added in QUnit 1.16.0 for internal use by html-reporter,\n          // but no longer used since QUnit 2.7.0.\n          // @deprecated Kept unofficially to be removed in QUnit 3.0.\n          tests: config.modules[i].tests\n        });\n      }\n    }\n\n    // The test run is officially beginning now\n    emit(\'runStart\', runSuite.start(true));\n    runLoggingCallbacks(\'begin\', {\n      totalTests: Test.count,\n      modules: modulesLog\n    }).then(unblockAndAdvanceQueue);\n  }\n  exportQUnit(QUnit);\n\n  (function () {\n    if (!window$1 || !document) {\n      return;\n    }\n    var config = QUnit.config;\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    // Stores fixture HTML for resetting later\n    function storeFixture() {\n      // Avoid overwriting user-defined values\n      if (hasOwn.call(config, \'fixture\')) {\n        return;\n      }\n      var fixture = document.getElementById(\'qunit-fixture\');\n      if (fixture) {\n        config.fixture = fixture.cloneNode(true);\n      }\n    }\n    QUnit.begin(storeFixture);\n\n    // Resets the fixture DOM element if available.\n    function resetFixture() {\n      if (config.fixture == null) {\n        return;\n      }\n      var fixture = document.getElementById(\'qunit-fixture\');\n      var resetFixtureType = _typeof(config.fixture);\n      if (resetFixtureType === \'string\') {\n        // support user defined values for `config.fixture`\n        var newFixture = document.createElement(\'div\');\n        newFixture.setAttribute(\'id\', \'qunit-fixture\');\n        newFixture.innerHTML = config.fixture;\n        fixture.parentNode.replaceChild(newFixture, fixture);\n      } else {\n        var clonedFixture = config.fixture.cloneNode(true);\n        fixture.parentNode.replaceChild(clonedFixture, fixture);\n      }\n    }\n    QUnit.testStart(resetFixture);\n  })();\n\n  (function () {\n    // Only interact with URLs via window.location\n    var location = typeof window$1 !== \'undefined\' && window$1.location;\n    if (!location) {\n      return;\n    }\n    var urlParams = getUrlParams();\n    QUnit.urlParams = urlParams;\n    QUnit.config.filter = urlParams.filter;\n    QUnit.config.module = urlParams.module;\n    QUnit.config.moduleId = [].concat(urlParams.moduleId || []);\n    QUnit.config.testId = [].concat(urlParams.testId || []);\n\n    // Test order randomization\n    if (urlParams.seed === true) {\n      // Generate a random seed if the option is specified without a value\n      QUnit.config.seed = Math.random().toString(36).slice(2);\n    } else if (urlParams.seed) {\n      QUnit.config.seed = urlParams.seed;\n    }\n\n    // Add URL-parameter-mapped config values with UI form rendering data\n    QUnit.config.urlConfig.push({\n      id: \'hidepassed\',\n      label: \'Hide passed tests\',\n      tooltip: \'Only show tests and assertions that fail. Stored as query-strings.\'\n    }, {\n      id: \'noglobals\',\n      label: \'Check for Globals\',\n      tooltip: \'Enabling this will test if any test introduces new properties on the \' + \'global object (`window` in Browsers). Stored as query-strings.\'\n    }, {\n      id: \'notrycatch\',\n      label: \'No try-catch\',\n      tooltip: \'Enabling this will run tests outside of a try-catch block. Makes debugging \' + \'exceptions in IE reasonable. Stored as query-strings.\'\n    });\n    QUnit.begin(function () {\n      var urlConfig = QUnit.config.urlConfig;\n      for (var i = 0; i < urlConfig.length; i++) {\n        // Options can be either strings or objects with nonempty "id" properties\n        var option = QUnit.config.urlConfig[i];\n        if (typeof option !== \'string\') {\n          option = option.id;\n        }\n        if (QUnit.config[option] === undefined) {\n          QUnit.config[option] = urlParams[option];\n        }\n      }\n    });\n    function getUrlParams() {\n      var urlParams = Object.create(null);\n      var params = location.search.slice(1).split(\'&\');\n      var length = params.length;\n      for (var i = 0; i < length; i++) {\n        if (params[i]) {\n          var param = params[i].split(\'=\');\n          var name = decodeQueryParam(param[0]);\n\n          // Allow just a key to turn on a flag, e.g., test.html?noglobals\n          var value = param.length === 1 || decodeQueryParam(param.slice(1).join(\'=\'));\n          if (name in urlParams) {\n            urlParams[name] = [].concat(urlParams[name], value);\n          } else {\n            urlParams[name] = value;\n          }\n        }\n      }\n      return urlParams;\n    }\n    function decodeQueryParam(param) {\n      return decodeURIComponent(param.replace(/\\+/g, \'%20\'));\n    }\n  })();\n\n  var fuzzysort$1 = {exports: {}};\n\n  (function (module) {\n    (function (root, UMD) {\n      if (module.exports) module.exports = UMD();else root.fuzzysort = UMD();\n    })(commonjsGlobal, function UMD() {\n      function fuzzysortNew(instanceOptions) {\n        var fuzzysort = {\n          single: function single(search, target, options) {\n            if (search == \'farzher\') return {\n              target: "farzher was here (^-^*)/",\n              score: 0,\n              indexes: [0, 1, 2, 3, 4, 5, 6]\n            };\n            if (!search) return null;\n            if (!isObj(search)) search = fuzzysort.getPreparedSearch(search);\n            if (!target) return null;\n            if (!isObj(target)) target = fuzzysort.getPrepared(target);\n            var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n            var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n            return algorithm(search, target, search[0]);\n          },\n          go: function go(search, targets, options) {\n            if (search == \'farzher\') return [{\n              target: "farzher was here (^-^*)/",\n              score: 0,\n              indexes: [0, 1, 2, 3, 4, 5, 6],\n              obj: targets ? targets[0] : null\n            }];\n            if (!search) return noResults;\n            search = fuzzysort.prepareSearch(search);\n            var searchLowerCode = search[0];\n            var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n            var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n            var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n            var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n            var resultsLen = 0;\n            var limitedCount = 0;\n            var targetsLen = targets.length;\n\n            // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n\n            // options.keys\n            if (options && options.keys) {\n              var scoreFn = options.scoreFn || defaultScoreFn;\n              var keys = options.keys;\n              var keysLen = keys.length;\n              for (var i = targetsLen - 1; i >= 0; --i) {\n                var obj = targets[i];\n                var objResults = new Array(keysLen);\n                for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n                  var key = keys[keyI];\n                  var target = getValue(obj, key);\n                  if (!target) {\n                    objResults[keyI] = null;\n                    continue;\n                  }\n                  if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                  objResults[keyI] = algorithm(search, target, searchLowerCode);\n                }\n                objResults.obj = obj; // before scoreFn so scoreFn can use it\n                var score = scoreFn(objResults);\n                if (score === null) continue;\n                if (score < threshold) continue;\n                objResults.score = score;\n                if (resultsLen < limit) {\n                  q.add(objResults);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (score > q.peek().score) q.replaceTop(objResults);\n                }\n              }\n\n              // options.key\n            } else if (options && options.key) {\n              var key = options.key;\n              for (var i = targetsLen - 1; i >= 0; --i) {\n                var obj = targets[i];\n                var target = getValue(obj, key);\n                if (!target) continue;\n                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                var result = algorithm(search, target, searchLowerCode);\n                if (result === null) continue;\n                if (result.score < threshold) continue;\n\n                // have to clone result so duplicate targets from different obj can each reference the correct obj\n                result = {\n                  target: result.target,\n                  _targetLowerCodes: null,\n                  _nextBeginningIndexes: null,\n                  score: result.score,\n                  indexes: result.indexes,\n                  obj: obj\n                }; // hidden\n\n                if (resultsLen < limit) {\n                  q.add(result);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (result.score > q.peek().score) q.replaceTop(result);\n                }\n              }\n\n              // no keys\n            } else {\n              for (var i = targetsLen - 1; i >= 0; --i) {\n                var target = targets[i];\n                if (!target) continue;\n                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                var result = algorithm(search, target, searchLowerCode);\n                if (result === null) continue;\n                if (result.score < threshold) continue;\n                if (resultsLen < limit) {\n                  q.add(result);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (result.score > q.peek().score) q.replaceTop(result);\n                }\n              }\n            }\n            if (resultsLen === 0) return noResults;\n            var results = new Array(resultsLen);\n            for (var i = resultsLen - 1; i >= 0; --i) {\n              results[i] = q.poll();\n            }\n            results.total = resultsLen + limitedCount;\n            return results;\n          },\n          goAsync: function goAsync(search, targets, options) {\n            var canceled = false;\n            var p = new Promise(function (resolve, reject) {\n              if (search == \'farzher\') return resolve([{\n                target: "farzher was here (^-^*)/",\n                score: 0,\n                indexes: [0, 1, 2, 3, 4, 5, 6],\n                obj: targets ? targets[0] : null\n              }]);\n              if (!search) return resolve(noResults);\n              search = fuzzysort.prepareSearch(search);\n              var searchLowerCode = search[0];\n              var q = fastpriorityqueue();\n              var iCurrent = targets.length - 1;\n              var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n              var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n              var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n              var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n              var resultsLen = 0;\n              var limitedCount = 0;\n              function step() {\n                if (canceled) return reject(\'canceled\');\n                var startMs = Date.now();\n\n                // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n\n                // options.keys\n                if (options && options.keys) {\n                  var scoreFn = options.scoreFn || defaultScoreFn;\n                  var keys = options.keys;\n                  var keysLen = keys.length;\n                  for (; iCurrent >= 0; --iCurrent) {\n                    if (iCurrent % 1000 /*itemsPerCheck*/ === 0) {\n                      if (Date.now() - startMs >= 10 /*asyncInterval*/) {\n                        isNode ? setImmediate(step) : setTimeout(step);\n                        return;\n                      }\n                    }\n                    var obj = targets[iCurrent];\n                    var objResults = new Array(keysLen);\n                    for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n                      var key = keys[keyI];\n                      var target = getValue(obj, key);\n                      if (!target) {\n                        objResults[keyI] = null;\n                        continue;\n                      }\n                      if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                      objResults[keyI] = algorithm(search, target, searchLowerCode);\n                    }\n                    objResults.obj = obj; // before scoreFn so scoreFn can use it\n                    var score = scoreFn(objResults);\n                    if (score === null) continue;\n                    if (score < threshold) continue;\n                    objResults.score = score;\n                    if (resultsLen < limit) {\n                      q.add(objResults);\n                      ++resultsLen;\n                    } else {\n                      ++limitedCount;\n                      if (score > q.peek().score) q.replaceTop(objResults);\n                    }\n                  }\n\n                  // options.key\n                } else if (options && options.key) {\n                  var key = options.key;\n                  for (; iCurrent >= 0; --iCurrent) {\n                    if (iCurrent % 1000 /*itemsPerCheck*/ === 0) {\n                      if (Date.now() - startMs >= 10 /*asyncInterval*/) {\n                        isNode ? setImmediate(step) : setTimeout(step);\n                        return;\n                      }\n                    }\n                    var obj = targets[iCurrent];\n                    var target = getValue(obj, key);\n                    if (!target) continue;\n                    if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                    var result = algorithm(search, target, searchLowerCode);\n                    if (result === null) continue;\n                    if (result.score < threshold) continue;\n\n                    // have to clone result so duplicate targets from different obj can each reference the correct obj\n                    result = {\n                      target: result.target,\n                      _targetLowerCodes: null,\n                      _nextBeginningIndexes: null,\n                      score: result.score,\n                      indexes: result.indexes,\n                      obj: obj\n                    }; // hidden\n\n                    if (resultsLen < limit) {\n                      q.add(result);\n                      ++resultsLen;\n                    } else {\n                      ++limitedCount;\n                      if (result.score > q.peek().score) q.replaceTop(result);\n                    }\n                  }\n\n                  // no keys\n                } else {\n                  for (; iCurrent >= 0; --iCurrent) {\n                    if (iCurrent % 1000 /*itemsPerCheck*/ === 0) {\n                      if (Date.now() - startMs >= 10 /*asyncInterval*/) {\n                        isNode ? setImmediate(step) : setTimeout(step);\n                        return;\n                      }\n                    }\n                    var target = targets[iCurrent];\n                    if (!target) continue;\n                    if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                    var result = algorithm(search, target, searchLowerCode);\n                    if (result === null) continue;\n                    if (result.score < threshold) continue;\n                    if (resultsLen < limit) {\n                      q.add(result);\n                      ++resultsLen;\n                    } else {\n                      ++limitedCount;\n                      if (result.score > q.peek().score) q.replaceTop(result);\n                    }\n                  }\n                }\n                if (resultsLen === 0) return resolve(noResults);\n                var results = new Array(resultsLen);\n                for (var i = resultsLen - 1; i >= 0; --i) {\n                  results[i] = q.poll();\n                }\n                results.total = resultsLen + limitedCount;\n                resolve(results);\n              }\n              isNode ? setImmediate(step) : step(); //setTimeout here is too slow\n            });\n\n            p.cancel = function () {\n              canceled = true;\n            };\n            return p;\n          },\n          highlight: function highlight(result, hOpen, hClose) {\n            if (typeof hOpen == \'function\') return fuzzysort.highlightCallback(result, hOpen);\n            if (result === null) return null;\n            if (hOpen === undefined) hOpen = \'<b>\';\n            if (hClose === undefined) hClose = \'</b>\';\n            var highlighted = \'\';\n            var matchesIndex = 0;\n            var opened = false;\n            var target = result.target;\n            var targetLen = target.length;\n            var matchesBest = result.indexes;\n            for (var i = 0; i < targetLen; ++i) {\n              var char = target[i];\n              if (matchesBest[matchesIndex] === i) {\n                ++matchesIndex;\n                if (!opened) {\n                  opened = true;\n                  highlighted += hOpen;\n                }\n                if (matchesIndex === matchesBest.length) {\n                  highlighted += char + hClose + target.substr(i + 1);\n                  break;\n                }\n              } else {\n                if (opened) {\n                  opened = false;\n                  highlighted += hClose;\n                }\n              }\n              highlighted += char;\n            }\n            return highlighted;\n          },\n          highlightCallback: function highlightCallback(result, cb) {\n            if (result === null) return null;\n            var target = result.target;\n            var targetLen = target.length;\n            var indexes = result.indexes;\n            var highlighted = \'\';\n            var matchI = 0;\n            var indexesI = 0;\n            var opened = false;\n            var result = [];\n            for (var i = 0; i < targetLen; ++i) {\n              var char = target[i];\n              if (indexes[indexesI] === i) {\n                ++indexesI;\n                if (!opened) {\n                  opened = true;\n                  result.push(highlighted);\n                  highlighted = \'\';\n                }\n                if (indexesI === indexes.length) {\n                  highlighted += char;\n                  result.push(cb(highlighted, matchI++));\n                  highlighted = \'\';\n                  result.push(target.substr(i + 1));\n                  break;\n                }\n              } else {\n                if (opened) {\n                  opened = false;\n                  result.push(cb(highlighted, matchI++));\n                  highlighted = \'\';\n                }\n              }\n              highlighted += char;\n            }\n            return result;\n          },\n          prepare: function prepare(target) {\n            if (!target) return {\n              target: \'\',\n              _targetLowerCodes: [0 /*this 0 doesn\'t make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/],\n              _nextBeginningIndexes: null,\n              score: null,\n              indexes: null,\n              obj: null\n            }; // hidden\n            return {\n              target: target,\n              _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n              _nextBeginningIndexes: null,\n              score: null,\n              indexes: null,\n              obj: null\n            }; // hidden\n          },\n\n          prepareSlow: function prepareSlow(target) {\n            if (!target) return {\n              target: \'\',\n              _targetLowerCodes: [0 /*this 0 doesn\'t make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/],\n              _nextBeginningIndexes: null,\n              score: null,\n              indexes: null,\n              obj: null\n            }; // hidden\n            return {\n              target: target,\n              _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n              _nextBeginningIndexes: fuzzysort.prepareNextBeginningIndexes(target),\n              score: null,\n              indexes: null,\n              obj: null\n            }; // hidden\n          },\n\n          prepareSearch: function prepareSearch(search) {\n            if (!search) search = \'\';\n            return fuzzysort.prepareLowerCodes(search);\n          },\n          // Below this point is only internal code\n          // Below this point is only internal code\n          // Below this point is only internal code\n          // Below this point is only internal code\n\n          getPrepared: function getPrepared(target) {\n            if (target.length > 999) return fuzzysort.prepare(target); // don\'t cache huge targets\n            var targetPrepared = preparedCache.get(target);\n            if (targetPrepared !== undefined) return targetPrepared;\n            targetPrepared = fuzzysort.prepare(target);\n            preparedCache.set(target, targetPrepared);\n            return targetPrepared;\n          },\n          getPreparedSearch: function getPreparedSearch(search) {\n            if (search.length > 999) return fuzzysort.prepareSearch(search); // don\'t cache huge searches\n            var searchPrepared = preparedSearchCache.get(search);\n            if (searchPrepared !== undefined) return searchPrepared;\n            searchPrepared = fuzzysort.prepareSearch(search);\n            preparedSearchCache.set(search, searchPrepared);\n            return searchPrepared;\n          },\n          algorithm: function algorithm(searchLowerCodes, prepared, searchLowerCode) {\n            var targetLowerCodes = prepared._targetLowerCodes;\n            var searchLen = searchLowerCodes.length;\n            var targetLen = targetLowerCodes.length;\n            var searchI = 0; // where we at\n            var targetI = 0; // where you at\n            var typoSimpleI = 0;\n            var matchesSimpleLen = 0;\n\n            // very basic fuzzy match; to remove non-matching targets ASAP!\n            // walk through target. find sequential matches.\n            // if all chars aren\'t found then exit\n            for (;;) {\n              var isMatch = searchLowerCode === targetLowerCodes[targetI];\n              if (isMatch) {\n                matchesSimple[matchesSimpleLen++] = targetI;\n                ++searchI;\n                if (searchI === searchLen) break;\n                searchLowerCode = searchLowerCodes[typoSimpleI === 0 ? searchI : typoSimpleI === searchI ? searchI + 1 : typoSimpleI === searchI - 1 ? searchI - 1 : searchI];\n              }\n              ++targetI;\n              if (targetI >= targetLen) {\n                // Failed to find searchI\n                // Check for typo or exit\n                // we go as far as possible before trying to transpose\n                // then we transpose backwards until we reach the beginning\n                for (;;) {\n                  if (searchI <= 1) return null; // not allowed to transpose first char\n                  if (typoSimpleI === 0) {\n                    // we haven\'t tried to transpose yet\n                    --searchI;\n                    var searchLowerCodeNew = searchLowerCodes[searchI];\n                    if (searchLowerCode === searchLowerCodeNew) continue; // doesn\'t make sense to transpose a repeat char\n                    typoSimpleI = searchI;\n                  } else {\n                    if (typoSimpleI === 1) return null; // reached the end of the line for transposing\n                    --typoSimpleI;\n                    searchI = typoSimpleI;\n                    searchLowerCode = searchLowerCodes[searchI + 1];\n                    var searchLowerCodeNew = searchLowerCodes[searchI];\n                    if (searchLowerCode === searchLowerCodeNew) continue; // doesn\'t make sense to transpose a repeat char\n                  }\n\n                  matchesSimpleLen = searchI;\n                  targetI = matchesSimple[matchesSimpleLen - 1] + 1;\n                  break;\n                }\n              }\n            }\n            var searchI = 0;\n            var typoStrictI = 0;\n            var successStrict = false;\n            var matchesStrictLen = 0;\n            var nextBeginningIndexes = prepared._nextBeginningIndexes;\n            if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n            var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];\n\n            // Our target string successfully matched all characters in sequence!\n            // Let\'s try a more advanced and strict test to improve the score\n            // only count it as a match if it\'s consecutive or a beginning character!\n            if (targetI !== targetLen) for (;;) {\n              if (targetI >= targetLen) {\n                // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n                if (searchI <= 0) {\n                  // We failed to push chars forward for a better match\n                  // transpose, starting from the beginning\n                  ++typoStrictI;\n                  if (typoStrictI > searchLen - 2) break;\n                  if (searchLowerCodes[typoStrictI] === searchLowerCodes[typoStrictI + 1]) continue; // doesn\'t make sense to transpose a repeat char\n                  targetI = firstPossibleI;\n                  continue;\n                }\n                --searchI;\n                var lastMatch = matchesStrict[--matchesStrictLen];\n                targetI = nextBeginningIndexes[lastMatch];\n              } else {\n                var isMatch = searchLowerCodes[typoStrictI === 0 ? searchI : typoStrictI === searchI ? searchI + 1 : typoStrictI === searchI - 1 ? searchI - 1 : searchI] === targetLowerCodes[targetI];\n                if (isMatch) {\n                  matchesStrict[matchesStrictLen++] = targetI;\n                  ++searchI;\n                  if (searchI === searchLen) {\n                    successStrict = true;\n                    break;\n                  }\n                  ++targetI;\n                } else {\n                  targetI = nextBeginningIndexes[targetI];\n                }\n              }\n            }\n            {\n              // tally up the score & keep track of matches for highlighting later\n              if (successStrict) {\n                var matchesBest = matchesStrict;\n                var matchesBestLen = matchesStrictLen;\n              } else {\n                var matchesBest = matchesSimple;\n                var matchesBestLen = matchesSimpleLen;\n              }\n              var score = 0;\n              var lastTargetI = -1;\n              for (var i = 0; i < searchLen; ++i) {\n                var targetI = matchesBest[i];\n                // score only goes down if they\'re not consecutive\n                if (lastTargetI !== targetI - 1) score -= targetI;\n                lastTargetI = targetI;\n              }\n              if (!successStrict) {\n                score *= 1000;\n                if (typoSimpleI !== 0) score += -20; /*typoPenalty*/\n              } else {\n                if (typoStrictI !== 0) score += -20; /*typoPenalty*/\n              }\n\n              score -= targetLen - searchLen;\n              prepared.score = score;\n              prepared.indexes = new Array(matchesBestLen);\n              for (var i = matchesBestLen - 1; i >= 0; --i) {\n                prepared.indexes[i] = matchesBest[i];\n              }\n              return prepared;\n            }\n          },\n          algorithmNoTypo: function algorithmNoTypo(searchLowerCodes, prepared, searchLowerCode) {\n            var targetLowerCodes = prepared._targetLowerCodes;\n            var searchLen = searchLowerCodes.length;\n            var targetLen = targetLowerCodes.length;\n            var searchI = 0; // where we at\n            var targetI = 0; // where you at\n            var matchesSimpleLen = 0;\n\n            // very basic fuzzy match; to remove non-matching targets ASAP!\n            // walk through target. find sequential matches.\n            // if all chars aren\'t found then exit\n            for (;;) {\n              var isMatch = searchLowerCode === targetLowerCodes[targetI];\n              if (isMatch) {\n                matchesSimple[matchesSimpleLen++] = targetI;\n                ++searchI;\n                if (searchI === searchLen) break;\n                searchLowerCode = searchLowerCodes[searchI];\n              }\n              ++targetI;\n              if (targetI >= targetLen) return null; // Failed to find searchI\n            }\n\n            var searchI = 0;\n            var successStrict = false;\n            var matchesStrictLen = 0;\n            var nextBeginningIndexes = prepared._nextBeginningIndexes;\n            if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n            targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];\n\n            // Our target string successfully matched all characters in sequence!\n            // Let\'s try a more advanced and strict test to improve the score\n            // only count it as a match if it\'s consecutive or a beginning character!\n            if (targetI !== targetLen) for (;;) {\n              if (targetI >= targetLen) {\n                // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n                if (searchI <= 0) break; // We failed to push chars forward for a better match\n\n                --searchI;\n                var lastMatch = matchesStrict[--matchesStrictLen];\n                targetI = nextBeginningIndexes[lastMatch];\n              } else {\n                var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];\n                if (isMatch) {\n                  matchesStrict[matchesStrictLen++] = targetI;\n                  ++searchI;\n                  if (searchI === searchLen) {\n                    successStrict = true;\n                    break;\n                  }\n                  ++targetI;\n                } else {\n                  targetI = nextBeginningIndexes[targetI];\n                }\n              }\n            }\n            {\n              // tally up the score & keep track of matches for highlighting later\n              if (successStrict) {\n                var matchesBest = matchesStrict;\n                var matchesBestLen = matchesStrictLen;\n              } else {\n                var matchesBest = matchesSimple;\n                var matchesBestLen = matchesSimpleLen;\n              }\n              var score = 0;\n              var lastTargetI = -1;\n              for (var i = 0; i < searchLen; ++i) {\n                var targetI = matchesBest[i];\n                // score only goes down if they\'re not consecutive\n                if (lastTargetI !== targetI - 1) score -= targetI;\n                lastTargetI = targetI;\n              }\n              if (!successStrict) score *= 1000;\n              score -= targetLen - searchLen;\n              prepared.score = score;\n              prepared.indexes = new Array(matchesBestLen);\n              for (var i = matchesBestLen - 1; i >= 0; --i) {\n                prepared.indexes[i] = matchesBest[i];\n              }\n              return prepared;\n            }\n          },\n          prepareLowerCodes: function prepareLowerCodes(str) {\n            var strLen = str.length;\n            var lowerCodes = []; // new Array(strLen)    sparse array is too slow\n            var lower = str.toLowerCase();\n            for (var i = 0; i < strLen; ++i) {\n              lowerCodes[i] = lower.charCodeAt(i);\n            }\n            return lowerCodes;\n          },\n          prepareBeginningIndexes: function prepareBeginningIndexes(target) {\n            var targetLen = target.length;\n            var beginningIndexes = [];\n            var beginningIndexesLen = 0;\n            var wasUpper = false;\n            var wasAlphanum = false;\n            for (var i = 0; i < targetLen; ++i) {\n              var targetCode = target.charCodeAt(i);\n              var isUpper = targetCode >= 65 && targetCode <= 90;\n              var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;\n              var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;\n              wasUpper = isUpper;\n              wasAlphanum = isAlphanum;\n              if (isBeginning) beginningIndexes[beginningIndexesLen++] = i;\n            }\n            return beginningIndexes;\n          },\n          prepareNextBeginningIndexes: function prepareNextBeginningIndexes(target) {\n            var targetLen = target.length;\n            var beginningIndexes = fuzzysort.prepareBeginningIndexes(target);\n            var nextBeginningIndexes = []; // new Array(targetLen)     sparse array is too slow\n            var lastIsBeginning = beginningIndexes[0];\n            var lastIsBeginningI = 0;\n            for (var i = 0; i < targetLen; ++i) {\n              if (lastIsBeginning > i) {\n                nextBeginningIndexes[i] = lastIsBeginning;\n              } else {\n                lastIsBeginning = beginningIndexes[++lastIsBeginningI];\n                nextBeginningIndexes[i] = lastIsBeginning === undefined ? targetLen : lastIsBeginning;\n              }\n            }\n            return nextBeginningIndexes;\n          },\n          cleanup: cleanup,\n          new: fuzzysortNew\n        };\n        return fuzzysort;\n      } // fuzzysortNew\n\n      // This stuff is outside fuzzysortNew, because it\'s shared with instances of fuzzysort.new()\n      var isNode = typeof commonjsRequire !== \'undefined\' && typeof window === \'undefined\';\n      var MyMap = typeof Map === \'function\' ? Map : function () {\n        var s = Object.create(null);\n        this.get = function (k) {\n          return s[k];\n        };\n        this.set = function (k, val) {\n          s[k] = val;\n          return this;\n        };\n        this.clear = function () {\n          s = Object.create(null);\n        };\n      };\n      var preparedCache = new MyMap();\n      var preparedSearchCache = new MyMap();\n      var noResults = [];\n      noResults.total = 0;\n      var matchesSimple = [];\n      var matchesStrict = [];\n      function cleanup() {\n        preparedCache.clear();\n        preparedSearchCache.clear();\n        matchesSimple = [];\n        matchesStrict = [];\n      }\n      function defaultScoreFn(a) {\n        var max = -9007199254740991;\n        for (var i = a.length - 1; i >= 0; --i) {\n          var result = a[i];\n          if (result === null) continue;\n          var score = result.score;\n          if (score > max) max = score;\n        }\n        if (max === -9007199254740991) return null;\n        return max;\n      }\n\n      // prop = \'key\'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\n      // prop = \'key1.key2\'        10ms\n      // prop = [\'key1\', \'key2\']   27ms\n      function getValue(obj, prop) {\n        var tmp = obj[prop];\n        if (tmp !== undefined) return tmp;\n        var segs = prop;\n        if (!Array.isArray(prop)) segs = prop.split(\'.\');\n        var len = segs.length;\n        var i = -1;\n        while (obj && ++i < len) {\n          obj = obj[segs[i]];\n        }\n        return obj;\n      }\n      function isObj(x) {\n        return _typeof(x) === \'object\';\n      } // faster as a function\n\n      // Hacked version of https://github.com/lemire/FastPriorityQueue.js\n      var fastpriorityqueue = function fastpriorityqueue() {\n        var r = [],\n          o = 0,\n          e = {};\n        function n() {\n          for (var e = 0, n = r[e], c = 1; c < o;) {\n            var f = c + 1;\n            e = c, f < o && r[f].score < r[c].score && (e = f), r[e - 1 >> 1] = r[e], c = 1 + (e << 1);\n          }\n          for (var a = e - 1 >> 1; e > 0 && n.score < r[a].score; a = (e = a) - 1 >> 1) {\n            r[e] = r[a];\n          }\n          r[e] = n;\n        }\n        return e.add = function (e) {\n          var n = o;\n          r[o++] = e;\n          for (var c = n - 1 >> 1; n > 0 && e.score < r[c].score; c = (n = c) - 1 >> 1) {\n            r[n] = r[c];\n          }\n          r[n] = e;\n        }, e.poll = function () {\n          if (0 !== o) {\n            var e = r[0];\n            return r[0] = r[--o], n(), e;\n          }\n        }, e.peek = function (e) {\n          if (0 !== o) return r[0];\n        }, e.replaceTop = function (o) {\n          r[0] = o, n();\n        }, e;\n      };\n      var q = fastpriorityqueue(); // reuse this, except for async, it needs to make its own\n\n      return fuzzysortNew();\n    }); // UMD\n\n    // TODO: (performance) wasm version!?\n    // TODO: (performance) threads?\n    // TODO: (performance) avoid cache misses\n    // TODO: (performance) preparedCache is a memory leak\n    // TODO: (like sublime) backslash === forwardslash\n    // TODO: (like sublime) spaces: "a b" should do 2 searches 1 for a and 1 for b\n    // TODO: (scoring) garbage in targets that allows most searches to strict match need a penality\n    // TODO: (performance) idk if allowTypo is optimized\n  })(fuzzysort$1);\n  var fuzzysort = fuzzysort$1.exports;\n\n  var stats = {\n    failedTests: [],\n    defined: 0,\n    completed: 0\n  };\n\n  // Escape text for attribute or text content.\n  function escapeText(str) {\n    if (!str) {\n      return \'\';\n    }\n\n    // Both single quotes and double quotes (for attributes)\n    return (\'\' + str).replace(/[\'"<>&]/g, function (s) {\n      switch (s) {\n        case "\'":\n          return \'&#039;\';\n        case \'"\':\n          return \'&quot;\';\n        case \'<\':\n          return \'&lt;\';\n        case \'>\':\n          return \'&gt;\';\n        case \'&\':\n          return \'&amp;\';\n      }\n    });\n  }\n  (function () {\n    // Don\'t load the HTML Reporter on non-browser environments\n    if (!window$1 || !document) {\n      return;\n    }\n    var config = QUnit.config;\n    var hiddenTests = [];\n    var collapseNext = false;\n    var hasOwn = Object.prototype.hasOwnProperty;\n    var unfilteredUrl = setUrl({\n      filter: undefined,\n      module: undefined,\n      moduleId: undefined,\n      testId: undefined\n    });\n    var dropdownData = null;\n    function trim(string) {\n      if (typeof string.trim === \'function\') {\n        return string.trim();\n      } else {\n        return string.replace(/^\\s+|\\s+$/g, \'\');\n      }\n    }\n    function addEvent(elem, type, fn) {\n      elem.addEventListener(type, fn, false);\n    }\n    function removeEvent(elem, type, fn) {\n      elem.removeEventListener(type, fn, false);\n    }\n    function addEvents(elems, type, fn) {\n      var i = elems.length;\n      while (i--) {\n        addEvent(elems[i], type, fn);\n      }\n    }\n    function hasClass(elem, name) {\n      return (\' \' + elem.className + \' \').indexOf(\' \' + name + \' \') >= 0;\n    }\n    function addClass(elem, name) {\n      if (!hasClass(elem, name)) {\n        elem.className += (elem.className ? \' \' : \'\') + name;\n      }\n    }\n    function toggleClass(elem, name, force) {\n      if (force || typeof force === \'undefined\' && !hasClass(elem, name)) {\n        addClass(elem, name);\n      } else {\n        removeClass(elem, name);\n      }\n    }\n    function removeClass(elem, name) {\n      var set = \' \' + elem.className + \' \';\n\n      // Class name may appear multiple times\n      while (set.indexOf(\' \' + name + \' \') >= 0) {\n        set = set.replace(\' \' + name + \' \', \' \');\n      }\n\n      // Trim for prettiness\n      elem.className = trim(set);\n    }\n    function id(name) {\n      return document.getElementById && document.getElementById(name);\n    }\n    function abortTests() {\n      var abortButton = id(\'qunit-abort-tests-button\');\n      if (abortButton) {\n        abortButton.disabled = true;\n        abortButton.innerHTML = \'Aborting...\';\n      }\n      QUnit.config.queue.length = 0;\n      return false;\n    }\n    function interceptNavigation(ev) {\n      // Trim potential accidental whitespace so that QUnit doesn\'t throw an error about no tests matching the filter.\n      var filterInputElem = id(\'qunit-filter-input\');\n      filterInputElem.value = trim(filterInputElem.value);\n      applyUrlParams();\n      if (ev && ev.preventDefault) {\n        ev.preventDefault();\n      }\n      return false;\n    }\n    function getUrlConfigHtml() {\n      var selection = false;\n      var urlConfig = config.urlConfig;\n      var urlConfigHtml = \'\';\n      for (var i = 0; i < urlConfig.length; i++) {\n        // Options can be either strings or objects with nonempty "id" properties\n        var val = config.urlConfig[i];\n        if (typeof val === \'string\') {\n          val = {\n            id: val,\n            label: val\n          };\n        }\n        var escaped = escapeText(val.id);\n        var escapedTooltip = escapeText(val.tooltip);\n        if (!val.value || typeof val.value === \'string\') {\n          urlConfigHtml += "<label for=\'qunit-urlconfig-" + escaped + "\' title=\'" + escapedTooltip + "\'><input id=\'qunit-urlconfig-" + escaped + "\' name=\'" + escaped + "\' type=\'checkbox\'" + (val.value ? " value=\'" + escapeText(val.value) + "\'" : \'\') + (config[val.id] ? " checked=\'checked\'" : \'\') + " title=\'" + escapedTooltip + "\' />" + escapeText(val.label) + \'</label>\';\n        } else {\n          urlConfigHtml += "<label for=\'qunit-urlconfig-" + escaped + "\' title=\'" + escapedTooltip + "\'>" + val.label + ": </label><select id=\'qunit-urlconfig-" + escaped + "\' name=\'" + escaped + "\' title=\'" + escapedTooltip + "\'><option></option>";\n          if (Array.isArray(val.value)) {\n            for (var j = 0; j < val.value.length; j++) {\n              escaped = escapeText(val.value[j]);\n              urlConfigHtml += "<option value=\'" + escaped + "\'" + (config[val.id] === val.value[j] ? (selection = true) && " selected=\'selected\'" : \'\') + \'>\' + escaped + \'</option>\';\n            }\n          } else {\n            for (var _j in val.value) {\n              if (hasOwn.call(val.value, _j)) {\n                urlConfigHtml += "<option value=\'" + escapeText(_j) + "\'" + (config[val.id] === _j ? (selection = true) && " selected=\'selected\'" : \'\') + \'>\' + escapeText(val.value[_j]) + \'</option>\';\n              }\n            }\n          }\n          if (config[val.id] && !selection) {\n            escaped = escapeText(config[val.id]);\n            urlConfigHtml += "<option value=\'" + escaped + "\' selected=\'selected\' disabled=\'disabled\'>" + escaped + \'</option>\';\n          }\n          urlConfigHtml += \'</select>\';\n        }\n      }\n      return urlConfigHtml;\n    }\n\n    // Handle "click" events on toolbar checkboxes and "change" for select menus.\n    // Updates the URL with the new state of `config.urlConfig` values.\n    function toolbarChanged() {\n      var field = this;\n      var params = {};\n\n      // Detect if field is a select menu or a checkbox\n      var value;\n      if (\'selectedIndex\' in field) {\n        value = field.options[field.selectedIndex].value || undefined;\n      } else {\n        value = field.checked ? field.defaultValue || true : undefined;\n      }\n      params[field.name] = value;\n      var updatedUrl = setUrl(params);\n\n      // Check if we can apply the change without a page refresh\n      if (field.name === \'hidepassed\' && \'replaceState\' in window$1.history) {\n        QUnit.urlParams[field.name] = value;\n        config[field.name] = value || false;\n        var tests = id(\'qunit-tests\');\n        if (tests) {\n          var length = tests.children.length;\n          var children = tests.children;\n          if (field.checked) {\n            for (var i = 0; i < length; i++) {\n              var test = children[i];\n              var className = test ? test.className : \'\';\n              var classNameHasPass = className.indexOf(\'pass\') > -1;\n              var classNameHasSkipped = className.indexOf(\'skipped\') > -1;\n              if (classNameHasPass || classNameHasSkipped) {\n                hiddenTests.push(test);\n              }\n            }\n            var _iterator = _createForOfIteratorHelper(hiddenTests),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var hiddenTest = _step.value;\n                tests.removeChild(hiddenTest);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          } else {\n            var _test;\n            while ((_test = hiddenTests.pop()) != null) {\n              tests.appendChild(_test);\n            }\n          }\n        }\n        window$1.history.replaceState(null, \'\', updatedUrl);\n      } else {\n        window$1.location = updatedUrl;\n      }\n    }\n    function setUrl(params) {\n      var querystring = \'?\';\n      var location = window$1.location;\n      params = extend(extend({}, QUnit.urlParams), params);\n      for (var key in params) {\n        // Skip inherited or undefined properties\n        if (hasOwn.call(params, key) && params[key] !== undefined) {\n          // Output a parameter for each value of this key\n          // (but usually just one)\n          var arrValue = [].concat(params[key]);\n          for (var i = 0; i < arrValue.length; i++) {\n            querystring += encodeURIComponent(key);\n            if (arrValue[i] !== true) {\n              querystring += \'=\' + encodeURIComponent(arrValue[i]);\n            }\n            querystring += \'&\';\n          }\n        }\n      }\n      return location.protocol + \'//\' + location.host + location.pathname + querystring.slice(0, -1);\n    }\n    function applyUrlParams() {\n      var filter = id(\'qunit-filter-input\').value;\n      window$1.location = setUrl({\n        filter: filter === \'\' ? undefined : filter,\n        moduleId: _toConsumableArray(dropdownData.selectedMap.keys()),\n        // Remove module and testId filter\n        module: undefined,\n        testId: undefined\n      });\n    }\n    function toolbarUrlConfigContainer() {\n      var urlConfigContainer = document.createElement(\'span\');\n      urlConfigContainer.innerHTML = getUrlConfigHtml();\n      addClass(urlConfigContainer, \'qunit-url-config\');\n      addEvents(urlConfigContainer.getElementsByTagName(\'input\'), \'change\', toolbarChanged);\n      addEvents(urlConfigContainer.getElementsByTagName(\'select\'), \'change\', toolbarChanged);\n      return urlConfigContainer;\n    }\n    function abortTestsButton() {\n      var button = document.createElement(\'button\');\n      button.id = \'qunit-abort-tests-button\';\n      button.innerHTML = \'Abort\';\n      addEvent(button, \'click\', abortTests);\n      return button;\n    }\n    function toolbarLooseFilter() {\n      var filter = document.createElement(\'form\');\n      var label = document.createElement(\'label\');\n      var input = document.createElement(\'input\');\n      var button = document.createElement(\'button\');\n      addClass(filter, \'qunit-filter\');\n      label.innerHTML = \'Filter: \';\n      input.type = \'text\';\n      input.value = config.filter || \'\';\n      input.name = \'filter\';\n      input.id = \'qunit-filter-input\';\n      button.innerHTML = \'Go\';\n      label.appendChild(input);\n      filter.appendChild(label);\n      filter.appendChild(document.createTextNode(\' \'));\n      filter.appendChild(button);\n      addEvent(filter, \'submit\', interceptNavigation);\n      return filter;\n    }\n    function createModuleListItem(moduleId, name, checked) {\n      return \'<li><label class="clickable\' + (checked ? \' checked\' : \'\') + \'"><input type="checkbox" \' + \'value="\' + escapeText(moduleId) + \'"\' + (checked ? \' checked="checked"\' : \'\') + \' />\' + escapeText(name) + \'</label></li>\';\n    }\n\n    /**\n     * @param {Array} Results from fuzzysort\n     * @return {string} HTML\n     */\n    function moduleListHtml(results) {\n      var html = \'\';\n\n      // Hoist the already selected items, and show them always\n      // even if not matched by the current search.\n      dropdownData.selectedMap.forEach(function (name, moduleId) {\n        html += createModuleListItem(moduleId, name, true);\n      });\n      for (var i = 0; i < results.length; i++) {\n        var mod = results[i].obj;\n        if (!dropdownData.selectedMap.has(mod.moduleId)) {\n          html += createModuleListItem(mod.moduleId, mod.name, false);\n        }\n      }\n      return html;\n    }\n    function toolbarModuleFilter(beginDetails) {\n      var initialSelected = null;\n      dropdownData = {\n        options: beginDetails.modules.slice(),\n        selectedMap: new StringMap(),\n        isDirty: function isDirty() {\n          return _toConsumableArray(dropdownData.selectedMap.keys()).sort().join(\',\') !== _toConsumableArray(initialSelected.keys()).sort().join(\',\');\n        }\n      };\n      if (config.moduleId.length) {\n        // The module dropdown is seeded with the runtime configuration of the last run.\n        //\n        // We don\'t reference `config.moduleId` directly after this and keep our own\n        // copy because:\n        // 1. This naturally filters out unknown moduleIds.\n        // 2. Gives us a place to manage and remember unsubmitted checkbox changes.\n        // 3. Gives us an efficient way to map a selected moduleId to module name\n        //    during rendering.\n        for (var i = 0; i < beginDetails.modules.length; i++) {\n          var mod = beginDetails.modules[i];\n          if (config.moduleId.indexOf(mod.moduleId) !== -1) {\n            dropdownData.selectedMap.set(mod.moduleId, mod.name);\n          }\n        }\n      }\n      initialSelected = new StringMap(dropdownData.selectedMap);\n      var moduleSearch = document.createElement(\'input\');\n      moduleSearch.id = \'qunit-modulefilter-search\';\n      moduleSearch.autocomplete = \'off\';\n      addEvent(moduleSearch, \'input\', searchInput);\n      addEvent(moduleSearch, \'input\', searchFocus);\n      addEvent(moduleSearch, \'focus\', searchFocus);\n      addEvent(moduleSearch, \'click\', searchFocus);\n      var label = document.createElement(\'label\');\n      label.htmlFor = \'qunit-modulefilter-search\';\n      label.textContent = \'Module:\';\n      var searchContainer = document.createElement(\'span\');\n      searchContainer.id = \'qunit-modulefilter-search-container\';\n      searchContainer.appendChild(moduleSearch);\n      var applyButton = document.createElement(\'button\');\n      applyButton.textContent = \'Apply\';\n      applyButton.title = \'Re-run the selected test modules\';\n      addEvent(applyButton, \'click\', applyUrlParams);\n      var resetButton = document.createElement(\'button\');\n      resetButton.textContent = \'Reset\';\n      resetButton.type = \'reset\';\n      resetButton.title = \'Restore the previous module selection\';\n      var clearButton = document.createElement(\'button\');\n      clearButton.textContent = \'Select none\';\n      clearButton.type = \'button\';\n      clearButton.title = \'Clear the current module selection\';\n      addEvent(clearButton, \'click\', function () {\n        dropdownData.selectedMap.clear();\n        selectionChange();\n        searchInput();\n      });\n      var actions = document.createElement(\'span\');\n      actions.id = \'qunit-modulefilter-actions\';\n      actions.appendChild(applyButton);\n      actions.appendChild(resetButton);\n      if (initialSelected.size) {\n        // Only show clear button if functionally different from reset\n        actions.appendChild(clearButton);\n      }\n      var dropDownList = document.createElement(\'ul\');\n      dropDownList.id = \'qunit-modulefilter-dropdown-list\';\n      var dropDown = document.createElement(\'div\');\n      dropDown.id = \'qunit-modulefilter-dropdown\';\n      dropDown.style.display = \'none\';\n      dropDown.appendChild(actions);\n      dropDown.appendChild(dropDownList);\n      addEvent(dropDown, \'change\', selectionChange);\n      searchContainer.appendChild(dropDown);\n      // Set initial moduleSearch.placeholder and clearButton/resetButton.\n      selectionChange();\n      var moduleFilter = document.createElement(\'form\');\n      moduleFilter.id = \'qunit-modulefilter\';\n      moduleFilter.appendChild(label);\n      moduleFilter.appendChild(document.createTextNode(\' \'));\n      moduleFilter.appendChild(searchContainer);\n      addEvent(moduleFilter, \'submit\', interceptNavigation);\n      addEvent(moduleFilter, \'reset\', function () {\n        dropdownData.selectedMap = new StringMap(initialSelected);\n        // Set moduleSearch.placeholder and reflect non-dirty state\n        selectionChange();\n        searchInput();\n      });\n\n      // Enables show/hide for the dropdown\n      function searchFocus() {\n        if (dropDown.style.display !== \'none\') {\n          return;\n        }\n\n        // Optimization: Defer rendering options until focussed.\n        // https://github.com/qunitjs/qunit/issues/1664\n        searchInput();\n        dropDown.style.display = \'block\';\n\n        // Hide on Escape keydown or on click outside the container\n        addEvent(document, \'click\', hideHandler);\n        addEvent(document, \'keydown\', hideHandler);\n        function hideHandler(e) {\n          var inContainer = moduleFilter.contains(e.target);\n          if (e.keyCode === 27 || !inContainer) {\n            if (e.keyCode === 27 && inContainer) {\n              moduleSearch.focus();\n            }\n            dropDown.style.display = \'none\';\n            removeEvent(document, \'click\', hideHandler);\n            removeEvent(document, \'keydown\', hideHandler);\n            moduleSearch.value = \'\';\n            searchInput();\n          }\n        }\n      }\n\n      /**\n       * @param {string} searchText\n       * @return {string} HTML\n       */\n      function filterModules(searchText) {\n        var results;\n        if (searchText === \'\') {\n          // Improve on-boarding experience by having an immediate display of\n          // module names, indicating how the interface works. This also makes\n          // for a quicker interaction in the common case of small projects.\n          // Don\'t mandate typing just to get the menu.\n          results = dropdownData.options.slice(0, 20).map(function (obj) {\n            // Fake empty results. https://github.com/farzher/fuzzysort/issues/41\n            return {\n              obj: obj\n            };\n          });\n        } else {\n          results = fuzzysort.go(searchText, dropdownData.options, {\n            limit: 20,\n            key: \'name\',\n            allowTypo: true\n          });\n        }\n        return moduleListHtml(results);\n      }\n\n      // Processes module search box input\n      var searchInputTimeout;\n      function searchInput() {\n        // Use a debounce with a ~0ms timeout. This is effectively instantaneous,\n        // but is better than undebounced because it avoids an ever-growing\n        // backlog of unprocessed now-outdated input events if fuzzysearch or\n        // drodown DOM is slow (e.g. very large test suite).\n        window$1.clearTimeout(searchInputTimeout);\n        searchInputTimeout = window$1.setTimeout(function () {\n          dropDownList.innerHTML = filterModules(moduleSearch.value);\n        });\n      }\n\n      // Processes checkbox change, or a generic render (initial render, or after reset event)\n      // Avoid any dropdown rendering here as this is used by toolbarModuleFilter()\n      // during the initial render, which should not delay test execution.\n      function selectionChange(evt) {\n        var checkbox = evt && evt.target || null;\n        if (checkbox) {\n          // Update internal state\n          if (checkbox.checked) {\n            dropdownData.selectedMap.set(checkbox.value, checkbox.parentNode.textContent);\n          } else {\n            dropdownData.selectedMap.delete(checkbox.value);\n          }\n\n          // Update UI state\n          toggleClass(checkbox.parentNode, \'checked\', checkbox.checked);\n        }\n        var textForm = dropdownData.selectedMap.size ? dropdownData.selectedMap.size + \' \' + (dropdownData.selectedMap.size === 1 ? \'module\' : \'modules\') : \'All modules\';\n        moduleSearch.placeholder = textForm;\n        moduleSearch.title = \'Type to search through and reduce the list.\';\n        resetButton.disabled = !dropdownData.isDirty();\n        clearButton.style.display = dropdownData.selectedMap.size ? \'\' : \'none\';\n      }\n      return moduleFilter;\n    }\n    function appendToolbar(beginDetails) {\n      var toolbar = id(\'qunit-testrunner-toolbar\');\n      if (toolbar) {\n        toolbar.appendChild(toolbarUrlConfigContainer());\n        var toolbarFilters = document.createElement(\'span\');\n        toolbarFilters.id = \'qunit-toolbar-filters\';\n        toolbarFilters.appendChild(toolbarLooseFilter());\n        toolbarFilters.appendChild(toolbarModuleFilter(beginDetails));\n        var clearfix = document.createElement(\'div\');\n        clearfix.className = \'clearfix\';\n        toolbar.appendChild(toolbarFilters);\n        toolbar.appendChild(clearfix);\n      }\n    }\n    function appendHeader() {\n      var header = id(\'qunit-header\');\n      if (header) {\n        header.innerHTML = "<a href=\'" + escapeText(unfilteredUrl) + "\'>" + header.innerHTML + \'</a> \';\n      }\n    }\n    function appendBanner() {\n      var banner = id(\'qunit-banner\');\n      if (banner) {\n        banner.className = \'\';\n      }\n    }\n    function appendTestResults() {\n      var tests = id(\'qunit-tests\');\n      var result = id(\'qunit-testresult\');\n      var controls;\n      if (result) {\n        result.parentNode.removeChild(result);\n      }\n      if (tests) {\n        tests.innerHTML = \'\';\n        result = document.createElement(\'p\');\n        result.id = \'qunit-testresult\';\n        result.className = \'result\';\n        tests.parentNode.insertBefore(result, tests);\n        result.innerHTML = \'<div id="qunit-testresult-display">Running...<br />&#160;</div>\' + \'<div id="qunit-testresult-controls"></div>\' + \'<div class="clearfix"></div>\';\n        controls = id(\'qunit-testresult-controls\');\n      }\n      if (controls) {\n        controls.appendChild(abortTestsButton());\n      }\n    }\n    function appendFilteredTest() {\n      var testId = QUnit.config.testId;\n      if (!testId || testId.length <= 0) {\n        return \'\';\n      }\n      return "<div id=\'qunit-filteredTest\'>Rerunning selected tests: " + escapeText(testId.join(\', \')) + " <a id=\'qunit-clearFilter\' href=\'" + escapeText(unfilteredUrl) + "\'>Run all tests</a></div>";\n    }\n    function appendUserAgent() {\n      var userAgent = id(\'qunit-userAgent\');\n      if (userAgent) {\n        userAgent.innerHTML = \'\';\n        userAgent.appendChild(document.createTextNode(\'QUnit \' + QUnit.version + \'; \' + navigator.userAgent));\n      }\n    }\n    function appendInterface(beginDetails) {\n      var qunit = id(\'qunit\');\n\n      // For compat with QUnit 1.2, and to support fully custom theme HTML,\n      // we will use any existing elements if no id="qunit" element exists.\n      //\n      // Note that we don\'t fail or fallback to creating it ourselves,\n      // because not having id="qunit" (and not having the below elements)\n      // simply means QUnit acts headless, allowing users to use their own\n      // reporters, or for a test runner to listen for events directly without\n      // having the HTML reporter actively render anything.\n      if (qunit) {\n        qunit.setAttribute(\'role\', \'main\');\n\n        // Since QUnit 1.3, these are created automatically if the page\n        // contains id="qunit".\n        qunit.innerHTML = "<h1 id=\'qunit-header\'>" + escapeText(document.title) + \'</h1>\' + "<h2 id=\'qunit-banner\'></h2>" + "<div id=\'qunit-testrunner-toolbar\' role=\'navigation\'></div>" + appendFilteredTest() + "<h2 id=\'qunit-userAgent\'></h2>" + "<ol id=\'qunit-tests\'></ol>";\n      }\n      appendHeader();\n      appendBanner();\n      appendTestResults();\n      appendUserAgent();\n      appendToolbar(beginDetails);\n    }\n    function appendTest(name, testId, moduleName) {\n      var tests = id(\'qunit-tests\');\n      if (!tests) {\n        return;\n      }\n      var title = document.createElement(\'strong\');\n      title.innerHTML = getNameHtml(name, moduleName);\n      var testBlock = document.createElement(\'li\');\n      testBlock.appendChild(title);\n\n      // No ID or rerun link for "global failure" blocks\n      if (testId !== undefined) {\n        var rerunTrigger = document.createElement(\'a\');\n        rerunTrigger.innerHTML = \'Rerun\';\n        rerunTrigger.href = setUrl({\n          testId: testId\n        });\n        testBlock.id = \'qunit-test-output-\' + testId;\n        testBlock.appendChild(rerunTrigger);\n      }\n      var assertList = document.createElement(\'ol\');\n      assertList.className = \'qunit-assert-list\';\n      testBlock.appendChild(assertList);\n      tests.appendChild(testBlock);\n      return testBlock;\n    }\n\n    // HTML Reporter initialization and load\n    QUnit.on(\'runStart\', function (runStart) {\n      stats.defined = runStart.testCounts.total;\n    });\n    QUnit.begin(function (beginDetails) {\n      // Initialize QUnit elements\n      // This is done from begin() instead of runStart, because\n      // urlparams.js uses begin(), which we need to wait for.\n      // urlparams.js in turn uses begin() to allow plugins to\n      // add entries to QUnit.config.urlConfig, which may be done\n      // asynchronously.\n      // <https://github.com/qunitjs/qunit/issues/1657>\n      appendInterface(beginDetails);\n    });\n    function getRerunFailedHtml(failedTests) {\n      if (failedTests.length === 0) {\n        return \'\';\n      }\n      var href = setUrl({\n        testId: failedTests\n      });\n      return ["<br /><a href=\'" + escapeText(href) + "\'>", failedTests.length === 1 ? \'Rerun 1 failed test\' : \'Rerun \' + failedTests.length + \' failed tests\', \'</a>\'].join(\'\');\n    }\n    QUnit.on(\'runEnd\', function (runEnd) {\n      var banner = id(\'qunit-banner\');\n      var tests = id(\'qunit-tests\');\n      var abortButton = id(\'qunit-abort-tests-button\');\n      var assertPassed = config.stats.all - config.stats.bad;\n      var html = [runEnd.testCounts.total, \' tests completed in \', runEnd.runtime, \' milliseconds, with \', runEnd.testCounts.failed, \' failed, \', runEnd.testCounts.skipped, \' skipped, and \', runEnd.testCounts.todo, \' todo.<br />\', "<span class=\'passed\'>", assertPassed, "</span> assertions of <span class=\'total\'>", config.stats.all, "</span> passed, <span class=\'failed\'>", config.stats.bad, \'</span> failed.\', getRerunFailedHtml(stats.failedTests)].join(\'\');\n      var test;\n      var assertLi;\n      var assertList;\n\n      // Update remaining tests to aborted\n      if (abortButton && abortButton.disabled) {\n        html = \'Tests aborted after \' + runEnd.runtime + \' milliseconds.\';\n        for (var i = 0; i < tests.children.length; i++) {\n          test = tests.children[i];\n          if (test.className === \'\' || test.className === \'running\') {\n            test.className = \'aborted\';\n            assertList = test.getElementsByTagName(\'ol\')[0];\n            assertLi = document.createElement(\'li\');\n            assertLi.className = \'fail\';\n            assertLi.innerHTML = \'Test aborted.\';\n            assertList.appendChild(assertLi);\n          }\n        }\n      }\n      if (banner && (!abortButton || abortButton.disabled === false)) {\n        banner.className = runEnd.status === \'failed\' ? \'qunit-fail\' : \'qunit-pass\';\n      }\n      if (abortButton) {\n        abortButton.parentNode.removeChild(abortButton);\n      }\n      if (tests) {\n        id(\'qunit-testresult-display\').innerHTML = html;\n      }\n      if (config.altertitle && document.title) {\n        // Show \u2716 for good, \u2714 for bad suite result in title\n        // use escape sequences in case file gets loaded with non-utf-8\n        // charset\n        document.title = [runEnd.status === \'failed\' ? "\\u2716" : "\\u2714", document.title.replace(/^[\\u2714\\u2716] /i, \'\')].join(\' \');\n      }\n\n      // Scroll back to top to show results\n      if (config.scrolltop && window$1.scrollTo) {\n        window$1.scrollTo(0, 0);\n      }\n    });\n    function getNameHtml(name, module) {\n      var nameHtml = \'\';\n      if (module) {\n        nameHtml = "<span class=\'module-name\'>" + escapeText(module) + \'</span>: \';\n      }\n      nameHtml += "<span class=\'test-name\'>" + escapeText(name) + \'</span>\';\n      return nameHtml;\n    }\n    function getProgressHtml(stats) {\n      return [stats.completed, \' / \', stats.defined, \' tests completed.<br />\'].join(\'\');\n    }\n    QUnit.testStart(function (details) {\n      var running, bad;\n      appendTest(details.name, details.testId, details.module);\n      running = id(\'qunit-testresult-display\');\n      if (running) {\n        addClass(running, \'running\');\n        bad = QUnit.config.reorder && details.previousFailure;\n        running.innerHTML = [getProgressHtml(stats), bad ? \'Rerunning previously failed test: <br />\' : \'Running: \', getNameHtml(details.name, details.module), getRerunFailedHtml(stats.failedTests)].join(\'\');\n      }\n    });\n    function stripHtml(string) {\n      // Strip tags, html entity and whitespaces\n      return string.replace(/<\\/?[^>]+(>|$)/g, \'\').replace(/&quot;/g, \'\').replace(/\\s+/g, \'\');\n    }\n    QUnit.log(function (details) {\n      var testItem = id(\'qunit-test-output-\' + details.testId);\n      if (!testItem) {\n        return;\n      }\n      var message = escapeText(details.message) || (details.result ? \'okay\' : \'failed\');\n      message = "<span class=\'test-message\'>" + message + \'</span>\';\n      message += "<span class=\'runtime\'>@ " + details.runtime + \' ms</span>\';\n      var expected;\n      var actual;\n      var diff;\n      var showDiff = false;\n\n      // The pushFailure doesn\'t provide details.expected\n      // when it calls, it\'s implicit to also not show expected and diff stuff\n      // Also, we need to check details.expected existence, as it can exist and be undefined\n      if (!details.result && hasOwn.call(details, \'expected\')) {\n        if (details.negative) {\n          expected = \'NOT \' + QUnit.dump.parse(details.expected);\n        } else {\n          expected = QUnit.dump.parse(details.expected);\n        }\n        actual = QUnit.dump.parse(details.actual);\n        message += "<table><tr class=\'test-expected\'><th>Expected: </th><td><pre>" + escapeText(expected) + \'</pre></td></tr>\';\n        if (actual !== expected) {\n          message += "<tr class=\'test-actual\'><th>Result: </th><td><pre>" + escapeText(actual) + \'</pre></td></tr>\';\n          if (typeof details.actual === \'number\' && typeof details.expected === \'number\') {\n            if (!isNaN(details.actual) && !isNaN(details.expected)) {\n              showDiff = true;\n              diff = details.actual - details.expected;\n              diff = (diff > 0 ? \'+\' : \'\') + diff;\n            }\n          } else if (typeof details.actual !== \'boolean\' && typeof details.expected !== \'boolean\') {\n            diff = QUnit.diff(expected, actual);\n\n            // don\'t show diff if there is zero overlap\n            showDiff = stripHtml(diff).length !== stripHtml(expected).length + stripHtml(actual).length;\n          }\n          if (showDiff) {\n            message += "<tr class=\'test-diff\'><th>Diff: </th><td><pre>" + diff + \'</pre></td></tr>\';\n          }\n        } else if (expected.indexOf(\'[object Array]\') !== -1 || expected.indexOf(\'[object Object]\') !== -1) {\n          message += "<tr class=\'test-message\'><th>Message: </th><td>" + \'Diff suppressed as the depth of object is more than current max depth (\' + QUnit.config.maxDepth + \').<p>Hint: Use <code>QUnit.dump.maxDepth</code> to \' + " run with a higher max depth or <a href=\'" + escapeText(setUrl({\n            maxDepth: -1\n          })) + "\'>" + \'Rerun</a> without max depth.</p></td></tr>\';\n        } else {\n          message += "<tr class=\'test-message\'><th>Message: </th><td>" + \'Diff suppressed as the expected and actual results have an equivalent\' + \' serialization</td></tr>\';\n        }\n        if (details.source) {\n          message += "<tr class=\'test-source\'><th>Source: </th><td><pre>" + escapeText(details.source) + \'</pre></td></tr>\';\n        }\n        message += \'</table>\';\n\n        // This occurs when pushFailure is set and we have an extracted stack trace\n      } else if (!details.result && details.source) {\n        message += \'<table>\' + "<tr class=\'test-source\'><th>Source: </th><td><pre>" + escapeText(details.source) + \'</pre></td></tr>\' + \'</table>\';\n      }\n      var assertList = testItem.getElementsByTagName(\'ol\')[0];\n      var assertLi = document.createElement(\'li\');\n      assertLi.className = details.result ? \'pass\' : \'fail\';\n      assertLi.innerHTML = message;\n      assertList.appendChild(assertLi);\n    });\n    QUnit.testDone(function (details) {\n      var tests = id(\'qunit-tests\');\n      var testItem = id(\'qunit-test-output-\' + details.testId);\n      if (!tests || !testItem) {\n        return;\n      }\n      removeClass(testItem, \'running\');\n      var status;\n      if (details.failed > 0) {\n        status = \'failed\';\n      } else if (details.todo) {\n        status = \'todo\';\n      } else {\n        status = details.skipped ? \'skipped\' : \'passed\';\n      }\n      var assertList = testItem.getElementsByTagName(\'ol\')[0];\n      var good = details.passed;\n      var bad = details.failed;\n\n      // This test passed if it has no unexpected failed assertions\n      var testPassed = details.failed > 0 ? details.todo : !details.todo;\n      if (testPassed) {\n        // Collapse the passing tests\n        addClass(assertList, \'qunit-collapsed\');\n      } else {\n        stats.failedTests.push(details.testId);\n        if (config.collapse) {\n          if (!collapseNext) {\n            // Skip collapsing the first failing test\n            collapseNext = true;\n          } else {\n            // Collapse remaining tests\n            addClass(assertList, \'qunit-collapsed\');\n          }\n        }\n      }\n\n      // The testItem.firstChild is the test name\n      var testTitle = testItem.firstChild;\n      var testCounts = bad ? "<b class=\'failed\'>" + bad + \'</b>, \' + "<b class=\'passed\'>" + good + \'</b>, \' : \'\';\n      testTitle.innerHTML += " <b class=\'counts\'>(" + testCounts + details.assertions.length + \')</b>\';\n      stats.completed++;\n      if (details.skipped) {\n        testItem.className = \'skipped\';\n        var skipped = document.createElement(\'em\');\n        skipped.className = \'qunit-skipped-label\';\n        skipped.innerHTML = \'skipped\';\n        testItem.insertBefore(skipped, testTitle);\n      } else {\n        addEvent(testTitle, \'click\', function () {\n          toggleClass(assertList, \'qunit-collapsed\');\n        });\n        testItem.className = testPassed ? \'pass\' : \'fail\';\n        if (details.todo) {\n          var todoLabel = document.createElement(\'em\');\n          todoLabel.className = \'qunit-todo-label\';\n          todoLabel.innerHTML = \'todo\';\n          testItem.className += \' todo\';\n          testItem.insertBefore(todoLabel, testTitle);\n        }\n        var time = document.createElement(\'span\');\n        time.className = \'runtime\';\n        time.innerHTML = details.runtime + \' ms\';\n        testItem.insertBefore(time, assertList);\n      }\n\n      // Show the source of the test when showing assertions\n      if (details.source) {\n        var sourceName = document.createElement(\'p\');\n        sourceName.innerHTML = \'<strong>Source: </strong>\' + escapeText(details.source);\n        addClass(sourceName, \'qunit-source\');\n        if (testPassed) {\n          addClass(sourceName, \'qunit-collapsed\');\n        }\n        addEvent(testTitle, \'click\', function () {\n          toggleClass(sourceName, \'qunit-collapsed\');\n        });\n        testItem.appendChild(sourceName);\n      }\n      if (config.hidepassed && (status === \'passed\' || details.skipped)) {\n        // use removeChild instead of remove because of support\n        hiddenTests.push(testItem);\n        tests.removeChild(testItem);\n      }\n    });\n    QUnit.on(\'error\', function (error) {\n      var testItem = appendTest(\'global failure\');\n      if (!testItem) {\n        // HTML Reporter is probably disabled or not yet initialized.\n        return;\n      }\n\n      // Render similar to a failed assertion (see above QUnit.log callback)\n      var message = escapeText(errorString(error));\n      message = "<span class=\'test-message\'>" + message + \'</span>\';\n      if (error && error.stack) {\n        message += \'<table>\' + "<tr class=\'test-source\'><th>Source: </th><td><pre>" + escapeText(error.stack) + \'</pre></td></tr>\' + \'</table>\';\n      }\n      var assertList = testItem.getElementsByTagName(\'ol\')[0];\n      var assertLi = document.createElement(\'li\');\n      assertLi.className = \'fail\';\n      assertLi.innerHTML = message;\n      assertList.appendChild(assertLi);\n\n      // Make it visible\n      testItem.className = \'fail\';\n    });\n\n    // Avoid readyState issue with phantomjs\n    // Ref: #818\n    var usingPhantom = function (p) {\n      return p && p.version && p.version.major > 0;\n    }(window$1.phantom);\n    if (usingPhantom) {\n      console$1.warn(\'Support for PhantomJS is deprecated and will be removed in QUnit 3.0.\');\n    }\n    if (!usingPhantom && document.readyState === \'complete\') {\n      QUnit.load();\n    } else {\n      addEvent(window$1, \'load\', QUnit.load);\n    }\n\n    // Wrap window.onerror. We will call the original window.onerror to see if\n    // the existing handler fully handles the error; if not, we will call the\n    // QUnit.onError function.\n    var originalWindowOnError = window$1.onerror;\n\n    // Cover uncaught exceptions\n    // Returning true will suppress the default browser handler,\n    // returning false will let it run.\n    window$1.onerror = function (message, fileName, lineNumber, columnNumber, errorObj) {\n      var ret = false;\n      if (originalWindowOnError) {\n        for (var _len = arguments.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n          args[_key - 5] = arguments[_key];\n        }\n        ret = originalWindowOnError.call.apply(originalWindowOnError, [this, message, fileName, lineNumber, columnNumber, errorObj].concat(args));\n      }\n\n      // Treat return value as window.onerror itself does,\n      // Only do our handling if not suppressed.\n      if (ret !== true) {\n        // If there is a current test that sets the internal `ignoreGlobalErrors` field\n        // (such as during `assert.throws()`), then the error is ignored and native\n        // error reporting is suppressed as well. This is because in browsers, an error\n        // can sometimes end up in `window.onerror` instead of in the local try/catch.\n        // This ignoring of errors does not apply to our general onUncaughtException\n        // method, nor to our `unhandledRejection` handlers, as those are not meant\n        // to receive an "expected" error during `assert.throws()`.\n        if (config.current && config.current.ignoreGlobalErrors) {\n          return true;\n        }\n\n        // According to\n        // https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror,\n        // most modern browsers support an errorObj argument; use that to\n        // get a full stack trace if it\'s available.\n        var error = errorObj || new Error(message);\n        if (!error.stack && fileName && lineNumber) {\n          error.stack = "".concat(fileName, ":").concat(lineNumber);\n        }\n        QUnit.onUncaughtException(error);\n      }\n      return ret;\n    };\n    window$1.addEventListener(\'unhandledrejection\', function (event) {\n      QUnit.onUncaughtException(event.reason);\n    });\n  })();\n\n  /*\n   * This file is a modified version of google-diff-match-patch\'s JavaScript implementation\n   * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n   * modifications are licensed as more fully set forth in LICENSE.txt.\n   *\n   * The original source of google-diff-match-patch is attributable and licensed as follows:\n   *\n   * Copyright 2006 Google Inc.\n   * https://code.google.com/p/google-diff-match-patch/\n   *\n   * Licensed under the Apache License, Version 2.0 (the "License");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * https://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an "AS IS" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * More Info:\n   *  https://code.google.com/p/google-diff-match-patch/\n   *\n   * Usage: QUnit.diff(expected, actual)\n   *\n   */\n  QUnit.diff = function () {\n    function DiffMatchPatch() {}\n\n    //  DIFF FUNCTIONS\n\n    /**\n     * The data structure representing a diff is an array of tuples:\n     * [[DIFF_DELETE, \'Hello\'], [DIFF_INSERT, \'Goodbye\'], [DIFF_EQUAL, \' world.\']]\n     * which means: delete \'Hello\', add \'Goodbye\' and keep \' world.\'\n     */\n    var DIFF_DELETE = -1;\n    var DIFF_INSERT = 1;\n    var DIFF_EQUAL = 0;\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    /**\n     * Find the differences between two texts.  Simplifies the problem by stripping\n     * any common prefix or suffix off the texts before diffing.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n     *     then don\'t run a line-level diff first to identify the changed areas.\n     *     Defaults to true, which does a faster, slightly less optimal diff.\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.DiffMain = function (text1, text2, optChecklines) {\n      // The diff must be complete in up to 1 second.\n      var deadline = Date.now() + 1000;\n\n      // Check for null inputs.\n      if (text1 === null || text2 === null) {\n        throw new Error(\'Cannot diff null input.\');\n      }\n\n      // Check for equality (speedup).\n      if (text1 === text2) {\n        if (text1) {\n          return [[DIFF_EQUAL, text1]];\n        }\n        return [];\n      }\n      if (typeof optChecklines === \'undefined\') {\n        optChecklines = true;\n      }\n\n      // Trim off common prefix (speedup).\n      var commonlength = this.diffCommonPrefix(text1, text2);\n      var commonprefix = text1.substring(0, commonlength);\n      text1 = text1.substring(commonlength);\n      text2 = text2.substring(commonlength);\n\n      // Trim off common suffix (speedup).\n      commonlength = this.diffCommonSuffix(text1, text2);\n      var commonsuffix = text1.substring(text1.length - commonlength);\n      text1 = text1.substring(0, text1.length - commonlength);\n      text2 = text2.substring(0, text2.length - commonlength);\n\n      // Compute the diff on the middle block.\n      var diffs = this.diffCompute(text1, text2, optChecklines, deadline);\n\n      // Restore the prefix and suffix.\n      if (commonprefix) {\n        diffs.unshift([DIFF_EQUAL, commonprefix]);\n      }\n      if (commonsuffix) {\n        diffs.push([DIFF_EQUAL, commonsuffix]);\n      }\n      this.diffCleanupMerge(diffs);\n      return diffs;\n    };\n\n    /**\n     * Reduce the number of edits by eliminating operationally trivial equalities.\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diffCleanupEfficiency = function (diffs) {\n      var changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;\n      changes = false;\n      equalities = []; // Stack of indices where equalities are found.\n      equalitiesLength = 0; // Keeping our own length var is faster in JS.\n      /** @type {?string} */\n      lastequality = null;\n\n      // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n      pointer = 0; // Index of current position.\n\n      // Is there an insertion operation before the last equality.\n      preIns = false;\n\n      // Is there a deletion operation before the last equality.\n      preDel = false;\n\n      // Is there an insertion operation after the last equality.\n      postIns = false;\n\n      // Is there a deletion operation after the last equality.\n      postDel = false;\n      while (pointer < diffs.length) {\n        // Equality found.\n        if (diffs[pointer][0] === DIFF_EQUAL) {\n          if (diffs[pointer][1].length < 4 && (postIns || postDel)) {\n            // Candidate found.\n            equalities[equalitiesLength++] = pointer;\n            preIns = postIns;\n            preDel = postDel;\n            lastequality = diffs[pointer][1];\n          } else {\n            // Not a candidate, and can never become one.\n            equalitiesLength = 0;\n            lastequality = null;\n          }\n          postIns = postDel = false;\n\n          // An insertion or deletion.\n        } else {\n          if (diffs[pointer][0] === DIFF_DELETE) {\n            postDel = true;\n          } else {\n            postIns = true;\n          }\n\n          /*\n           * Five types to be split:\n           * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n           * <ins>A</ins>X<ins>C</ins><del>D</del>\n           * <ins>A</ins><del>B</del>X<ins>C</ins>\n           * <ins>A</del>X<ins>C</ins><del>D</del>\n           * <ins>A</ins><del>B</del>X<del>C</del>\n           */\n          if (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {\n            // Duplicate record.\n            diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n\n            // Change second copy to insert.\n            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n            equalitiesLength--; // Throw away the equality we just deleted;\n            lastequality = null;\n            if (preIns && preDel) {\n              // No changes made which could affect previous entry, keep going.\n              postIns = postDel = true;\n              equalitiesLength = 0;\n            } else {\n              equalitiesLength--; // Throw away the previous equality.\n              pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n              postIns = postDel = false;\n            }\n            changes = true;\n          }\n        }\n        pointer++;\n      }\n      if (changes) {\n        this.diffCleanupMerge(diffs);\n      }\n    };\n\n    /**\n     * Convert a diff array into a pretty HTML report.\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n     * @param {integer} string to be beautified.\n     * @return {string} HTML representation.\n     */\n    DiffMatchPatch.prototype.diffPrettyHtml = function (diffs) {\n      var html = [];\n      for (var x = 0; x < diffs.length; x++) {\n        var op = diffs[x][0]; // Operation (insert, delete, equal)\n        var data = diffs[x][1]; // Text of change.\n        switch (op) {\n          case DIFF_INSERT:\n            html[x] = \'<ins>\' + escapeText(data) + \'</ins>\';\n            break;\n          case DIFF_DELETE:\n            html[x] = \'<del>\' + escapeText(data) + \'</del>\';\n            break;\n          case DIFF_EQUAL:\n            html[x] = \'<span>\' + escapeText(data) + \'</span>\';\n            break;\n        }\n      }\n      return html.join(\'\');\n    };\n\n    /**\n     * Determine the common prefix of two strings.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {number} The number of characters common to the start of each\n     *     string.\n     */\n    DiffMatchPatch.prototype.diffCommonPrefix = function (text1, text2) {\n      var pointermid, pointermax, pointermin, pointerstart;\n\n      // Quick check for common null cases.\n      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n        return 0;\n      }\n\n      // Binary search.\n      // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n      pointermin = 0;\n      pointermax = Math.min(text1.length, text2.length);\n      pointermid = pointermax;\n      pointerstart = 0;\n      while (pointermin < pointermid) {\n        if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n          pointermin = pointermid;\n          pointerstart = pointermin;\n        } else {\n          pointermax = pointermid;\n        }\n        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n      }\n      return pointermid;\n    };\n\n    /**\n     * Determine the common suffix of two strings.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {number} The number of characters common to the end of each string.\n     */\n    DiffMatchPatch.prototype.diffCommonSuffix = function (text1, text2) {\n      var pointermid, pointermax, pointermin, pointerend;\n\n      // Quick check for common null cases.\n      if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {\n        return 0;\n      }\n\n      // Binary search.\n      // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n      pointermin = 0;\n      pointermax = Math.min(text1.length, text2.length);\n      pointermid = pointermax;\n      pointerend = 0;\n      while (pointermin < pointermid) {\n        if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n          pointermin = pointermid;\n          pointerend = pointermin;\n        } else {\n          pointermax = pointermid;\n        }\n        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n      }\n      return pointermid;\n    };\n\n    /**\n     * Find the differences between two texts.  Assumes that the texts do not\n     * have any common prefix or suffix.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {boolean} checklines Speedup flag.  If false, then don\'t run a\n     *     line-level diff first to identify the changed areas.\n     *     If true, then run a faster, slightly less optimal diff.\n     * @param {number} deadline Time when the diff should be complete by.\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n     * @private\n     */\n    DiffMatchPatch.prototype.diffCompute = function (text1, text2, checklines, deadline) {\n      var diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;\n      if (!text1) {\n        // Just add some text (speedup).\n        return [[DIFF_INSERT, text2]];\n      }\n      if (!text2) {\n        // Just delete some text (speedup).\n        return [[DIFF_DELETE, text1]];\n      }\n      longtext = text1.length > text2.length ? text1 : text2;\n      shorttext = text1.length > text2.length ? text2 : text1;\n      i = longtext.indexOf(shorttext);\n      if (i !== -1) {\n        // Shorter text is inside the longer text (speedup).\n        diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n\n        // Swap insertions for deletions if diff is reversed.\n        if (text1.length > text2.length) {\n          diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n        }\n        return diffs;\n      }\n      if (shorttext.length === 1) {\n        // Single character string.\n        // After the previous speedup, the character can\'t be an equality.\n        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n      }\n\n      // Check to see if the problem can be split in two.\n      hm = this.diffHalfMatch(text1, text2);\n      if (hm) {\n        // A half-match was found, sort out the return data.\n        text1A = hm[0];\n        text1B = hm[1];\n        text2A = hm[2];\n        text2B = hm[3];\n        midCommon = hm[4];\n\n        // Send both pairs off for separate processing.\n        diffsA = this.DiffMain(text1A, text2A, checklines, deadline);\n        diffsB = this.DiffMain(text1B, text2B, checklines, deadline);\n\n        // Merge the results.\n        return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n      }\n      if (checklines && text1.length > 100 && text2.length > 100) {\n        return this.diffLineMode(text1, text2, deadline);\n      }\n      return this.diffBisect(text1, text2, deadline);\n    };\n\n    /**\n     * Do the two texts share a substring which is at least half the length of the\n     * longer text?\n     * This speedup can produce non-minimal diffs.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {Array.<string>} Five element Array, containing the prefix of\n     *     text1, the suffix of text1, the prefix of text2, the suffix of\n     *     text2 and the common middle.  Or null if there was no match.\n     * @private\n     */\n    DiffMatchPatch.prototype.diffHalfMatch = function (text1, text2) {\n      var longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;\n      longtext = text1.length > text2.length ? text1 : text2;\n      shorttext = text1.length > text2.length ? text2 : text1;\n      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n        return null; // Pointless.\n      }\n\n      dmp = this; // \'this\' becomes \'window\' in a closure.\n\n      /**\n       * Does a substring of shorttext exist within longtext such that the substring\n       * is at least half the length of longtext?\n       * Closure, but does not reference any external variables.\n       * @param {string} longtext Longer string.\n       * @param {string} shorttext Shorter string.\n       * @param {number} i Start index of quarter length substring within longtext.\n       * @return {Array.<string>} Five element Array, containing the prefix of\n       *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n       *     of shorttext and the common middle.  Or null if there was no match.\n       * @private\n       */\n      function diffHalfMatchI(longtext, shorttext, i) {\n        var seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n        // Start with a 1/4 length substring at position i as a seed.\n        seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n        j = -1;\n        bestCommon = \'\';\n        while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\n          prefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));\n          suffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n          if (bestCommon.length < suffixLength + prefixLength) {\n            bestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n            bestLongtextA = longtext.substring(0, i - suffixLength);\n            bestLongtextB = longtext.substring(i + prefixLength);\n            bestShorttextA = shorttext.substring(0, j - suffixLength);\n            bestShorttextB = shorttext.substring(j + prefixLength);\n          }\n        }\n        if (bestCommon.length * 2 >= longtext.length) {\n          return [bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB, bestCommon];\n        } else {\n          return null;\n        }\n      }\n\n      // First check if the second quarter is the seed for a half-match.\n      hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));\n\n      // Check again based on the third quarter.\n      hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));\n      if (!hm1 && !hm2) {\n        return null;\n      } else if (!hm2) {\n        hm = hm1;\n      } else if (!hm1) {\n        hm = hm2;\n      } else {\n        // Both matched.  Select the longest.\n        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n      }\n\n      // A half-match was found, sort out the return data.\n      if (text1.length > text2.length) {\n        text1A = hm[0];\n        text1B = hm[1];\n        text2A = hm[2];\n        text2B = hm[3];\n      } else {\n        text2A = hm[0];\n        text2B = hm[1];\n        text1A = hm[2];\n        text1B = hm[3];\n      }\n      midCommon = hm[4];\n      return [text1A, text1B, text2A, text2B, midCommon];\n    };\n\n    /**\n     * Do a quick line-level diff on both strings, then rediff the parts for\n     * greater accuracy.\n     * This speedup can produce non-minimal diffs.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {number} deadline Time when the diff should be complete by.\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n     * @private\n     */\n    DiffMatchPatch.prototype.diffLineMode = function (text1, text2, deadline) {\n      var a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j;\n\n      // Scan the text on a line-by-line basis first.\n      a = this.diffLinesToChars(text1, text2);\n      text1 = a.chars1;\n      text2 = a.chars2;\n      linearray = a.lineArray;\n      diffs = this.DiffMain(text1, text2, false, deadline);\n\n      // Convert the diff back to original text.\n      this.diffCharsToLines(diffs, linearray);\n\n      // Eliminate freak matches (e.g. blank lines)\n      this.diffCleanupSemantic(diffs);\n\n      // Rediff any replacement blocks, this time character-by-character.\n      // Add a dummy entry at the end.\n      diffs.push([DIFF_EQUAL, \'\']);\n      pointer = 0;\n      countDelete = 0;\n      countInsert = 0;\n      textDelete = \'\';\n      textInsert = \'\';\n      while (pointer < diffs.length) {\n        switch (diffs[pointer][0]) {\n          case DIFF_INSERT:\n            countInsert++;\n            textInsert += diffs[pointer][1];\n            break;\n          case DIFF_DELETE:\n            countDelete++;\n            textDelete += diffs[pointer][1];\n            break;\n          case DIFF_EQUAL:\n            // Upon reaching an equality, check for prior redundancies.\n            if (countDelete >= 1 && countInsert >= 1) {\n              // Delete the offending records and add the merged ones.\n              diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);\n              pointer = pointer - countDelete - countInsert;\n              a = this.DiffMain(textDelete, textInsert, false, deadline);\n              for (j = a.length - 1; j >= 0; j--) {\n                diffs.splice(pointer, 0, a[j]);\n              }\n              pointer = pointer + a.length;\n            }\n            countInsert = 0;\n            countDelete = 0;\n            textDelete = \'\';\n            textInsert = \'\';\n            break;\n        }\n        pointer++;\n      }\n      diffs.pop(); // Remove the dummy entry at the end.\n\n      return diffs;\n    };\n\n    /**\n     * Find the \'middle snake\' of a diff, split the problem in two\n     * and return the recursively constructed diff.\n     * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {number} deadline Time at which to bail if not yet complete.\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n     * @private\n     */\n    DiffMatchPatch.prototype.diffBisect = function (text1, text2, deadline) {\n      var text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n      // Cache the text lengths to prevent multiple calls.\n      text1Length = text1.length;\n      text2Length = text2.length;\n      maxD = Math.ceil((text1Length + text2Length) / 2);\n      vOffset = maxD;\n      vLength = 2 * maxD;\n      v1 = new Array(vLength);\n      v2 = new Array(vLength);\n\n      // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n      // integers and undefined.\n      for (x = 0; x < vLength; x++) {\n        v1[x] = -1;\n        v2[x] = -1;\n      }\n      v1[vOffset + 1] = 0;\n      v2[vOffset + 1] = 0;\n      delta = text1Length - text2Length;\n\n      // If the total number of characters is odd, then the front path will collide\n      // with the reverse path.\n      front = delta % 2 !== 0;\n\n      // Offsets for start and end of k loop.\n      // Prevents mapping of space beyond the grid.\n      k1start = 0;\n      k1end = 0;\n      k2start = 0;\n      k2end = 0;\n      for (d = 0; d < maxD; d++) {\n        // Bail out if deadline is reached.\n        if (Date.now() > deadline) {\n          break;\n        }\n\n        // Walk the front path one step.\n        for (k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n          k1Offset = vOffset + k1;\n          if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {\n            x1 = v1[k1Offset + 1];\n          } else {\n            x1 = v1[k1Offset - 1] + 1;\n          }\n          y1 = x1 - k1;\n          while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {\n            x1++;\n            y1++;\n          }\n          v1[k1Offset] = x1;\n          if (x1 > text1Length) {\n            // Ran off the right of the graph.\n            k1end += 2;\n          } else if (y1 > text2Length) {\n            // Ran off the bottom of the graph.\n            k1start += 2;\n          } else if (front) {\n            k2Offset = vOffset + delta - k1;\n            if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n              // Mirror x2 onto top-left coordinate system.\n              x2 = text1Length - v2[k2Offset];\n              if (x1 >= x2) {\n                // Overlap detected.\n                return this.diffBisectSplit(text1, text2, x1, y1, deadline);\n              }\n            }\n          }\n        }\n\n        // Walk the reverse path one step.\n        for (k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n          k2Offset = vOffset + k2;\n          if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {\n            x2 = v2[k2Offset + 1];\n          } else {\n            x2 = v2[k2Offset - 1] + 1;\n          }\n          y2 = x2 - k2;\n          while (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {\n            x2++;\n            y2++;\n          }\n          v2[k2Offset] = x2;\n          if (x2 > text1Length) {\n            // Ran off the left of the graph.\n            k2end += 2;\n          } else if (y2 > text2Length) {\n            // Ran off the top of the graph.\n            k2start += 2;\n          } else if (!front) {\n            k1Offset = vOffset + delta - k2;\n            if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n              x1 = v1[k1Offset];\n              y1 = vOffset + x1 - k1Offset;\n\n              // Mirror x2 onto top-left coordinate system.\n              x2 = text1Length - x2;\n              if (x1 >= x2) {\n                // Overlap detected.\n                return this.diffBisectSplit(text1, text2, x1, y1, deadline);\n              }\n            }\n          }\n        }\n      }\n\n      // Diff took too long and hit the deadline or\n      // number of diffs equals number of characters, no commonality at all.\n      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n    };\n\n    /**\n     * Given the location of the \'middle snake\', split the diff in two parts\n     * and recurse.\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {number} x Index of split point in text1.\n     * @param {number} y Index of split point in text2.\n     * @param {number} deadline Time at which to bail if not yet complete.\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n     * @private\n     */\n    DiffMatchPatch.prototype.diffBisectSplit = function (text1, text2, x, y, deadline) {\n      var text1a, text1b, text2a, text2b, diffs, diffsb;\n      text1a = text1.substring(0, x);\n      text2a = text2.substring(0, y);\n      text1b = text1.substring(x);\n      text2b = text2.substring(y);\n\n      // Compute both diffs serially.\n      diffs = this.DiffMain(text1a, text2a, false, deadline);\n      diffsb = this.DiffMain(text1b, text2b, false, deadline);\n      return diffs.concat(diffsb);\n    };\n\n    /**\n     * Reduce the number of edits by eliminating semantically trivial equalities.\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diffCleanupSemantic = function (diffs) {\n      var changes = false;\n      var equalities = []; // Stack of indices where equalities are found.\n      var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n      /** @type {?string} */\n      var lastequality = null;\n\n      // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n      var pointer = 0; // Index of current position.\n\n      // Number of characters that changed prior to the equality.\n      var lengthInsertions1 = 0;\n      var lengthDeletions1 = 0;\n\n      // Number of characters that changed after the equality.\n      var lengthInsertions2 = 0;\n      var lengthDeletions2 = 0;\n      while (pointer < diffs.length) {\n        if (diffs[pointer][0] === DIFF_EQUAL) {\n          // Equality found.\n          equalities[equalitiesLength++] = pointer;\n          lengthInsertions1 = lengthInsertions2;\n          lengthDeletions1 = lengthDeletions2;\n          lengthInsertions2 = 0;\n          lengthDeletions2 = 0;\n          lastequality = diffs[pointer][1];\n        } else {\n          // An insertion or deletion.\n          if (diffs[pointer][0] === DIFF_INSERT) {\n            lengthInsertions2 += diffs[pointer][1].length;\n          } else {\n            lengthDeletions2 += diffs[pointer][1].length;\n          }\n\n          // Eliminate an equality that is smaller or equal to the edits on both\n          // sides of it.\n          if (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {\n            // Duplicate record.\n            diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n\n            // Change second copy to insert.\n            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n\n            // Throw away the equality we just deleted.\n            equalitiesLength--;\n\n            // Throw away the previous equality (it needs to be reevaluated).\n            equalitiesLength--;\n            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n\n            // Reset the counters.\n            lengthInsertions1 = 0;\n            lengthDeletions1 = 0;\n            lengthInsertions2 = 0;\n            lengthDeletions2 = 0;\n            lastequality = null;\n            changes = true;\n          }\n        }\n        pointer++;\n      }\n\n      // Normalize the diff.\n      if (changes) {\n        this.diffCleanupMerge(diffs);\n      }\n      var deletion, insertion, overlapLength1, overlapLength2;\n\n      // Find any overlaps between deletions and insertions.\n      // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n      //   -> <del>abc</del>xxx<ins>def</ins>\n      // e.g: <del>xxxabc</del><ins>defxxx</ins>\n      //   -> <ins>def</ins>xxx<del>abc</del>\n      // Only extract an overlap if it is as big as the edit ahead or behind it.\n      pointer = 1;\n      while (pointer < diffs.length) {\n        if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n          deletion = diffs[pointer - 1][1];\n          insertion = diffs[pointer][1];\n          overlapLength1 = this.diffCommonOverlap(deletion, insertion);\n          overlapLength2 = this.diffCommonOverlap(insertion, deletion);\n          if (overlapLength1 >= overlapLength2) {\n            if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {\n              // Overlap found.  Insert an equality and trim the surrounding edits.\n              diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]);\n              diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);\n              diffs[pointer + 1][1] = insertion.substring(overlapLength1);\n              pointer++;\n            }\n          } else {\n            if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {\n              // Reverse overlap found.\n              // Insert an equality and swap and trim the surrounding edits.\n              diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]);\n              diffs[pointer - 1][0] = DIFF_INSERT;\n              diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);\n              diffs[pointer + 1][0] = DIFF_DELETE;\n              diffs[pointer + 1][1] = deletion.substring(overlapLength2);\n              pointer++;\n            }\n          }\n          pointer++;\n        }\n        pointer++;\n      }\n    };\n\n    /**\n     * Determine if the suffix of one string is the prefix of another.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {number} The number of characters common to the end of the first\n     *     string and the start of the second string.\n     * @private\n     */\n    DiffMatchPatch.prototype.diffCommonOverlap = function (text1, text2) {\n      // Cache the text lengths to prevent multiple calls.\n      var text1Length = text1.length;\n      var text2Length = text2.length;\n\n      // Eliminate the null case.\n      if (text1Length === 0 || text2Length === 0) {\n        return 0;\n      }\n\n      // Truncate the longer string.\n      if (text1Length > text2Length) {\n        text1 = text1.substring(text1Length - text2Length);\n      } else if (text1Length < text2Length) {\n        text2 = text2.substring(0, text1Length);\n      }\n      var textLength = Math.min(text1Length, text2Length);\n\n      // Quick check for the worst case.\n      if (text1 === text2) {\n        return textLength;\n      }\n\n      // Start by looking for a single character match\n      // and increase length until no match is found.\n      // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n      var best = 0;\n      var length = 1;\n      while (true) {\n        var pattern = text1.substring(textLength - length);\n        var found = text2.indexOf(pattern);\n        if (found === -1) {\n          return best;\n        }\n        length += found;\n        if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {\n          best = length;\n          length++;\n        }\n      }\n    };\n\n    /**\n     * Split two texts into an array of strings.  Reduce the texts to a string of\n     * hashes where each Unicode character represents one line.\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n     *     An object containing the encoded text1, the encoded text2 and\n     *     the array of unique strings.\n     *     The zeroth element of the array of unique strings is intentionally blank.\n     * @private\n     */\n    DiffMatchPatch.prototype.diffLinesToChars = function (text1, text2) {\n      var lineArray = []; // E.g. lineArray[4] === \'Hello\\n\'\n      var lineHash = {}; // E.g. lineHash[\'Hello\\n\'] === 4\n\n      // \'\\x00\' is a valid character, but various debuggers don\'t like it.\n      // So we\'ll insert a junk entry to avoid generating a null character.\n      lineArray[0] = \'\';\n\n      /**\n       * Split a text into an array of strings.  Reduce the texts to a string of\n       * hashes where each Unicode character represents one line.\n       * Modifies linearray and linehash through being a closure.\n       * @param {string} text String to encode.\n       * @return {string} Encoded string.\n       * @private\n       */\n      function diffLinesToCharsMunge(text) {\n        var chars = \'\';\n\n        // Walk the text, pulling out a substring for each line.\n        // text.split(\'\\n\') would would temporarily double our memory footprint.\n        // Modifying text would create many large strings to garbage collect.\n        var lineStart = 0;\n        var lineEnd = -1;\n\n        // Keeping our own length variable is faster than looking it up.\n        var lineArrayLength = lineArray.length;\n        while (lineEnd < text.length - 1) {\n          lineEnd = text.indexOf(\'\\n\', lineStart);\n          if (lineEnd === -1) {\n            lineEnd = text.length - 1;\n          }\n          var line = text.substring(lineStart, lineEnd + 1);\n          lineStart = lineEnd + 1;\n          if (hasOwn.call(lineHash, line)) {\n            chars += String.fromCharCode(lineHash[line]);\n          } else {\n            chars += String.fromCharCode(lineArrayLength);\n            lineHash[line] = lineArrayLength;\n            lineArray[lineArrayLength++] = line;\n          }\n        }\n        return chars;\n      }\n      var chars1 = diffLinesToCharsMunge(text1);\n      var chars2 = diffLinesToCharsMunge(text2);\n      return {\n        chars1: chars1,\n        chars2: chars2,\n        lineArray: lineArray\n      };\n    };\n\n    /**\n     * Rehydrate the text in a diff from a string of line hashes to real lines of\n     * text.\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n     * @param {!Array.<string>} lineArray Array of unique strings.\n     * @private\n     */\n    DiffMatchPatch.prototype.diffCharsToLines = function (diffs, lineArray) {\n      for (var x = 0; x < diffs.length; x++) {\n        var chars = diffs[x][1];\n        var text = [];\n        for (var y = 0; y < chars.length; y++) {\n          text[y] = lineArray[chars.charCodeAt(y)];\n        }\n        diffs[x][1] = text.join(\'\');\n      }\n    };\n\n    /**\n     * Reorder and merge like edit sections.  Merge equalities.\n     * Any edit section can move as long as it doesn\'t cross an equality.\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diffCleanupMerge = function (diffs) {\n      diffs.push([DIFF_EQUAL, \'\']); // Add a dummy entry at the end.\n      var pointer = 0;\n      var countDelete = 0;\n      var countInsert = 0;\n      var textDelete = \'\';\n      var textInsert = \'\';\n      while (pointer < diffs.length) {\n        switch (diffs[pointer][0]) {\n          case DIFF_INSERT:\n            countInsert++;\n            textInsert += diffs[pointer][1];\n            pointer++;\n            break;\n          case DIFF_DELETE:\n            countDelete++;\n            textDelete += diffs[pointer][1];\n            pointer++;\n            break;\n          case DIFF_EQUAL:\n            // Upon reaching an equality, check for prior redundancies.\n            if (countDelete + countInsert > 1) {\n              if (countDelete !== 0 && countInsert !== 0) {\n                // Factor out any common prefixes.\n                var commonlength = this.diffCommonPrefix(textInsert, textDelete);\n                if (commonlength !== 0) {\n                  if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {\n                    diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);\n                  } else {\n                    diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]);\n                    pointer++;\n                  }\n                  textInsert = textInsert.substring(commonlength);\n                  textDelete = textDelete.substring(commonlength);\n                }\n\n                // Factor out any common suffixies.\n                commonlength = this.diffCommonSuffix(textInsert, textDelete);\n                if (commonlength !== 0) {\n                  diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];\n                  textInsert = textInsert.substring(0, textInsert.length - commonlength);\n                  textDelete = textDelete.substring(0, textDelete.length - commonlength);\n                }\n              }\n\n              // Delete the offending records and add the merged ones.\n              if (countDelete === 0) {\n                diffs.splice(pointer - countInsert, countDelete + countInsert, [DIFF_INSERT, textInsert]);\n              } else if (countInsert === 0) {\n                diffs.splice(pointer - countDelete, countDelete + countInsert, [DIFF_DELETE, textDelete]);\n              } else {\n                diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [DIFF_DELETE, textDelete], [DIFF_INSERT, textInsert]);\n              }\n              pointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;\n            } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n              // Merge this equality with the previous one.\n              diffs[pointer - 1][1] += diffs[pointer][1];\n              diffs.splice(pointer, 1);\n            } else {\n              pointer++;\n            }\n            countInsert = 0;\n            countDelete = 0;\n            textDelete = \'\';\n            textInsert = \'\';\n            break;\n        }\n      }\n      if (diffs[diffs.length - 1][1] === \'\') {\n        diffs.pop(); // Remove the dummy entry at the end.\n      }\n\n      // Second pass: look for single edits surrounded on both sides by equalities\n      // which can be shifted sideways to eliminate an equality.\n      // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n      var changes = false;\n      pointer = 1;\n\n      // Intentionally ignore the first and last element (don\'t need checking).\n      while (pointer < diffs.length - 1) {\n        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n          var diffPointer = diffs[pointer][1];\n          var position = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length);\n\n          // This is a single edit surrounded by equalities.\n          if (position === diffs[pointer - 1][1]) {\n            // Shift the edit over the previous equality.\n            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n            diffs.splice(pointer - 1, 1);\n            changes = true;\n          } else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n            // Shift the edit over the next equality.\n            diffs[pointer - 1][1] += diffs[pointer + 1][1];\n            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n            diffs.splice(pointer + 1, 1);\n            changes = true;\n          }\n        }\n        pointer++;\n      }\n\n      // If shifts were made, the diff needs reordering and another shift sweep.\n      if (changes) {\n        this.diffCleanupMerge(diffs);\n      }\n    };\n    return function (o, n) {\n      var diff, output, text;\n      diff = new DiffMatchPatch();\n      output = diff.DiffMain(o, n);\n      diff.diffCleanupEfficiency(output);\n      text = diff.diffPrettyHtml(output);\n      return text;\n    };\n  }();\n\n})();\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, 'QUnit');
});
/*steal-css@1.3.2#css*/
define('steal-css@1.3.2#css', [
    'require',
    'exports',
    'module',
    '@loader',
    '@steal'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var loader = require('@loader');
        var steal = require('@steal');
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var importRegEx = /@import [^uU]['"]?([^'"\)]*)['"]?/g;
        var resourceRegEx = /url\(['"]?([^'"\)]*)['"]?\)/g;
        var waitSeconds = loader.cssOptions && loader.cssOptions.timeout ? parseInt(loader.cssOptions.timeout, 10) : 60;
        var onloadCss = function (link, cb) {
            var styleSheets = getDocument().styleSheets, i = styleSheets.length;
            while (i--) {
                if (styleSheets[i].href === link.href) {
                    return cb();
                }
            }
            setTimeout(function () {
                onloadCss(link, cb);
            });
        };
        function isIE9() {
            var doc = getDocument();
            return doc && !!Function('/*@cc_on return (/^9/.test(@_jscript_version) && /MSIE 9.0(?!.*IEMobile)/i.test(navigator.userAgent)); @*/')();
        }
        function getDocument() {
            if (typeof doneSsr !== 'undefined' && doneSsr.globalDocument) {
                return doneSsr.globalDocument;
            }
            if (typeof document !== 'undefined') {
                return document;
            }
            throw new Error('Unable to load CSS in an environment without a document.');
        }
        function getHead() {
            var doc = getDocument();
            var head = doc.head || doc.getElementsByTagName('head')[0];
            if (!head) {
                var docEl = doc.documentElement || doc;
                head = doc.createElement('head');
                docEl.insertBefore(head, docEl.firstChild);
            }
            return head;
        }
        function CSSModule(load, loader) {
            if (typeof load === 'object') {
                this.load = load;
                this.loader = loader;
                this.address = this.load.address;
                this.source = this.load.source;
            } else {
                this.address = load;
                this.source = loader;
            }
        }
        CSSModule.cssCount = 0;
        CSSModule.ie9MaxStyleSheets = 31;
        CSSModule.currentStyleSheet = null;
        CSSModule.prototype = {
            injectLink: function () {
                if (this._loaded) {
                    return this._loaded;
                }
                if (this.linkExists()) {
                    this._loaded = Promise.resolve('');
                    return this._loaded;
                }
                var doc = getDocument();
                var link = this.link = doc.createElement('link');
                link.type = 'text/css';
                link.rel = 'stylesheet';
                link.href = this.address;
                this._loaded = new Promise(function (resolve, reject) {
                    var timeout = setTimeout(function () {
                        reject('Unable to load CSS');
                    }, waitSeconds * 1000);
                    var loadCB = function (event) {
                        clearTimeout(timeout);
                        link.removeEventListener('load', loadCB);
                        link.removeEventListener('error', loadCB);
                        if (event && event.type === 'error') {
                            reject('Unable to load CSS');
                        } else {
                            resolve('');
                        }
                    };
                    if ('isApplicationInstalled' in navigator || !link.addEventListener) {
                        onloadCss(link, loadCB);
                    } else if (navigator.noUI) {
                        loadCB();
                    } else {
                        link.addEventListener('load', loadCB);
                        link.addEventListener('error', loadCB);
                    }
                    getHead().appendChild(link);
                });
                return this._loaded;
            },
            injectStyle: function () {
                var doc = getDocument();
                var head = getHead();
                var style = this.style = doc.createElement('style');
                style.type = 'text/css';
                if (style.sheet) {
                    style.sheet.cssText = this.source;
                } else if (style.styleSheet) {
                    style.styleSheet.cssText = this.source;
                } else {
                    style.appendChild(doc.createTextNode(this.source));
                }
                head.appendChild(style);
            },
            ie9StyleSheetLimitHack: function () {
                var doc = getDocument();
                if (!CSSModule.cssCount) {
                    CSSModule.currentStyleSheet = doc.createStyleSheet();
                }
                CSSModule.cssCount += 1;
                CSSModule.currentStyleSheet.cssText += this.source;
                if (CSSModule.cssCount === CSSModule.ie9MaxStyleSheets) {
                    CSSModule.cssCount = 0;
                }
            },
            updateURLs: function () {
                var rawSource = this.source, address = this.address;
                this.source = rawSource.replace(importRegEx, function (whole, part) {
                    if (isNode) {
                        return '@import url(' + part + ')';
                    } else {
                        return '@import url(' + steal.joinURIs(address, part) + ')';
                    }
                });
                if (!loader.isEnv('build')) {
                    this.source = this.source + '/*# sourceURL=' + address + ' */';
                    this.source = this.source.replace(resourceRegEx, function (whole, part) {
                        return 'url(' + steal.joinURIs(address, part) + ')';
                    });
                }
                return this.source;
            },
            getExistingNode: function () {
                var doc = getDocument();
                var selector = '[href=\'' + this.address + '\']';
                return doc.querySelector && doc.querySelector(selector);
            },
            linkExists: function () {
                var styleSheets = getDocument().styleSheets;
                for (var i = 0; i < styleSheets.length; ++i) {
                    if (this.address === styleSheets[i].href) {
                        return true;
                    }
                }
                return false;
            },
            setupLiveReload: function (loader, name) {
                var head = getHead();
                var css = this;
                if (loader.liveReloadInstalled) {
                    var cssReload = loader['import']('live-reload', { name: module.id });
                    Promise.resolve(cssReload).then(function (reload) {
                        loader['import'](name).then(function () {
                            reload.once('!dispose/' + name, function () {
                                css.style.__isDirty = true;
                                reload.once('!cycleComplete', function () {
                                    head.removeChild(css.style);
                                });
                            });
                        });
                    });
                }
            }
        };
        if (loader.isEnv('production')) {
            exports.fetch = function (load) {
                var css = new CSSModule(load.address);
                return css.injectLink();
            };
        } else {
            exports.instantiate = function (load) {
                var loader = this;
                var css = new CSSModule(load.address, load.source);
                load.source = css.updateURLs();
                load.metadata.deps = [];
                load.metadata.format = 'css';
                load.metadata.execute = function () {
                    if (getDocument()) {
                        if (isIE9()) {
                            css.ie9StyleSheetLimitHack();
                        } else {
                            css.injectStyle();
                        }
                        css.setupLiveReload(loader, load.name);
                    }
                    return loader.newModule({ source: css.source });
                };
            };
        }
        exports.CSSModule = CSSModule;
        exports.getDocument = getDocument;
        exports.getHead = getHead;
        exports.locateScheme = true;
        exports.buildType = 'css';
        exports.includeInBuild = true;
        exports.pluginBuilder = 'steal-css/slim';
    }(function () {
        return this;
    }(), require, exports, module));
});
/*steal-qunit@2.0.0#steal-qunit*/
'format amd';
define('steal-qunit@2.0.0#steal-qunit', [
    '@loader',
    'qunit/qunit/qunit',
    'qunit/qunit/qunit.css'
], function (loader, QUnit) {
    if (loader.has('live-reload')) {
        setupLiveReload();
    }
    setupSauceLabsReporting();
    function setupLiveReload() {
        QUnit.done(updateResults);
        function findModule(name) {
            var mods = QUnit.config.modules;
            return mods.filter(function (mod) {
                return mod.name === name;
            }).pop();
        }
        function findTestResult(mod, id) {
            var tests = mod.tests || [];
            return tests.filter(function (test) {
                return test.testId === id;
            })[0];
        }
        function updateResults() {
            var tests = document.getElementById('qunit-tests').children;
            var node, id, test, moduleName, mod;
            passed = true, removedNodes = [];
            for (var i = 0, len = tests.length; i < len; i++) {
                node = tests.item(i);
                id = node.id.split('-').pop();
                moduleName = node.querySelector('.module-name').textContent;
                mod = findModule(moduleName);
                test = findTestResult(mod, id);
                if (test) {
                    removeAllButLast(node, 'runtime');
                    if (node.hasAttribute && node.hasAttribute('class') && node.className !== 'pass') {
                        passed = false;
                        break;
                    }
                } else {
                    removedNodes.push(node);
                }
            }
            removedNodes.forEach(function (node) {
                node.parentNode.removeChild(node);
            });
            document.getElementById('qunit-banner').className = passed ? 'qunit-pass' : 'qunit-fail';
        }
        function removeAllButLast(parent, className) {
            var node, nodes = [];
            var children = parent.children;
            for (var i = 0, len = children.length; i < len; i++) {
                node = children.item(i);
                if (node.className === className)
                    nodes.push(node);
            }
            while (nodes.length > 1) {
                node = nodes.shift();
                parent.removeChild(node);
            }
        }
    }
    function setupSauceLabsReporting() {
        var log = [];
        QUnit.done(function (test_results) {
            var tests = [];
            for (var i = 0, len = log.length; i < len; i++) {
                var details = log[i];
                tests.push({
                    name: details.name,
                    result: details.result,
                    expected: details.expected,
                    actual: details.actual,
                    source: details.source
                });
            }
            test_results.tests = tests;
            window.global_test_results = test_results;
        });
        QUnit.testStart(function (testDetails) {
            QUnit.log(function (details) {
                if (!details.result) {
                    details.name = testDetails.name;
                    log.push(details);
                }
            });
        });
    }
    QUnit.config.autostart = false;
    steal.done().then(function () {
        if (window.Testee && window.Testee.init) {
            Testee.init();
        }
        var qunitVersion = Number(QUnit.version.split('.')[0]);
        if (qunitVersion < 2) {
            QUnit.load();
        }
    });
    return QUnit;
});
/*can-namespace@1.0.0#can-namespace*/
define('can-namespace@1.0.0#can-namespace', function (require, exports, module) {
    module.exports = {};
});
/*can-symbol@1.7.0#can-symbol*/
define('can-symbol@1.7.0#can-symbol', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var supportsNativeSymbols = function () {
            var symbolExists = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function';
            if (!symbolExists) {
                return false;
            }
            var symbol = Symbol('a symbol for testing symbols');
            return typeof symbol === 'symbol';
        }();
        var CanSymbol;
        if (supportsNativeSymbols) {
            CanSymbol = Symbol;
        } else {
            var symbolNum = 0;
            CanSymbol = function CanSymbolPolyfill(description) {
                var symbolValue = '@@symbol' + symbolNum++ + description;
                var symbol = {};
                Object.defineProperties(symbol, {
                    toString: {
                        value: function () {
                            return symbolValue;
                        }
                    }
                });
                return symbol;
            };
            var descriptionToSymbol = {};
            var symbolToDescription = {};
            CanSymbol.for = function (description) {
                var symbol = descriptionToSymbol[description];
                if (!symbol) {
                    symbol = descriptionToSymbol[description] = CanSymbol(description);
                    symbolToDescription[symbol] = description;
                }
                return symbol;
            };
            CanSymbol.keyFor = function (symbol) {
                return symbolToDescription[symbol];
            };
            [
                'hasInstance',
                'isConcatSpreadable',
                'iterator',
                'match',
                'prototype',
                'replace',
                'search',
                'species',
                'split',
                'toPrimitive',
                'toStringTag',
                'unscopables'
            ].forEach(function (name) {
                CanSymbol[name] = CanSymbol('Symbol.' + name);
            });
        }
        [
            'isMapLike',
            'isListLike',
            'isValueLike',
            'isFunctionLike',
            'isScopeLike',
            'getOwnKeys',
            'getOwnKeyDescriptor',
            'proto',
            'getOwnEnumerableKeys',
            'hasOwnKey',
            'hasKey',
            'size',
            'getName',
            'getIdentity',
            'assignDeep',
            'updateDeep',
            'getValue',
            'setValue',
            'getKeyValue',
            'setKeyValue',
            'updateValues',
            'addValue',
            'removeValues',
            'apply',
            'new',
            'onValue',
            'offValue',
            'onKeyValue',
            'offKeyValue',
            'getKeyDependencies',
            'getValueDependencies',
            'keyHasDependencies',
            'valueHasDependencies',
            'onKeys',
            'onKeysAdded',
            'onKeysRemoved',
            'onPatches'
        ].forEach(function (name) {
            CanSymbol.for('can.' + name);
        });
        module.exports = namespace.Symbol = CanSymbol;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-reflect@1.19.0#reflections/helpers*/
define('can-reflect@1.19.0#reflections/helpers', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    module.exports = {
        makeGetFirstSymbolValue: function (symbolNames) {
            var symbols = symbolNames.map(function (name) {
                return canSymbol.for(name);
            });
            var length = symbols.length;
            return function getFirstSymbol(obj) {
                var index = -1;
                while (++index < length) {
                    if (obj[symbols[index]] !== undefined) {
                        return obj[symbols[index]];
                    }
                }
            };
        },
        hasLength: function (list) {
            var type = typeof list;
            if (type === 'string' || Array.isArray(list)) {
                return true;
            }
            var length = list && (type !== 'boolean' && type !== 'number' && 'length' in list) && list.length;
            return typeof list !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in list);
        }
    };
});
/*can-reflect@1.19.0#reflections/type/type*/
define('can-reflect@1.19.0#reflections/type/type', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var helpers = require('../helpers');
    var plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames(function () {
    }.prototype);
    var plainFunctionPrototypeProto = Object.getPrototypeOf(function () {
    }.prototype);
    function isConstructorLike(func) {
        var value = func[canSymbol.for('can.new')];
        if (value !== undefined) {
            return value;
        }
        if (typeof func !== 'function') {
            return false;
        }
        var prototype = func.prototype;
        if (!prototype) {
            return false;
        }
        if (plainFunctionPrototypeProto !== Object.getPrototypeOf(prototype)) {
            return true;
        }
        var propertyNames = Object.getOwnPropertyNames(prototype);
        if (propertyNames.length === plainFunctionPrototypePropertyNames.length) {
            for (var i = 0, len = propertyNames.length; i < len; i++) {
                if (propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {
                    return true;
                }
            }
            return false;
        } else {
            return true;
        }
    }
    var getNewOrApply = helpers.makeGetFirstSymbolValue([
        'can.new',
        'can.apply'
    ]);
    function isFunctionLike(obj) {
        var result, symbolValue = !!obj && obj[canSymbol.for('can.isFunctionLike')];
        if (symbolValue !== undefined) {
            return symbolValue;
        }
        result = getNewOrApply(obj);
        if (result !== undefined) {
            return !!result;
        }
        return typeof obj === 'function';
    }
    function isPrimitive(obj) {
        var type = typeof obj;
        if (obj == null || type !== 'function' && type !== 'object') {
            return true;
        } else {
            return false;
        }
    }
    var coreHasOwn = Object.prototype.hasOwnProperty;
    var funcToString = Function.prototype.toString;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        var proto = Object.getPrototypeOf(obj);
        if (proto === Object.prototype || proto === null) {
            return true;
        }
        var Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;
        return typeof Constructor === 'function' && Constructor instanceof Constructor && funcToString.call(Constructor) === objectCtorString;
    }
    function isBuiltIn(obj) {
        if (isPrimitive(obj) || Array.isArray(obj) || isPlainObject(obj) || Object.prototype.toString.call(obj) !== '[object Object]' && Object.prototype.toString.call(obj).indexOf('[object ') !== -1) {
            return true;
        } else {
            return false;
        }
    }
    function isValueLike(obj) {
        var symbolValue;
        if (isPrimitive(obj)) {
            return true;
        }
        symbolValue = obj[canSymbol.for('can.isValueLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = obj[canSymbol.for('can.getValue')];
        if (value !== undefined) {
            return !!value;
        }
    }
    function isMapLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        var isMapLike = obj[canSymbol.for('can.isMapLike')];
        if (typeof isMapLike !== 'undefined') {
            return !!isMapLike;
        }
        var value = obj[canSymbol.for('can.getKeyValue')];
        if (value !== undefined) {
            return !!value;
        }
        return true;
    }
    var onValueSymbol = canSymbol.for('can.onValue'), onKeyValueSymbol = canSymbol.for('can.onKeyValue'), onPatchesSymbol = canSymbol.for('can.onPatches');
    function isObservableLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        return Boolean(obj[onValueSymbol] || obj[onKeyValueSymbol] || obj[onPatchesSymbol]);
    }
    function isListLike(list) {
        var symbolValue, type = typeof list;
        if (type === 'string') {
            return true;
        }
        if (isPrimitive(list)) {
            return false;
        }
        symbolValue = list[canSymbol.for('can.isListLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = list[canSymbol.iterator];
        if (value !== undefined) {
            return !!value;
        }
        if (Array.isArray(list)) {
            return true;
        }
        return helpers.hasLength(list);
    }
    var supportsNativeSymbols = function () {
        var symbolExists = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function';
        if (!symbolExists) {
            return false;
        }
        var symbol = Symbol('a symbol for testing symbols');
        return typeof symbol === 'symbol';
    }();
    var isSymbolLike;
    if (supportsNativeSymbols) {
        isSymbolLike = function (symbol) {
            return typeof symbol === 'symbol';
        };
    } else {
        var symbolStart = '@@symbol';
        isSymbolLike = function (symbol) {
            if (typeof symbol === 'object' && !Array.isArray(symbol)) {
                return symbol.toString().substr(0, symbolStart.length) === symbolStart;
            } else {
                return false;
            }
        };
    }
    var fnKeys = [
        'get',
        'set',
        'peek',
        'computeData',
        'add',
        'getScope',
        'getHelperOrPartial',
        'getTemplateContext',
        'cloneFromRef'
    ];
    function isScopeLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        var isScopeLike = obj[canSymbol.for('can.isScopeLike')];
        if (typeof isScopeLike !== 'undefined') {
            return !!isScopeLike;
        }
        return fnKeys.every(function (key) {
            return typeof obj[key] === 'function';
        }) && '_context' in obj && obj._meta && typeof obj._meta === 'object';
    }
    module.exports = {
        isConstructorLike: isConstructorLike,
        isFunctionLike: isFunctionLike,
        isListLike: isListLike,
        isMapLike: isMapLike,
        isObservableLike: isObservableLike,
        isScopeLike: isScopeLike,
        isPrimitive: isPrimitive,
        isBuiltIn: isBuiltIn,
        isValueLike: isValueLike,
        isSymbolLike: isSymbolLike,
        isMoreListLikeThanMapLike: function (obj) {
            if (Array.isArray(obj)) {
                return true;
            }
            if (obj instanceof Array) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            var value = obj[canSymbol.for('can.isMoreListLikeThanMapLike')];
            if (value !== undefined) {
                return value;
            }
            var isListLike = this.isListLike(obj), isMapLike = this.isMapLike(obj);
            if (isListLike && !isMapLike) {
                return true;
            } else if (!isListLike && isMapLike) {
                return false;
            }
        },
        isIteratorLike: function (obj) {
            return obj && typeof obj === 'object' && typeof obj.next === 'function' && obj.next.length === 0;
        },
        isPromise: function (obj) {
            return obj instanceof Promise || Object.prototype.toString.call(obj) === '[object Promise]';
        },
        isPlainObject: isPlainObject
    };
});
/*can-reflect@1.19.0#reflections/call/call*/
define('can-reflect@1.19.0#reflections/call/call', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    module.exports = {
        call: function (func, context) {
            var args = [].slice.call(arguments, 2);
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        apply: function (func, context, args) {
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        'new': function (func) {
            var args = [].slice.call(arguments, 1);
            var makeNew = func[canSymbol.for('can.new')];
            if (makeNew) {
                return makeNew.apply(func, args);
            } else {
                var context = Object.create(func.prototype);
                var ret = func.apply(context, args);
                if (typeReflections.isPrimitive(ret)) {
                    return context;
                } else {
                    return ret;
                }
            }
        }
    };
});
/*can-reflect@1.19.0#reflections/get-set/get-set*/
define('can-reflect@1.19.0#reflections/get-set/get-set', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue'), getKeyValueSymbol = canSymbol.for('can.getKeyValue'), getValueSymbol = canSymbol.for('can.getValue'), setValueSymbol = canSymbol.for('can.setValue');
    var reflections = {
        setKeyValue: function (obj, key, value) {
            if (typeReflections.isSymbolLike(key)) {
                if (typeof key === 'symbol') {
                    obj[key] = value;
                } else {
                    Object.defineProperty(obj, key, {
                        enumerable: false,
                        configurable: true,
                        value: value,
                        writable: true
                    });
                }
                return;
            }
            var setKeyValue = obj[setKeyValueSymbol];
            if (setKeyValue !== undefined) {
                return setKeyValue.call(obj, key, value);
            } else {
                obj[key] = value;
            }
        },
        getKeyValue: function (obj, key) {
            var getKeyValue = obj[getKeyValueSymbol];
            if (getKeyValue) {
                return getKeyValue.call(obj, key);
            }
            return obj[key];
        },
        deleteKeyValue: function (obj, key) {
            var deleteKeyValue = obj[canSymbol.for('can.deleteKeyValue')];
            if (deleteKeyValue) {
                return deleteKeyValue.call(obj, key);
            }
            delete obj[key];
        },
        getValue: function (value) {
            if (typeReflections.isPrimitive(value)) {
                return value;
            }
            var getValue = value[getValueSymbol];
            if (getValue) {
                return getValue.call(value);
            }
            return value;
        },
        setValue: function (item, value) {
            var setValue = item && item[setValueSymbol];
            if (setValue) {
                return setValue.call(item, value);
            } else {
                throw new Error('can-reflect.setValue - Can not set value.');
            }
        },
        splice: function (obj, index, removing, adding) {
            var howMany;
            if (typeof removing !== 'number') {
                var updateValues = obj[canSymbol.for('can.updateValues')];
                if (updateValues) {
                    return updateValues.call(obj, index, removing, adding);
                }
                howMany = removing.length;
            } else {
                howMany = removing;
            }
            if (arguments.length <= 3) {
                adding = [];
            }
            var splice = obj[canSymbol.for('can.splice')];
            if (splice) {
                return splice.call(obj, index, howMany, adding);
            }
            return [].splice.apply(obj, [
                index,
                howMany
            ].concat(adding));
        },
        addValues: function (obj, adding, index) {
            var add = obj[canSymbol.for('can.addValues')];
            if (add) {
                return add.call(obj, adding, index);
            }
            if (Array.isArray(obj) && index === undefined) {
                return obj.push.apply(obj, adding);
            }
            return reflections.splice(obj, index, [], adding);
        },
        removeValues: function (obj, removing, index) {
            var removeValues = obj[canSymbol.for('can.removeValues')];
            if (removeValues) {
                return removeValues.call(obj, removing, index);
            }
            if (Array.isArray(obj) && index === undefined) {
                removing.forEach(function (item) {
                    var index = obj.indexOf(item);
                    if (index >= 0) {
                        obj.splice(index, 1);
                    }
                });
                return;
            }
            return reflections.splice(obj, index, removing, []);
        }
    };
    reflections.get = reflections.getKeyValue;
    reflections.set = reflections.setKeyValue;
    reflections['delete'] = reflections.deleteKeyValue;
    module.exports = reflections;
});
/*can-reflect@1.19.0#reflections/observe/observe*/
define('can-reflect@1.19.0#reflections/observe/observe', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var slice = [].slice;
    function makeFallback(symbolName, fallbackName) {
        return function (obj, event, handler, queueName) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                return method.call(obj, event, handler, queueName);
            }
            return this[fallbackName].apply(this, arguments);
        };
    }
    function makeErrorIfMissing(symbolName, errorMessage) {
        return function (obj) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                var args = slice.call(arguments, 1);
                return method.apply(obj, args);
            }
            throw new Error(errorMessage);
        };
    }
    module.exports = {
        onKeyValue: makeFallback('can.onKeyValue', 'onEvent'),
        offKeyValue: makeFallback('can.offKeyValue', 'offEvent'),
        onKeys: makeErrorIfMissing('can.onKeys', 'can-reflect: can not observe an onKeys event'),
        onKeysAdded: makeErrorIfMissing('can.onKeysAdded', 'can-reflect: can not observe an onKeysAdded event'),
        onKeysRemoved: makeErrorIfMissing('can.onKeysRemoved', 'can-reflect: can not unobserve an onKeysRemoved event'),
        getKeyDependencies: makeErrorIfMissing('can.getKeyDependencies', 'can-reflect: can not determine dependencies'),
        getWhatIChange: makeErrorIfMissing('can.getWhatIChange', 'can-reflect: can not determine dependencies'),
        getChangesDependencyRecord: function getChangesDependencyRecord(handler) {
            var fn = handler[canSymbol.for('can.getChangesDependencyRecord')];
            if (typeof fn === 'function') {
                return fn();
            }
        },
        keyHasDependencies: makeErrorIfMissing('can.keyHasDependencies', 'can-reflect: can not determine if this has key dependencies'),
        onValue: makeErrorIfMissing('can.onValue', 'can-reflect: can not observe value change'),
        offValue: makeErrorIfMissing('can.offValue', 'can-reflect: can not unobserve value change'),
        getValueDependencies: makeErrorIfMissing('can.getValueDependencies', 'can-reflect: can not determine dependencies'),
        valueHasDependencies: makeErrorIfMissing('can.valueHasDependencies', 'can-reflect: can not determine if value has dependencies'),
        onPatches: makeErrorIfMissing('can.onPatches', 'can-reflect: can not observe patches on object'),
        offPatches: makeErrorIfMissing('can.offPatches', 'can-reflect: can not unobserve patches on object'),
        onInstancePatches: makeErrorIfMissing('can.onInstancePatches', 'can-reflect: can not observe onInstancePatches on Type'),
        offInstancePatches: makeErrorIfMissing('can.offInstancePatches', 'can-reflect: can not unobserve onInstancePatches on Type'),
        onInstanceBoundChange: makeErrorIfMissing('can.onInstanceBoundChange', 'can-reflect: can not observe bound state change in instances.'),
        offInstanceBoundChange: makeErrorIfMissing('can.offInstanceBoundChange', 'can-reflect: can not unobserve bound state change'),
        isBound: makeErrorIfMissing('can.isBound', 'can-reflect: cannot determine if object is bound'),
        onEvent: function (obj, eventName, callback, queue) {
            if (obj) {
                var onEvent = obj[canSymbol.for('can.onEvent')];
                if (onEvent !== undefined) {
                    return onEvent.call(obj, eventName, callback, queue);
                } else if (obj.addEventListener) {
                    obj.addEventListener(eventName, callback, queue);
                }
            }
        },
        offEvent: function (obj, eventName, callback, queue) {
            if (obj) {
                var offEvent = obj[canSymbol.for('can.offEvent')];
                if (offEvent !== undefined) {
                    return offEvent.call(obj, eventName, callback, queue);
                } else if (obj.removeEventListener) {
                    obj.removeEventListener(eventName, callback, queue);
                }
            }
        },
        setPriority: function (obj, priority) {
            if (obj) {
                var setPriority = obj[canSymbol.for('can.setPriority')];
                if (setPriority !== undefined) {
                    setPriority.call(obj, priority);
                    return true;
                }
            }
            return false;
        },
        getPriority: function (obj) {
            if (obj) {
                var getPriority = obj[canSymbol.for('can.getPriority')];
                if (getPriority !== undefined) {
                    return getPriority.call(obj);
                }
            }
            return undefined;
        }
    };
});
/*can-reflect@1.19.0#reflections/shape/shape*/
define('can-reflect@1.19.0#reflections/shape/shape', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../get-set/get-set',
    '../type/type',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var getSetReflections = require('../get-set/get-set');
    var typeReflections = require('../type/type');
    var helpers = require('../helpers');
    var getPrototypeOfWorksWithPrimitives = true;
    try {
        Object.getPrototypeOf(1);
    } catch (e) {
        getPrototypeOfWorksWithPrimitives = false;
    }
    var ArrayMap;
    if (typeof Map === 'function') {
        ArrayMap = Map;
    } else {
        var isEven = function isEven(num) {
            return num % 2 === 0;
        };
        ArrayMap = function () {
            this.contents = [];
        };
        ArrayMap.prototype = {
            _getIndex: function (key) {
                var idx;
                do {
                    idx = this.contents.indexOf(key, idx);
                } while (idx !== -1 && !isEven(idx));
                return idx;
            },
            has: function (key) {
                return this._getIndex(key) !== -1;
            },
            get: function (key) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    return this.contents[idx + 1];
                }
            },
            set: function (key, value) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    this.contents[idx + 1] = value;
                } else {
                    this.contents.push(key);
                    this.contents.push(value);
                }
            },
            'delete': function (key) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    this.contents.splice(idx, 2);
                }
            }
        };
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var shapeReflections;
    var shiftFirstArgumentToThis = function (func) {
        return function () {
            var args = [this];
            args.push.apply(args, arguments);
            return func.apply(null, args);
        };
    };
    var getKeyValueSymbol = canSymbol.for('can.getKeyValue');
    var shiftedGetKeyValue = shiftFirstArgumentToThis(getSetReflections.getKeyValue);
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue');
    var shiftedSetKeyValue = shiftFirstArgumentToThis(getSetReflections.setKeyValue);
    var sizeSymbol = canSymbol.for('can.size');
    var hasUpdateSymbol = helpers.makeGetFirstSymbolValue([
        'can.updateDeep',
        'can.assignDeep',
        'can.setKeyValue'
    ]);
    var shouldUpdateOrAssign = function (obj) {
        return typeReflections.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);
    };
    function isSerializedHelper(obj) {
        if (typeReflections.isPrimitive(obj)) {
            return true;
        }
        if (hasUpdateSymbol(obj)) {
            return false;
        }
        return typeReflections.isBuiltIn(obj) && !typeReflections.isPlainObject(obj) && !Array.isArray(obj) && !typeReflections.isObservableLike(obj);
    }
    var Object_Keys;
    try {
        Object.keys(1);
        Object_Keys = Object.keys;
    } catch (e) {
        Object_Keys = function (obj) {
            if (typeReflections.isPrimitive(obj)) {
                return [];
            } else {
                return Object.keys(obj);
            }
        };
    }
    function createSerializeMap(Type) {
        var MapType = Type || ArrayMap;
        return {
            unwrap: new MapType(),
            serialize: new MapType(),
            isSerializing: {
                unwrap: new MapType(),
                serialize: new MapType()
            },
            circularReferenceIsSerializing: {
                unwrap: new MapType(),
                serialize: new MapType()
            }
        };
    }
    function makeSerializer(methodName, symbolsToCheck) {
        var serializeMap = null;
        function SerializeOperation(MapType) {
            this.first = !serializeMap;
            if (this.first) {
                serializeMap = createSerializeMap(MapType);
            }
            this.map = serializeMap;
            this.result = null;
        }
        SerializeOperation.prototype.end = function () {
            if (this.first) {
                serializeMap = null;
            }
            return this.result;
        };
        return function serializer(value, MapType) {
            if (isSerializedHelper(value)) {
                return value;
            }
            var operation = new SerializeOperation(MapType);
            if (typeReflections.isValueLike(value)) {
                operation.result = this[methodName](getSetReflections.getValue(value));
            } else {
                var isListLike = typeReflections.isIteratorLike(value) || typeReflections.isMoreListLikeThanMapLike(value);
                operation.result = isListLike ? [] : {};
                if (operation.map[methodName].has(value)) {
                    if (operation.map.isSerializing[methodName].has(value)) {
                        operation.map.circularReferenceIsSerializing[methodName].set(value, true);
                    }
                    return operation.map[methodName].get(value);
                } else {
                    operation.map[methodName].set(value, operation.result);
                }
                for (var i = 0, len = symbolsToCheck.length; i < len; i++) {
                    var serializer = value[symbolsToCheck[i]];
                    if (serializer) {
                        operation.map.isSerializing[methodName].set(value, true);
                        var oldResult = operation.result;
                        operation.result = serializer.call(value, oldResult);
                        operation.map.isSerializing[methodName].delete(value);
                        if (operation.result !== oldResult) {
                            if (operation.map.circularReferenceIsSerializing[methodName].has(value)) {
                                operation.end();
                                throw new Error('Cannot serialize cirular reference!');
                            }
                            operation.map[methodName].set(value, operation.result);
                        }
                        return operation.end();
                    }
                }
                if (typeof obj === 'function') {
                    operation.map[methodName].set(value, value);
                    operation.result = value;
                } else if (isListLike) {
                    this.eachIndex(value, function (childValue, index) {
                        operation.result[index] = this[methodName](childValue);
                    }, this);
                } else {
                    this.eachKey(value, function (childValue, prop) {
                        operation.result[prop] = this[methodName](childValue);
                    }, this);
                }
            }
            return operation.end();
        };
    }
    var makeMap;
    if (typeof Map !== 'undefined') {
        makeMap = function (keys) {
            var map = new Map();
            shapeReflections.eachIndex(keys, function (key) {
                map.set(key, true);
            });
            return map;
        };
    } else {
        makeMap = function (keys) {
            var map = {};
            keys.forEach(function (key) {
                map[key] = true;
            });
            return {
                get: function (key) {
                    return map[key];
                },
                set: function (key, value) {
                    map[key] = value;
                },
                keys: function () {
                    return keys;
                }
            };
        };
    }
    var fastHasOwnKey = function (obj) {
        var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
        if (hasOwnKey) {
            return hasOwnKey.bind(obj);
        } else {
            var map = makeMap(shapeReflections.getOwnEnumerableKeys(obj));
            return function (key) {
                return map.get(key);
            };
        }
    };
    function addPatch(patches, patch) {
        var lastPatch = patches[patches.length - 1];
        if (lastPatch) {
            if (lastPatch.deleteCount === lastPatch.insert.length && patch.index - lastPatch.index === lastPatch.deleteCount) {
                lastPatch.insert.push.apply(lastPatch.insert, patch.insert);
                lastPatch.deleteCount += patch.deleteCount;
                return;
            }
        }
        patches.push(patch);
    }
    function updateDeepList(target, source, isAssign) {
        var sourceArray = this.toArray(source);
        var patches = [], lastIndex = -1;
        this.eachIndex(target, function (curVal, index) {
            lastIndex = index;
            if (index >= sourceArray.length) {
                if (!isAssign) {
                    addPatch(patches, {
                        index: index,
                        deleteCount: target.length - index + 1,
                        insert: []
                    });
                }
                return false;
            }
            var newVal = sourceArray[index];
            if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                addPatch(patches, {
                    index: index,
                    deleteCount: 1,
                    insert: [newVal]
                });
            } else {
                if (isAssign === true) {
                    this.assignDeep(curVal, newVal);
                } else {
                    this.updateDeep(curVal, newVal);
                }
            }
        }, this);
        if (sourceArray.length > lastIndex) {
            addPatch(patches, {
                index: lastIndex + 1,
                deleteCount: 0,
                insert: sourceArray.slice(lastIndex + 1)
            });
        }
        for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
            var patch = patches[i];
            getSetReflections.splice(target, patch.index, patch.deleteCount, patch.insert);
        }
        return target;
    }
    shapeReflections = {
        each: function (obj, callback, context) {
            if (typeReflections.isIteratorLike(obj) || typeReflections.isMoreListLikeThanMapLike(obj)) {
                return shapeReflections.eachIndex(obj, callback, context);
            } else {
                return shapeReflections.eachKey(obj, callback, context);
            }
        },
        eachIndex: function (list, callback, context) {
            if (Array.isArray(list)) {
                return shapeReflections.eachListLike(list, callback, context);
            } else {
                var iter, iterator = list[canSymbol.iterator];
                if (typeReflections.isIteratorLike(list)) {
                    iter = list;
                } else if (iterator) {
                    iter = iterator.call(list);
                }
                if (iter) {
                    var res, index = 0;
                    while (!(res = iter.next()).done) {
                        if (callback.call(context || list, res.value, index++, list) === false) {
                            break;
                        }
                    }
                } else {
                    shapeReflections.eachListLike(list, callback, context);
                }
            }
            return list;
        },
        eachListLike: function (list, callback, context) {
            var index = -1;
            var length = list.length;
            if (length === undefined) {
                var size = list[sizeSymbol];
                if (size) {
                    length = size.call(list);
                } else {
                    throw new Error('can-reflect: unable to iterate.');
                }
            }
            while (++index < length) {
                var item = list[index];
                if (callback.call(context || item, item, index, list) === false) {
                    break;
                }
            }
            return list;
        },
        toArray: function (obj) {
            var arr = [];
            shapeReflections.each(obj, function (value) {
                arr.push(value);
            });
            return arr;
        },
        eachKey: function (obj, callback, context) {
            if (obj) {
                var enumerableKeys = shapeReflections.getOwnEnumerableKeys(obj);
                var getKeyValue = obj[getKeyValueSymbol] || shiftedGetKeyValue;
                return shapeReflections.eachIndex(enumerableKeys, function (key) {
                    var value = getKeyValue.call(obj, key);
                    return callback.call(context || obj, value, key, obj);
                });
            }
            return obj;
        },
        'hasOwnKey': function (obj, key) {
            var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
            if (hasOwnKey) {
                return hasOwnKey.call(obj, key);
            }
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                var found = false;
                shapeReflections.eachIndex(getOwnKeys.call(obj), function (objKey) {
                    if (objKey === key) {
                        found = true;
                        return false;
                    }
                });
                return found;
            }
            return hasOwnProperty.call(obj, key);
        },
        getOwnEnumerableKeys: function (obj) {
            var getOwnEnumerableKeys = obj[canSymbol.for('can.getOwnEnumerableKeys')];
            if (getOwnEnumerableKeys) {
                return getOwnEnumerableKeys.call(obj);
            }
            if (obj[canSymbol.for('can.getOwnKeys')] && obj[canSymbol.for('can.getOwnKeyDescriptor')]) {
                var keys = [];
                shapeReflections.eachIndex(shapeReflections.getOwnKeys(obj), function (key) {
                    var descriptor = shapeReflections.getOwnKeyDescriptor(obj, key);
                    if (descriptor.enumerable) {
                        keys.push(key);
                    }
                }, this);
                return keys;
            } else {
                return Object_Keys(obj);
            }
        },
        getOwnKeys: function (obj) {
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                return getOwnKeys.call(obj);
            } else {
                return Object.getOwnPropertyNames(obj);
            }
        },
        getOwnKeyDescriptor: function (obj, key) {
            var getOwnKeyDescriptor = obj[canSymbol.for('can.getOwnKeyDescriptor')];
            if (getOwnKeyDescriptor) {
                return getOwnKeyDescriptor.call(obj, key);
            } else {
                return Object.getOwnPropertyDescriptor(obj, key);
            }
        },
        unwrap: makeSerializer('unwrap', [canSymbol.for('can.unwrap')]),
        serialize: makeSerializer('serialize', [
            canSymbol.for('can.serialize'),
            canSymbol.for('can.unwrap')
        ]),
        assignMap: function (target, source) {
            var hasOwnKey = fastHasOwnKey(target);
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(source, function (value, key) {
                if (!hasOwnKey(key) || getKeyValue.call(target, key) !== value) {
                    setKeyValue.call(target, key, value);
                }
            });
            return target;
        },
        assignList: function (target, source) {
            var inserting = shapeReflections.toArray(source);
            getSetReflections.splice(target, 0, inserting, inserting);
            return target;
        },
        assign: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.assignList(target, source);
            } else {
                shapeReflections.assignMap(target, source);
            }
            return target;
        },
        assignDeepMap: function (target, source) {
            var hasOwnKey = fastHasOwnKey(target);
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(source, function (newVal, key) {
                if (!hasOwnKey(key)) {
                    getSetReflections.setKeyValue(target, key, newVal);
                } else {
                    var curVal = getKeyValue.call(target, key);
                    if (newVal === curVal) {
                    } else if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                        setKeyValue.call(target, key, newVal);
                    } else {
                        shapeReflections.assignDeep(curVal, newVal);
                    }
                }
            }, this);
            return target;
        },
        assignDeepList: function (target, source) {
            return updateDeepList.call(this, target, source, true);
        },
        assignDeep: function (target, source) {
            var assignDeep = target[canSymbol.for('can.assignDeep')];
            if (assignDeep) {
                assignDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.assignDeepList(target, source);
            } else {
                shapeReflections.assignDeepMap(target, source);
            }
            return target;
        },
        updateMap: function (target, source) {
            var sourceKeyMap = makeMap(shapeReflections.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap.get(key)) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap.set(key, false);
                var newVal = sourceGetKeyValue.call(source, key);
                if (newVal !== curVal) {
                    targetSetKeyValue.call(target, key, newVal);
                }
            }, this);
            shapeReflections.eachIndex(sourceKeyMap.keys(), function (key) {
                if (sourceKeyMap.get(key)) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            });
            return target;
        },
        updateList: function (target, source) {
            var inserting = shapeReflections.toArray(source);
            getSetReflections.splice(target, 0, target, inserting);
            return target;
        },
        update: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.updateList(target, source);
            } else {
                shapeReflections.updateMap(target, source);
            }
            return target;
        },
        updateDeepMap: function (target, source) {
            var sourceKeyMap = makeMap(shapeReflections.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap.get(key)) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap.set(key, false);
                var newVal = sourceGetKeyValue.call(source, key);
                if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                    targetSetKeyValue.call(target, key, newVal);
                } else {
                    shapeReflections.updateDeep(curVal, newVal);
                }
            }, this);
            shapeReflections.eachIndex(sourceKeyMap.keys(), function (key) {
                if (sourceKeyMap.get(key)) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            });
            return target;
        },
        updateDeepList: function (target, source) {
            return updateDeepList.call(this, target, source);
        },
        updateDeep: function (target, source) {
            var updateDeep = target[canSymbol.for('can.updateDeep')];
            if (updateDeep) {
                updateDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.updateDeepList(target, source);
            } else {
                shapeReflections.updateDeepMap(target, source);
            }
            return target;
        },
        hasKey: function (obj, key) {
            if (obj == null) {
                return false;
            }
            if (typeReflections.isPrimitive(obj)) {
                if (hasOwnProperty.call(obj, key)) {
                    return true;
                } else {
                    var proto;
                    if (getPrototypeOfWorksWithPrimitives) {
                        proto = Object.getPrototypeOf(obj);
                    } else {
                        proto = obj.__proto__;
                    }
                    if (proto !== undefined) {
                        return key in proto;
                    } else {
                        return obj[key] !== undefined;
                    }
                }
            }
            var hasKey = obj[canSymbol.for('can.hasKey')];
            if (hasKey) {
                return hasKey.call(obj, key);
            }
            var found = shapeReflections.hasOwnKey(obj, key);
            return found || key in obj;
        },
        getAllEnumerableKeys: function () {
        },
        getAllKeys: function () {
        },
        assignSymbols: function (target, source) {
            shapeReflections.eachKey(source, function (value, key) {
                var symbol = typeReflections.isSymbolLike(canSymbol[key]) ? canSymbol[key] : canSymbol.for(key);
                getSetReflections.setKeyValue(target, symbol, value);
            });
            return target;
        },
        isSerialized: isSerializedHelper,
        size: function (obj) {
            if (obj == null) {
                return 0;
            }
            var size = obj[sizeSymbol];
            var count = 0;
            if (size) {
                return size.call(obj);
            } else if (helpers.hasLength(obj)) {
                return obj.length;
            } else if (typeReflections.isListLike(obj)) {
                shapeReflections.eachIndex(obj, function () {
                    count++;
                });
                return count;
            } else if (obj) {
                return shapeReflections.getOwnEnumerableKeys(obj).length;
            } else {
                return undefined;
            }
        },
        defineInstanceKey: function (cls, key, properties) {
            var defineInstanceKey = cls[canSymbol.for('can.defineInstanceKey')];
            if (defineInstanceKey) {
                return defineInstanceKey.call(cls, key, properties);
            }
            var proto = cls.prototype;
            defineInstanceKey = proto[canSymbol.for('can.defineInstanceKey')];
            if (defineInstanceKey) {
                defineInstanceKey.call(proto, key, properties);
            } else {
                Object.defineProperty(proto, key, shapeReflections.assign({
                    configurable: true,
                    enumerable: !typeReflections.isSymbolLike(key),
                    writable: true
                }, properties));
            }
        }
    };
    shapeReflections.isSerializable = shapeReflections.isSerialized;
    shapeReflections.keys = shapeReflections.getOwnEnumerableKeys;
    module.exports = shapeReflections;
});
/*can-reflect@1.19.0#reflections/shape/schema/schema*/
define('can-reflect@1.19.0#reflections/shape/schema/schema', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../../type/type',
    '../../get-set/get-set',
    '../shape'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../../type/type');
    var getSetReflections = require('../../get-set/get-set');
    var shapeReflections = require('../shape');
    var getSchemaSymbol = canSymbol.for('can.getSchema'), isMemberSymbol = canSymbol.for('can.isMember'), newSymbol = canSymbol.for('can.new');
    function comparator(a, b) {
        return a.localeCompare(b);
    }
    function sort(obj) {
        if (typeReflections.isPrimitive(obj) || obj instanceof Date) {
            return obj;
        }
        var out;
        if (typeReflections.isListLike(obj)) {
            out = [];
            shapeReflections.eachKey(obj, function (item) {
                out.push(sort(item));
            });
            return out;
        }
        if (typeReflections.isMapLike(obj)) {
            out = {};
            shapeReflections.getOwnKeys(obj).sort(comparator).forEach(function (key) {
                out[key] = sort(getSetReflections.getKeyValue(obj, key));
            });
            return out;
        }
        return obj;
    }
    function isPrimitiveConverter(Type) {
        return Type === Number || Type === String || Type === Boolean;
    }
    var schemaReflections = {
        getSchema: function (type) {
            if (type === undefined || type === null) {
                return type;
            }
            var getSchema = type[getSchemaSymbol];
            if (getSchema === undefined) {
                type = type.constructor;
                getSchema = type && type[getSchemaSymbol];
            }
            return getSchema !== undefined ? getSchema.call(type) : undefined;
        },
        getIdentity: function (value, schema) {
            schema = schema || schemaReflections.getSchema(value);
            if (schema === undefined) {
                throw new Error('can-reflect.getIdentity - Unable to find a schema for the given value.');
            }
            var identity = schema.identity;
            if (!identity || identity.length === 0) {
                throw new Error('can-reflect.getIdentity - Provided schema lacks an identity property.');
            } else if (identity.length === 1) {
                return getSetReflections.getKeyValue(value, identity[0]);
            } else {
                var id = {};
                identity.forEach(function (key) {
                    id[key] = getSetReflections.getKeyValue(value, key);
                });
                return JSON.stringify(schemaReflections.cloneKeySort(id));
            }
        },
        cloneKeySort: function (obj) {
            return sort(obj);
        },
        convert: function (value, Type) {
            if (isPrimitiveConverter(Type)) {
                return Type(value);
            }
            var isMemberTest = Type[isMemberSymbol], isMember = false, type = typeof Type, createNew = Type[newSymbol];
            if (isMemberTest !== undefined) {
                isMember = isMemberTest.call(Type, value);
            } else if (type === 'function') {
                if (typeReflections.isConstructorLike(Type)) {
                    isMember = value instanceof Type;
                }
            }
            if (isMember) {
                return value;
            }
            if (createNew !== undefined) {
                return createNew.call(Type, value);
            } else if (type === 'function') {
                if (typeReflections.isConstructorLike(Type)) {
                    return new Type(value);
                } else {
                    return Type(value);
                }
            } else {
                throw new Error('can-reflect: Can not convert values into type. Type must provide `can.new` symbol.');
            }
        }
    };
    module.exports = schemaReflections;
});
/*can-reflect@1.19.0#reflections/get-name/get-name*/
define('can-reflect@1.19.0#reflections/get-name/get-name', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var getNameSymbol = canSymbol.for('can.getName');
    function setName(obj, nameGetter) {
        if (typeof nameGetter !== 'function') {
            var value = nameGetter;
            nameGetter = function () {
                return value;
            };
        }
        Object.defineProperty(obj, getNameSymbol, { value: nameGetter });
    }
    var anonymousID = 0;
    function getName(obj) {
        var type = typeof obj;
        if (obj === null || type !== 'object' && type !== 'function') {
            return '' + obj;
        }
        var nameGetter = obj[getNameSymbol];
        if (nameGetter) {
            return nameGetter.call(obj);
        }
        if (type === 'function') {
            if (!('name' in obj)) {
                obj.name = 'functionIE' + anonymousID++;
            }
            return obj.name;
        }
        if (obj.constructor && obj !== obj.constructor) {
            var parent = getName(obj.constructor);
            if (parent) {
                if (typeReflections.isValueLike(obj)) {
                    return parent + '<>';
                }
                if (typeReflections.isMoreListLikeThanMapLike(obj)) {
                    return parent + '[]';
                }
                if (typeReflections.isMapLike(obj)) {
                    return parent + '{}';
                }
            }
        }
        return undefined;
    }
    module.exports = {
        setName: setName,
        getName: getName
    };
});
/*can-reflect@1.19.0#types/map*/
define('can-reflect@1.19.0#types/map', [
    'require',
    'exports',
    'module',
    '../reflections/shape/shape',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var shape = require('../reflections/shape/shape');
    var CanSymbol = require('can-symbol');
    function keysPolyfill() {
        var keys = [];
        var currentIndex = 0;
        this.forEach(function (val, key) {
            keys.push(key);
        });
        return {
            next: function () {
                return {
                    value: keys[currentIndex],
                    done: currentIndex++ === keys.length
                };
            }
        };
    }
    if (typeof Map !== 'undefined') {
        shape.assignSymbols(Map.prototype, {
            'can.getOwnEnumerableKeys': Map.prototype.keys,
            'can.setKeyValue': Map.prototype.set,
            'can.getKeyValue': Map.prototype.get,
            'can.deleteKeyValue': Map.prototype['delete'],
            'can.hasOwnKey': Map.prototype.has
        });
        if (typeof Map.prototype.keys !== 'function') {
            Map.prototype.keys = Map.prototype[CanSymbol.for('can.getOwnEnumerableKeys')] = keysPolyfill;
        }
    }
    if (typeof WeakMap !== 'undefined') {
        shape.assignSymbols(WeakMap.prototype, {
            'can.getOwnEnumerableKeys': function () {
                throw new Error('can-reflect: WeakMaps do not have enumerable keys.');
            },
            'can.setKeyValue': WeakMap.prototype.set,
            'can.getKeyValue': WeakMap.prototype.get,
            'can.deleteKeyValue': WeakMap.prototype['delete'],
            'can.hasOwnKey': WeakMap.prototype.has
        });
    }
});
/*can-reflect@1.19.0#types/set*/
define('can-reflect@1.19.0#types/set', [
    'require',
    'exports',
    'module',
    '../reflections/shape/shape',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var shape = require('../reflections/shape/shape');
    var CanSymbol = require('can-symbol');
    if (typeof Set !== 'undefined') {
        shape.assignSymbols(Set.prototype, {
            'can.isMoreListLikeThanMapLike': true,
            'can.updateValues': function (index, removing, adding) {
                if (removing !== adding) {
                    shape.each(removing, function (value) {
                        this.delete(value);
                    }, this);
                }
                shape.each(adding, function (value) {
                    this.add(value);
                }, this);
            },
            'can.size': function () {
                return this.size;
            }
        });
        if (typeof Set.prototype[CanSymbol.iterator] !== 'function') {
            Set.prototype[CanSymbol.iterator] = function () {
                var arr = [];
                var currentIndex = 0;
                this.forEach(function (val) {
                    arr.push(val);
                });
                return {
                    next: function () {
                        return {
                            value: arr[currentIndex],
                            done: currentIndex++ === arr.length
                        };
                    }
                };
            };
        }
    }
    if (typeof WeakSet !== 'undefined') {
        shape.assignSymbols(WeakSet.prototype, {
            'can.isListLike': true,
            'can.isMoreListLikeThanMapLike': true,
            'can.updateValues': function (index, removing, adding) {
                if (removing !== adding) {
                    shape.each(removing, function (value) {
                        this.delete(value);
                    }, this);
                }
                shape.each(adding, function (value) {
                    this.add(value);
                }, this);
            },
            'can.size': function () {
                throw new Error('can-reflect: WeakSets do not have enumerable keys.');
            }
        });
    }
});
/*can-reflect@1.19.0#can-reflect*/
define('can-reflect@1.19.0#can-reflect', [
    'require',
    'exports',
    'module',
    './reflections/call/call',
    './reflections/get-set/get-set',
    './reflections/observe/observe',
    './reflections/shape/shape',
    './reflections/shape/schema/schema',
    './reflections/type/type',
    './reflections/get-name/get-name',
    'can-namespace',
    './types/map',
    './types/set'
], function (require, exports, module) {
    'use strict';
    var functionReflections = require('./reflections/call/call');
    var getSet = require('./reflections/get-set/get-set');
    var observe = require('./reflections/observe/observe');
    var shape = require('./reflections/shape/shape');
    var schema = require('./reflections/shape/schema/schema');
    var type = require('./reflections/type/type');
    var getName = require('./reflections/get-name/get-name');
    var namespace = require('can-namespace');
    var reflect = {};
    [
        functionReflections,
        getSet,
        observe,
        shape,
        type,
        getName,
        schema
    ].forEach(function (reflections) {
        for (var prop in reflections) {
            reflect[prop] = reflections[prop];
        }
    });
    require('./types/map');
    require('./types/set');
    module.exports = namespace.Reflect = reflect;
});
/*can-globals@1.2.2#can-globals-proto*/
define('can-globals@1.2.2#can-globals-proto', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var canReflect = require('can-reflect');
        function dispatch(key) {
            var handlers = this.eventHandlers[key];
            if (handlers) {
                var handlersCopy = handlers.slice();
                var value = this.getKeyValue(key);
                for (var i = 0; i < handlersCopy.length; i++) {
                    handlersCopy[i](value);
                }
            }
        }
        function Globals() {
            this.eventHandlers = {};
            this.properties = {};
        }
        Globals.prototype.define = function (key, value, enableCache) {
            if (enableCache === undefined) {
                enableCache = true;
            }
            if (!this.properties[key]) {
                this.properties[key] = {
                    default: value,
                    value: value,
                    enableCache: enableCache
                };
            }
            return this;
        };
        Globals.prototype.getKeyValue = function (key) {
            var property = this.properties[key];
            if (property) {
                if (typeof property.value === 'function') {
                    if (property.cachedValue) {
                        return property.cachedValue;
                    }
                    if (property.enableCache) {
                        property.cachedValue = property.value();
                        return property.cachedValue;
                    } else {
                        return property.value();
                    }
                }
                return property.value;
            }
        };
        Globals.prototype.makeExport = function (key) {
            return function (value) {
                if (arguments.length === 0) {
                    return this.getKeyValue(key);
                }
                if (typeof value === 'undefined' || value === null) {
                    this.deleteKeyValue(key);
                } else {
                    if (typeof value === 'function') {
                        this.setKeyValue(key, function () {
                            return value;
                        });
                    } else {
                        this.setKeyValue(key, value);
                    }
                    return value;
                }
            }.bind(this);
        };
        Globals.prototype.offKeyValue = function (key, handler) {
            if (this.properties[key]) {
                var handlers = this.eventHandlers[key];
                if (handlers) {
                    var i = handlers.indexOf(handler);
                    handlers.splice(i, 1);
                }
            }
            return this;
        };
        Globals.prototype.onKeyValue = function (key, handler) {
            if (this.properties[key]) {
                if (!this.eventHandlers[key]) {
                    this.eventHandlers[key] = [];
                }
                this.eventHandlers[key].push(handler);
            }
            return this;
        };
        Globals.prototype.deleteKeyValue = function (key) {
            var property = this.properties[key];
            if (property !== undefined) {
                property.value = property.default;
                property.cachedValue = undefined;
                dispatch.call(this, key);
            }
            return this;
        };
        Globals.prototype.setKeyValue = function (key, value) {
            if (!this.properties[key]) {
                return this.define(key, value);
            }
            var property = this.properties[key];
            property.value = value;
            property.cachedValue = undefined;
            dispatch.call(this, key);
            return this;
        };
        Globals.prototype.reset = function () {
            for (var key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    this.properties[key].value = this.properties[key].default;
                    this.properties[key].cachedValue = undefined;
                    dispatch.call(this, key);
                }
            }
            return this;
        };
        canReflect.assignSymbols(Globals.prototype, {
            'can.getKeyValue': Globals.prototype.getKeyValue,
            'can.setKeyValue': Globals.prototype.setKeyValue,
            'can.deleteKeyValue': Globals.prototype.deleteKeyValue,
            'can.onKeyValue': Globals.prototype.onKeyValue,
            'can.offKeyValue': Globals.prototype.offKeyValue
        });
        module.exports = Globals;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#can-globals-instance*/
define('can-globals@1.2.2#can-globals-instance', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './can-globals-proto'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var Globals = require('./can-globals-proto');
        var globals = new Globals();
        if (namespace.globals) {
            throw new Error('You can\'t have two versions of can-globals, check your dependencies');
        } else {
            module.exports = namespace.globals = globals;
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#global/global*/
define('can-globals@1.2.2#global/global', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        globals.define('global', function () {
            return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : typeof process === 'object' && {}.toString.call(process) === '[object process]' ? global : window;
        });
        module.exports = globals.makeExport('global');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-import-module@1.3.0#loader/steal-optimized*/
define('can-import-module@1.3.0#loader/steal-optimized', [
    'require',
    'exports',
    'module',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var getGlobal = require('can-globals/global/global');
        var global = getGlobal();
        module.exports = function (moduleName, parentName) {
            if (typeof global.stealRequire !== 'undefined') {
                return steal.import(moduleName, { name: parentName });
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-import-module@1.3.0#loader/system*/
define('can-import-module@1.3.0#loader/system', [
    'require',
    'exports',
    'module',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var getGlobal = require('can-globals/global/global');
        var global = getGlobal();
        function isFunction(fn) {
            return typeof fn === 'function';
        }
        module.exports = function (moduleName, parentName) {
            if (typeof global.System === 'object' && isFunction(global.System['import'])) {
                return global.System['import'](moduleName, { name: parentName });
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-import-module@1.3.0#loader/es6*/
define('can-import-module@1.3.0#loader/es6', [
    'require',
    'exports',
    'module',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var getGlobal = require('can-globals/global/global');
        module.exports = function (moduleName) {
            if ('HTMLScriptElement' in getGlobal() && 'noModule' in HTMLScriptElement.prototype) {
                if (!(moduleName.match(/[^\\\/]\.([^.\\\/]+)$/) || [null]).pop()) {
                    moduleName += '.js';
                }
                return import(moduleName.replace(/['"]+/g, ''));
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#is-node/is-node*/
define('can-globals@1.2.2#is-node/is-node', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        globals.define('isNode', function () {
            return typeof process === 'object' && {}.toString.call(process) === '[object process]';
        });
        module.exports = globals.makeExport('isNode');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-import-module@1.3.0#loader/node*/
define('can-import-module@1.3.0#loader/node', [
    'require',
    'exports',
    'module',
    'can-globals/is-node/is-node'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var isNode = require('can-globals/is-node/is-node');
        module.exports = function (moduleName) {
            if (isNode()) {
                return Promise.resolve(require(moduleName));
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-import-module@1.3.0#loader/require*/
define('can-import-module@1.3.0#loader/require', [
    'require',
    'exports',
    'module',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var getGlobal = require('can-globals/global/global');
        var global = getGlobal();
        module.exports = function (moduleName) {
            if (global.define && global.define.amd) {
                return new Promise(function (resolve, reject) {
                    global.require([moduleName], function (value) {
                        resolve(value);
                    });
                });
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-import-module@1.3.0#can-import-module*/
define('can-import-module@1.3.0#can-import-module', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './loader/steal-optimized',
    './loader/system',
    './loader/es6',
    './loader/node',
    './loader/steal-optimized',
    './loader/es6',
    './loader/node',
    './loader/require',
    './loader/system'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var loader = [];
    function addLoader(fn) {
        if (typeof fn === 'function') {
            loader.push(fn);
        }
    }
    function flushLoader() {
        loader = [];
    }
    function preset(preset) {
        flushLoader();
        switch (preset) {
        case 'stealjs':
            addLoader(require('./loader/steal-optimized'));
            addLoader(require('./loader/system'));
            break;
        case 'ES2020':
        case 'es2020':
        case 'dynamic-import':
            addLoader(require('./loader/es6'));
            break;
        case 'node':
            addLoader(require('./loader/node'));
            break;
        case 'all':
        default:
            addLoader(require('./loader/steal-optimized'));
            addLoader(require('./loader/es6'));
            addLoader(require('./loader/node'));
            addLoader(require('./loader/require'));
            addLoader(require('./loader/system'));
            break;
        }
    }
    preset('all');
    module.exports = namespace.import = function (moduleName, parentName) {
        return new Promise(function (resolve, reject) {
            try {
                var loaderPromise;
                for (var i = loader.length - 1; i >= 0; i--) {
                    loaderPromise = loader[i](moduleName, parentName);
                    if (loaderPromise) {
                        break;
                    }
                }
                if (loaderPromise) {
                    loaderPromise.then(resolve, reject);
                } else {
                    reject('no proper module-loader available');
                }
            } catch (err) {
                reject(err);
            }
        });
    };
    module.exports.addLoader = addLoader;
    module.exports.flushLoader = flushLoader;
    module.exports.preset = preset;
});
/*can-import-module@1.3.0#test/browser-test*/
define('can-import-module@1.3.0#test/browser-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../can-import-module'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var moduleImport = require('../can-import-module');
    var prefix;
    QUnit.module('can-import-module', {
        before: function () {
            if (QUnit.config.modules.length > 1) {
                prefix = {
                    npm: 'can-import-module/test',
                    esm: '/node_modules/can-import-module/test'
                };
            } else {
                prefix = {
                    npm: '~/test',
                    esm: '/test'
                };
            }
        }
    });
    QUnit.test('load npm library via default config (SystemJS first)', function (assert) {
        return moduleImport('can-import-module/test/cjs-module').then(function (data) {
            assert.equal(data, 'Hello from cjs-module');
        }).then(null, function (err) {
            assert.ok(false, err);
        });
    });
    QUnit.test('load es6 module with dynamic import', function (assert) {
        moduleImport.preset('es2020');
        return moduleImport(prefix.esm + '/es6-module').then(function (module) {
            assert.equal(module.default, 'Hello from es6-module');
        }).then(null, function (err) {
            assert.ok(false, err);
        });
    });
    QUnit.test('custom loader', function (assert) {
        moduleImport.flushLoader();
        moduleImport.addLoader(function (moduleName) {
            return import(moduleName.replace('cjs', 'es6'));
        });
        return moduleImport(prefix.esm + '/cjs-module.js').then(function (module) {
            assert.equal(module.default, 'Hello from es6-module', 'es6 module loaded');
        }).then(null, function (err) {
            assert.ok(false, err);
        });
    });
    QUnit.test('presets', function (assert) {
        moduleImport.preset('node');
        return moduleImport(prefix.npm + '/cjs-module.js').then(function () {
            assert.ok(false);
        }, function (err) {
            assert.equal(err, 'no proper module-loader available');
        });
    });
});
/*can-import-module@1.3.0#test*/
define('can-import-module@1.3.0#test', [
    'can-import-module@1.3.0#test/cjs-module',
    'can-import-module@1.3.0#test/browser-test',
    'steal-qunit@2.0.0#steal-qunit',
    '@loader',
    'qunit@2.19.4#qunit/qunit',
    'steal-qunit@2.0.0#add-dom',
    'qunit@2.19.4#qunit/qunit.css!steal-css@1.3.2#css',
    'can-import-module@1.3.0#can-import-module',
    'can-namespace@1.0.0#can-namespace',
    'can-import-module@1.3.0#loader/steal-optimized',
    'can-globals@1.2.2#global/global',
    'can-globals@1.2.2#can-globals-instance',
    'can-globals@1.2.2#can-globals-proto',
    'can-reflect@1.19.0#can-reflect',
    'can-reflect@1.19.0#reflections/call/call',
    'can-symbol@1.7.0#can-symbol',
    'can-reflect@1.19.0#reflections/type/type',
    'can-reflect@1.19.0#reflections/helpers',
    'can-reflect@1.19.0#reflections/get-set/get-set',
    'can-reflect@1.19.0#reflections/observe/observe',
    'can-reflect@1.19.0#reflections/shape/shape',
    'can-reflect@1.19.0#reflections/shape/schema/schema',
    'can-reflect@1.19.0#reflections/get-name/get-name',
    'can-reflect@1.19.0#types/map',
    'can-reflect@1.19.0#types/set',
    'can-import-module@1.3.0#loader/system',
    'can-import-module@1.3.0#loader/es6',
    'can-import-module@1.3.0#loader/node',
    'can-globals@1.2.2#is-node/is-node',
    'can-import-module@1.3.0#loader/require'
], function () {
    'use strict';
});